// YSLib::Definitions by Franksoft 2010
// CodePage = UTF-8;
// CTime = 2010-01-26 19:34:51 + 08:00;
// UTime = 2010-10-15 12:58 + 08:00;
// Version = r8691;


// Definitions ：方法和公共域定义与说明。

/*

体例说明：

（文档专用）外部语义位置标记符：
@ //作用于可打印字符或空白符（见以下定义）的字符序列，表示逻辑位置。

以下列表中的概念参考 ISO/IEC-14882:2003 - The C++ Programing Language （以下简称“语言标准”）：
翻译单元(translation unit) ：(@2|1 [lex])；
字符集(character set) ：(@2.2 [lex.charset])；
预处理记号(preprocessing token) ：(@2.4 [lex.pptoken])；
记号(token) ：(@2.6 [lex.token])；
注释(comment) ：(@2.7 [lex.comment])；
头文件名(header name) ：(@2.8 [lex.header])；
标识符(identifier) ：(@2.10 [lex.name])；
关键字(keyword) ：(@2.11 [lex.key])；
操作符(operator) ：(@2.11 [lex.operators])；
标点符(punctuator) ：(@2.11 [lex.operators])；
字面量(literal) ：(@2.13 [lex.literals])；
转义[字符]序列(escape sequence) ：(@2.13.2 [lex.ccon])；
实体(entity) ：(@3|3 [basic])；
名称(name) ：(@3|4 [basic])；
作用域(scope) ：(@3.3|1 [basic.scope])；
链接(linkage) ：(@3.5 [basic.link])；
存储期(storage duration) ：(@3.7 [basic.stc])；
类型(type) ：(@3.9 [basic.types])；
对象类型(object type) ：(@3.9 [basic.types])；
不完整类型(incomplete type) ：(@3.9.1 [basic.fundamental])；
命名空间(namespace) ：(@7.3 [basic.namespace])。

以下内容参考语言标准相关描述：
续行/断行连接(line continuation) ：(@2.1|2 [lex.phases])，“splicing physical source lines to form logical source lines”。

以下为附加语法和语义说明。

类预处理器语法：
#region $name_exp //表示字符序列 $name_exp 标记的位置，可用于标记段落。供文档规格化工具使用。
其它预处理指令同语言标准。

外部语义链接标记符：
$ //作用于受限制的字符序列（语言规范中定义的标识符或关键字）前，表示该字符序列不由编译程序提供语义实现。
$import //导入实体。
$export //导出实体，显式使用表示强调无论实现如何，应该向外部提供形式上和之后说明一致的接口。

全局域关键字：
$code {} //表示（源）代码段。
$unit $unit_name //单元：指称一个编译单元（一般应为语言规范中定义的翻译单元）。单元名称 $unit_name 为可变部分，是语言规范中定义的标识符或关键字。
$header $header_name //头文件：指称一个头文件。头文件名标识字符序列 $header_name 是可变部分，同语言标准中 #include $header_name 的用法。

*/

#region synopsis(begin)

//平台定义文件（platform.h）定义示例。

$code $header <platform.h> {


#ifndef _ATTRIBUTE
#	ifdef __GNUC__
#		define _ATTRIBUTE(attrs) __attribute__ (attrs)
#	else
#		define _ATTRIBUTE(attrs)
#	endif
#endif


//$example:
//字符兼容性补充。

#include <stdint.h>

namespace std
{
	typedef ::uint16_t char16_t;
	typedef ::uint32_t char32_t;
}


//$example:
$import $header <nds.h>, <fat.h>, <unistd.h>, <sys/dir.h>;

//像素类型。
$import type $pixeltype;

$import typedef signed char s8;
$import typedef unsigned char u8;
$import typedef signed short s16;
$import typedef unsigned short u16;
$import typedef signed long s32;
$import typedef unsigned long u32;

//主屏幕的宽与高。
extern const u16 $SCREEN_WIDTH, $SCREEN_HEIGHT;

//定义使用 Unicode 编码字符串。
#ifndef UNICODE
#	define UNICODE
//宽字符支持。
#	define CHRLIB_WCHAR_T_SIZE 4
#endif

} //$code;


// CHRLib 定义。

$code CHRLib {

$import typedef unsigned short u16;

$header CHRDefinition "chrdef.h" //类型定义。
{
	$import <platform.h>;


	#define CHRLIB_BEGIN	namespace CHRLib {
	#define CHRLIB_END		}
	#define _CHRLIB_			::CHRLib::
	#define _CHRLIB			::CHRLib

	#define CHRLIB_BEGIN_NAMESPACE(s)	namespace s {
	#define CHRLIB_END_NAMESPACE(s)	}

	CHRLIB_BEGIN

	typedef unsigned char ubyte_t;
	typedef unsigned long usize_t;

	//字符类型定义。
	typedef std::char32_t fchar_t; // UCS-4 字符。
	typedef std::char16_t uchar_t; // UCS-2 字符。
	typedef s32 uint_t;

	//宽字符串转换宏。
	#define FS(str) static_cast<const CHRLib::fchar_t*>(L##str)

	typedef enum {Deg0 = 0, Deg90 = 1, Deg180 = 2, Deg270 = 3} CROT;

	CHRLIB_END

} //$header CHRDefinition;


$unit CharacterMapping "chrmap.h" //字符映射。
{
	$import $unit CHRDefinition, $header <cstdio>;


	CHRLIB_BEGIN

	CHRLIB_BEGIN_NAMESPACE(CharSet)

	//编码字符集：使用 IANA 官方字符集名称和 MIBenum ，详见 http://www.iana.org/assignments/character-sets 。
	typedef enum
	{
		//保留。
		Null = 0, //空字符集。
		Reserved_1 = 1,
		Reserved_2 = 2,

		US_ASCII = 3,
		SHIFT_JIS = 17,
		KS_C_5601_1987 = 36,
		EUC_KR = 38,
	//	ASMO_449 = 65,
		UTF_8 = 106,
		GBK = 113,
		GB18030 = 114,

		ISO_10646_UCS_2 = 1000,
		ISO_10646_UCS_4 = 1001,
		ISO_10646_UCS_Basic = 1002,

		UTF_7 = 1012,
		UTF_16BE = 1013,
		UTF_16LE = 1014,
		UTF_16 = 1015,
		UTF_32 = 1017,
		UTF_32BE = 1018,
		UTF_32LE = 1019,

		GB2312 = 2025, //仅 EUC-CN ，GB2312 最常用实现。
		Big5 = 2026,

		//其它。
		/*
		HZ_GB_2312 = 52396, // Chinese Simplified (HZ)，GB2312 的另一种实现。
		MIK, // Supports Bulgarian and Russian as well
		*/
	} CSID; //字符集标识。

	//别名。
	const CSID
		iso_ir_6(US_ASCII), ISO646_US(US_ASCII), ASCII(US_ASCII), us(US_ASCII), IBM367(US_ASCII), cp367(US_ASCII), csASCII(US_ASCII),
		MS_Kanji(SHIFT_JIS), csShiftJIS(SHIFT_JIS), windows_932_(SHIFT_JIS),
		iso_ir_149(KS_C_5601_1987), KS_C_5601_1989(KS_C_5601_1987), KSC_5601(KS_C_5601_1987), korean(KS_C_5601_1987), csKSC56011987(KS_C_5601_1987), windows_949_(KS_C_5601_1987),
		windows_65001_(UTF_8),
		CP936(GBK), MS936(GBK), windows_936(GBK),
		windows_54936_(GB18030),

		csUnicode(ISO_10646_UCS_2),
		csUCS4(ISO_10646_UCS_4),
		csUnicodeASCII(ISO_10646_UCS_Basic),
		windows_1201_(UTF_16BE),
		windows_1200_(UTF_16LE),

		csGB2312(GB2312), EUC_CN_(GB2312), windows_51936_(GB2312),
		windows_950_(Big5);

	CHRLIB_END_NAMESPACE(CharSet)

	using CharSet::CSID;

	//默认字符集。
	const CSID CS_Default = CharSet::UTF_8;
	const CSID CS_Local = CharSet::GBK;


	//编码转换表。
	const ubyte_t cp17[] = {0};
	extern "C"
	{
		extern const ubyte_t cp113[];
		//extern const ubyte_t cp2026[13658];
	}
	const ubyte_t cp2026[] = {0};


	//取小端序双字节字符。
	inline u16
	getword_LE(const char* c);
	//取大端序双字节字符。
	inline u16
	getword_BE(const char* c);


	//编码映射函数类型定义。
	typedef uchar_t CMF(ubyte_t&, const char*);
	typedef uchar_t CMF_File(ubyte_t&, FILE*);


	//未实现的编码映射函数模板原型。
	template<CSID>
	CMF codemap;
	template<CSID>
	CMF_File codemap;

	//编码映射函数模板特化版本。

	template<>
	uchar_t
	codemap<CharSet::SHIFT_JIS>(ubyte_t&, const char*);
	template<>
	uchar_t
	codemap<CharSet::SHIFT_JIS>(ubyte_t&, FILE*);

	template<>
	uchar_t
	codemap<CharSet::UTF_8>(ubyte_t&, const char*);
	template<>
	uchar_t
	codemap<CharSet::UTF_8>(ubyte_t&, FILE*);

	template<>
	uchar_t
	codemap<CharSet::GBK>(ubyte_t&, const char*);
	template<>
	uchar_t
	codemap<CharSet::GBK>(ubyte_t&, FILE*);

	template<>
	uchar_t
	codemap<CharSet::UTF_16BE>(ubyte_t&, const char*);
	template<>
	uchar_t
	codemap<CharSet::UTF_16BE>(ubyte_t&, FILE*);

	template<>
	uchar_t
	codemap<CharSet::UTF_16LE>(ubyte_t&, const char*);
	template<>
	uchar_t
	codemap<CharSet::UTF_16LE>(ubyte_t&, FILE*);

	template<>
	uchar_t
	codemap<CharSet::Big5>(ubyte_t&, const char*);
	template<>
	uchar_t
	codemap<CharSet::Big5>(ubyte_t&, FILE*);

	CHRLIB_END

} //$unit CharacterMapping;


$unit CharacterProcessing "chrproc" //字符编码处理。
{
	$import $unit CHRDefinition, CharacterMapping, $header <cctype>, <cstdlib>, <cstring>, <cwchar>;


	CHRLIB_BEGIN

	//判断是否为 ASCII 字符。
	template<typename _tChar>
	inline bool
	IsASCII(_tChar c);

	//计算 UCS-2 字符串长度。
	usize_t
	ucslen(const uchar_t*);

	//逐字节比较 UCS-2 字符串。
	uchar_t
	ucscmp(const uchar_t*, const uchar_t*);

	//逐字节比较 UCS-2 字符串（忽略大小写）。
	uchar_t
	ucsicmp(const uchar_t*, const uchar_t*);

	//宽字符转换为 ASCII 字符（截取低字节）。
	template<typename _tChar>
	inline char
	ToASCII(_tChar c);

	//按字符集转换字符串中字符为 UCS-2 字符，返回转换的字节数。
	ubyte_t
	ToUTF(const char*, uchar_t&, const CSID&);
	//按字符集转换字符流中字符为 UCS-2 字符，返回转换的字节数。
	ubyte_t
	ToUTF(FILE*, uchar_t&, const CSID&);

	//转换 MBCS 字符串为 ANSI 字符串（非 ANSI 字符替换为第三参数），返回转换的串长。
	usize_t
	MBCSToANSI(char*, const char*, char = ' ');
	//转换 UCS2 字符串为 ANSI 字符串（非 UTF16LE 字符替换为第三参数），返回转换的串长。
	usize_t
	UCS2ToANSI(char*, const uchar_t*, char = ' ');
	//转换 UCS4 字符串为 ANSI 字符串（非 UTF16BE 字符替换为第三参数），返回转换的串长。
	usize_t
	UCS4ToANSI(char*, const fchar_t*, char = ' ');

	//按字符集转换 MBCS 字符串为 UTF-16LE 字符串，返回转换的串长。
	usize_t
	MBCSToUTF16LE(uchar_t*, const char*, const CSID& = CS_Default);
	//按字符集转换 MBCS 字符串为 UCS-4 字符串，返回转换的串长。
	usize_t
	MBCSToUCS(fchar_t*, const char*, const CSID& = CS_Default);
	//按字符集转换 UTF-16LE 字符串为 MBCS 字符串，返回转换的串长。
	usize_t
	UTF16LEToMBCS(char*, const uchar_t*, const CSID& = CS_Default);
	//转换 UCS-4 字符串为 UCS-2 字符串，返回转换的串长。
	usize_t
	UCS4ToUCS2(uchar_t*, const fchar_t*);

	//复制 MBCS 字符串为 ANSI 字符串（非 ANSI 字符替换为第二参数）。空间由 free() 释放。
	char*
	sdup(const char*, char = ' ');
	//复制 UCS-2 字符串为 ANSI 字符串（非 ANSI 字符替换为第二参数）。空间由 free() 释放。
	char*
	sdup(const uchar_t*, char = ' ');
	//复制 UCS-4 字符串为 ANSI 字符串（非 ANSI 字符替换为第二参数）。空间由 free() 释放。
	char*
	sdup(const fchar_t*, char = ' ');

	//复制 MBCS 字符串为 UCS-2/UTF-16LE 字符串。空间由 free() 释放。
	uchar_t*
	ucsdup(const char*, const CSID& = CS_Default);
	//复制 UCS-2 字符串。空间由 free() 释放。
	uchar_t*
	ucsdup(const uchar_t*);
	//复制 UCS-4 字符串为 UCS-2 字符串。空间由 free() 释放。
	uchar_t*
	ucsdup(const fchar_t*);

	CHRLIB_END

} //$unit CharacterProcessing;

} //$code CHRLib;


// YCLib 定义。

$code $export YCLib {

$import $header <platform.h>;

$header YDefinition "ydef.h" //系统环境和公用变量类型的基础定义。
{
	#ifdef __cplusplus
	extern "C" {
	#endif

	#if defined __GNUC__ || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)

	#	include <stddef.h>
	#	include <stdint.h>

	typedef intptr_t INT_PTR;
	typedef uintptr_t UINT_PTR;

	#else

	typedef int INT_PTR;
	typedef unsigned int UINT_PTR;

	#endif

	typedef long LONG_PTR;
	typedef unsigned long ULONG_PTR;


	#define _nullterminated

	#undef FALSE
	#define FALSE 0

	#undef TRUE
	#define TRUE 1

	#ifndef BASETYPES
	#define BASETYPES
	typedef unsigned char UCHAR, *PUCHAR;
	typedef unsigned short USHORT, *PUSHORT;
	typedef unsigned long ULONG, *PULONG;
	typedef char* PSZ;
	#endif

	typedef int             BOOL;
	typedef unsigned char   BYTE;
	typedef unsigned short  WORD;
	typedef unsigned long   DWORD;


	typedef void FVOID(void);
	typedef FVOID *PFVOID;


	// UCS(Universal Character Set) 字符类型定义。

	typedef unsigned long UCSCHAR;

	#define UCSCHAR_INVALID_CHARACTER (0xFFFFFFFF)
	#define MIN_UCSCHAR (0)
	#define MAX_UCSCHAR (0x0010FFFF)


	typedef INT_PTR			IRES;
	typedef UINT_PTR		URES;
	typedef LONG_PTR		LRES;

	typedef UINT_PTR        WPARAM;
	typedef LONG_PTR        LPARAM;

	typedef IRES			ERRNO;

	#define LOBYTE(w)       ((BYTE)(((DWORD_PTR)(w)) & 0xff))
	#define HIBYTE(w)       ((BYTE)((((DWORD_PTR)(w)) >> 8) & 0xff))
	#define LOWORD(l)       ((WORD)(((DWORD_PTR)(l)) & 0xffff))
	#define HIWORD(l)       ((WORD)((((DWORD_PTR)(l)) >> 16) & 0xffff))
	#define MAKEWORD(a, b)  ((WORD)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((WORD)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8))
	#define MAKELONG(a, b)  ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16))

	typedef char* STR;
	typedef const char* CSTR;

	//路径类型定义。
	typedef char* PATH;
	typedef const char* CPATH;

	#ifdef __cplusplus
	}
	#endif

} //$header YDefinition;


$unit YCommon "ycommon" //平台相关的公共组件无关函数与宏定义集合。
{
	//最大路径长度。
	$export #define YC_MAX_PATH;

	#ifndef UNICODE
	#define UNICODE
	#endif
	
	$import $header "ydef.h", <cstdio>,
		<cstdarg>, <cstring>, <cstdarg>;

	//平台无关部分。

	namespace stdex
	{
		//当字符指针非空时返回 std::strlen 计算的串长，否则返回 0 。
		std::size_t
		strlen_n(const char*);

		//当目标字符串和源字符串都非空时用 std::strcpy 复制字符串并返回复制的字符串，否则返回空指针。
		char*
		strcpy_n(char*, const char*);

		//当目标字符串和源字符串都非空时用 stpcpy 复制字符串并返回复制的字符串的结尾指针，否则返回空指针。
		char*
		stpcpy_n(char*, const char*);

		//当两个字符串都非空时返回 stricmp 比较的字符串结果，否则返回 EOF 。
		int
		stricmp_n(const char*, const char*);

		//当字符指针非空时用 strdup 复制字符串并返回复制的字符串，否则返回空指针。
		char*
		strdup_n(const char*);

		//串接给定的两个字符串，结果复制至指定位置（对传入参数进行非空检查），返回目标参数。
		char*
		strcpycat(char*, const char*, const char*);

		//串接给定的两个字符串，结果复制至用指定分配函数（默认为 std::malloc）新分配的空间（对传入参数进行非空检查），返回目标参数。
		char*
		strcatdup(const char*, const char*, void*(*)(std::size_t) = std::malloc);


		//通过 C 标准函数库操作判断给定路径的文件是否存在。
		bool
		fexists(CPATH);
	} //namespace stdex;


	//平台相关部分。

	//最大路径长度。
	#define YC_MAX_PATH MAXPATHLEN;

	namespace platform
	{
		using ::iprintf;

		//当 buf 非空时取当前工作目录复制至 buf 起始的长为 t 的缓冲区中，并返回 buf 。
		char*
		getcwd_n(char* buf, std::size_t);

		//判断指定目录是否存在。
		bool
		direxists(CPATH);

		using ::mkdir;
		using ::chdir;

		//按路径新建一个或多个目录。
		bool
		mkdirs(CPATH);


		//异常终止函数。
		void
		terminate();


		typedef u16 PixelType; //像素。
		typedef PixelType* BitmapPtr;
		typedef const PixelType* ConstBitmapPtr;
		typedef PixelType ScreenBufferType[SCREEN_WIDTH * SCREEN_HEIGHT]; //主显示屏缓冲区。
		#define BITALPHA BIT(15) // Alpha 位。


		//系统默认颜色空间。
		class Color
		{
		public:
			typedef enum ColorSet
			{

		//	#define DefColorA(r, g, b, name) name = ARGB16(1, r, g, b),
			#define	HexAdd0x(hex) 0x##hex
			#define DefColorH_(hex, name) name = RGB8(((hex >> 16) & 0xFF), ((hex >> 8) & 0xFF), (hex & 0xFF)) | BITALPHA
			#define DefColorH(hex_, name) DefColorH_(HexAdd0x(hex_), name),

			//参考：http://www.w3schools.com/html/html_colornames.asp 。

				DefColorH(00FFFF, Aqua)
				DefColorH(000000, Black)
				DefColorH(0000FF, Blue)
				DefColorH(FF00FF, Fuchsia)
				DefColorH(808080, Gray)
				DefColorH(008000, Green)
				DefColorH(00FF00, Lime)
				DefColorH(800000, Maroon)
				DefColorH(000080, Navy)
				DefColorH(808000, Olive)
				DefColorH(800080, Purple)
				DefColorH(FF0000, Red)
				DefColorH(C0C0C0, Silver)
				DefColorH(008080, Teal)
				DefColorH(FFFFFF, White)
				DefColorH(FFFF00, Yellow)

			#undef DefColorH
			#undef DefColorH_
			#undef HexAdd0x

			} ColorSet;

		private:
			PixelType _value;

		public:
			Color(PixelType = 0);
			Color(u8, u8, u8, bool = true);

			operator PixelType() const;
		};


		//按键集合。
		class Key
		{
		public:
			typedef enum KeySet
			{
				Empty	= 0,
				A		= KEY_A,
				B		= KEY_B,
				Select	= KEY_SELECT,
				Start	= KEY_START,
				Right	= KEY_RIGHT,
				Left	= KEY_LEFT,
				Up		= KEY_UP,
				Down	= KEY_DOWN,
				R		= KEY_R,
				L		= KEY_L,
				X		= KEY_X,
				Y		= KEY_Y,
				Touch	= KEY_TOUCH,
				Lid		= KEY_LID
			} KeySet;
			typedef u32 InputType;

		private:
			InputType _value;

		public:
			//按键别名。
			static const KeySet
				Enter = A,
				ESC = B,
				PgUp = L,
				PgDn = R;

			Key(InputType = 0);

			operator InputType() const;
		}; //class Key;


		//按键信息。
		typedef struct KeysInfo
		{
			Key up, down, held;
		} KeysInfo;


		//屏幕光标信息。
		typedef struct CursorInfo : public ::touchPosition
		{
			u16 GetX() const;
			u16 GetY() const;
		} CursorInfo;


		//调试模式：设置状态。
		void
		YDebugSetStatus(bool = true);

		//调试模式：取得状态。
		bool
		YDebugGetStatus();

		//调试模式：显示（fc 为前景色，bc为背景色）。
		void
		YDebugBegin(Color fc = Color::White, Color bc = Color::Blue);

		//调试模式：按键继续。
		void
		YDebug();
		//调试模式：显示控制台字符串，按键继续。
		void
		YDebug(const char*);

		//调试模式：显示控制台字（int 型数据），按键继续。
		void
		YDebugW(int);

		//调试模式：显示控制台 printf ，按键继续。
		int
		yprintf(const char*, ...)
			_ATTRIBUTE ((format (printf, 1, 2)));

		//断言。
		#ifdef YC_USE_YASSERT

		#undef YAssert

		inline void
		yassert(bool exp, const char* expstr, const char* message, int line, const char* file);

		#define YAssert(exp, message) yassert(exp, #exp, message, __LINE__, __FILE__);

		#else

		#	include <cassert>
		#	define YAssert(exp, message) assert(exp)

		#endif


		//定长路径字符串类型。
		typedef char PATHSTR[MAXPATHLEN];


		//目录迭代器。
		class HDirectory
		{
		public:
			typedef ::DIR_ITER* IteratorType;

			static PATHSTR name; //节点名称。
			static struct ::stat Stat; //节点状态信息。
			static int LastError; //上一次操作结果，0 为无错误。

		private:
			IteratorType dir;

		public:
			inline explicit
			HDirectory(CPATH = NULL);

		private:
			inline HDirectory(IteratorType&);

		public:
			inline ~HDirectory();

			inline HDirectory&
			operator++();
			inline HDirectory
			operator++(int);

			inline bool
			IsValid() const; //判断文件系统节点是否有效。
			static bool
			IsDirectory(); //从节点状态信息判断是否为目录。

			inline void
			Open(CPATH);

			inline void
			Close();

			inline void
			Reset();
		}; //class HDirectory;


		//判断是否为绝对路径。
		bool
		IsAbsolute(CPATH) throw();

		//取给定路径的文件系统根节点名称的长度。
		std::size_t
		GetRootNameLength(CPATH);

		//快速刷新缓存映像到主显示屏。
		inline void
		scrCopy(PixelType* scr, const PixelType* buf);

		//复位屏幕显示模式。
		void
		ResetVideo();


		//启动控制台（fc 为前景色，bc为背景色）。
		void
		YConsoleInit(u8 dspIndex, Color fc = Color::White, Color bc = Color::Black);

		//输出控制台字（int 型数据）。
		inline void
		iputw(int n);


		//等待任意按键。
		void
		WaitForInput();

		//等待 mask 包含的按键。
		void
		WaitForKey(u32 mask);

		//等待任意按键（除触摸屏、翻盖外）。
		inline void
		WaitForKeypad()

		//等待任意按键（除 L 、 R 和翻盖外）。
		inline void
		WaitForFrontKey()

		//等待任意按键（除 L 、 R 、触摸屏和翻盖外）。
		inline void
		WaitForFrontKeypad()

		//等待方向键。
		inline void
		WaitForArrowKey()

		//等待按键 A 、 B 、 X 、 Y 键。
		inline void
		WaitForABXY()


		//写入当前按键信息。
		void
		WriteKeysInfo(KeysInfo&, CursorInfo&);


		//寄存器 - 毫秒转换。
		inline vu32
		timers2msRaw(vu16, vu16);
		inline vu32
		timers2ms(vu16, vu16);

		//初始化计时器。
		void
		InitTimers(vu16&, vu16&);
		void
		InitTimers();

		//清除计时器。
		inline void
		ClearTimers(vu16& = TIMER0_DATA, vu16& = TIMER1_DATA);

		//初始化实时时钟。
		inline void
		InitRTC();

		//清除实时时钟。
		inline void
		ClearRTC();

		//复位实时时钟。
		inline void
		ResetRTC();

		//取实时时钟计数。
		inline vu32
		GetRTC();

		//开始 tick 计时。
		void
		StartTicks();

		//取 tick 数。
		u32
		GetTicks();

		//延时 ms 毫秒（ms 仅低 25 位有效）。
		void
		Delay(u32 ms);
	} //namespace platform;

} //$unit YCommon;

} //$code YCLib;


// YSLib 定义。

$code YSLib {

$export adaptor YSLib::Adaptor::YAdaptor;

using namespace ::YSLib;


$code YSLib::Adaptor {

$header Base "base.h" //通用基础设施。
{
	!$import;


	/*
	 ISO/IEC C++ 未确定宏定义内 # 和 ## 操作符求值顺序。
	 GCC 中，宏定义内 ## 操作符修饰的形式参数为宏时，该宏不会被展开。详见： http://gcc.gnu.org/onlinedocs/cpp/Concatenation.html 。
	解决方案来源： https://www.securecoding.cert.org/confluence/display/cplusplus/PRE05-CPP.+Understand+macro+replacement+when+concatenating+tokens+or+performing+stringification 。
	*/
	#define _yJOIN(x, y) x ## y


	// YSLib 命名空间宏。

	#define YSL_BEGIN	namespace YSLib {
	#define YSL_END		}
	#define YSL_			::YSLib::
	#define YSL			::YSLib

	#define YSL_BEGIN_NAMESPACE(s)	namespace s {
	#define YSL_END_NAMESPACE(s)		}

	#define YSL_BEGIN_SHELL(s)	namespace _yJOIN(_YSHL_, s) {
	#define YSL_END_SHELL(s)	}
	#define YSL_SHL_(s)		YSL_ _yJOIN(_YSHL_, s)::
	#define YSL_SHL(s)		YSL_ _yJOIN(_YSHL_, s)


	//异常规范宏。

	// ythrow = "yielded throwing";
	#ifdef YSL_USE_EXCEPTION_SPECIFICATION
	#	define ythrow throw
	#else
	#	define ythrow(...)
	#endif


	//接口类型宏。

	#define __interface struct
	#define _yInterface __interface

	#define implements public

	#define _yInterfaceHead(_name) { \
		virtual ~_name() {}

	//prefix "PDecl" = Pre-declare;
	#define PDeclInterface(_name) _yInterface _name;

	#define DeclInterface(_name) _yInterface _name _yInterfaceHead(_name)

	#ifdef __GNUC__
	//对于基接口需要显示指定访问权限和继承方式。由于接口定义为 struct 类型，因此通常只需指定是否为 virtual 继承。
	#	define DeclBasedInterface(_name, _base...) \
		_yInterface _name : _base _yInterfaceHead(_name)
	#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
	#	define DeclBasedInterface(_name, _base, ...) \
		_yInterface _name : _base, __VA_ARGS__ _yInterfaceHead(_name)
	#else
	//注意 ISO/IEC C++ 不支持宏的可变参数列表，因此无法实现接口多继承。
	#	define DeclBasedInterface(_name, _base) \
		_yInterface _name : _base _yInterfaceHead(_name)
	#endif

	//"DeclIEntry" = Declare Interface Entry;
	#define DeclIEntry(_signature) virtual _signature = 0;

	#define EndDecl };


	//函数宏。

	//通用函数头定义。
	//prefix "PDefH" = Partially Define Head;
	#ifdef __GNUC__
	#	define PDefH(_type, _name, _paralist...) \
		_type _name(_paralist)
	#	define PDefHOperator(_type, _op, _paralist...) \
		_type operator _op(_paralist)
	#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
	#	define PDefH(_type, _name, _paralist, ...) \
		_type _name(_paralist, __VA_ARGS__)
	#	define PDefHOperator(_type, _op, _paralist, ...) \
		_type operator _op(_paralist, __VA_ARGS__)
	#else
	#	define PDefH(_type, _name, _paralist) \
		_type _name(_paralist)
	#	define PDefHOperator(_type, _op, _paralist) \
		_type operator _op(_paralist)
	#endif


	//简单通用函数实现。
	//prefix "Impl" = Implement;
	#define ImplExpr(_expr) \
		{ \
			_expr; \
		}
	#define ImplRet(_expr) \
		{ \
			return _expr; \
		}

	//基类同名函数映射和成员同名函数映射实现。
	//prefix "Impl" = Implement;
	#ifdef __GNUC__
	#	define ImplBodyBase(_base, _name, _arglist...) \
		{ \
			return _base::_name(_arglist); \
		}
	#	define ImplBodyBaseVoid(_base, _name, _arglist...) \
		{ \
			_base::_name(_arglist); \
		}
	#	define ImplBodyMember(_member, _name, _arglist...) \
		{ \
			return (_member)._name(_arglist); \
		}
	#	define ImplBodyMemberVoid(_member, _name, _arglist...) \
		{ \
			(_member)._name(_arglist); \
		}
	#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
	#	define ImplBodyBase(_base, _name, _arglist, ...) \
		{ \
			return _base::_name(_arglist, __VA_ARGS__); \
		}
	#	define ImplBodyBaseVoid(_base, _name, _arglist, ...) \
		{ \
			_base::_name(_arglist, __VA_ARGS__); \
		}
	#	define ImplBodyMember(_member, _name, _arglist...) \
		{ \
			return (_member)._name(_arglist); \
		}
	#	define ImplBodyMemberVoid(_member, _name, _arglist...) \
		{ \
			(_member)._name(_arglist); \
		}
	#else
	#	define ImplBodyBase(_base, _name, _arglist) \
		{ \
			return _base::_name(_arglist); \
		}
	#	define ImplBodyBaseVoid(_base, _name, _arglist) \
		{ \
			_base::_name(_arglist); \
		}
	#	define ImplBodyMember(_member, _name, _arglist) \
		{ \
			return (_member)._name(_arglist); \
		}
	#	define ImplBodyMemberVoid(_member, _name, _arglist) \
		{ \
			(_member)._name(_arglist); \
		}
	#endif


	//简单通用成员函数定义。
	//prefix "Def" = Define;
	#define DefEmptyDtor(_type) \
		~_type() \
		{}

	#define DefConverter(_type, _expr) \
		operator _type() const ythrow() \
		{ \
			return _expr; \
		}
	#define DefConverterBase(_type, _base) \
		operator _type() const ythrow() \
		{ \
			return _base::operator _type(); \
		}
	#define DefConverterMember(_type, _member) \
		operator _type() const ythrow() \
		{ \
			return (_member).operator _type(); \
		}

	#define DefGetter(_type, _name, _member) \
		_type _yJOIN(Get, _name)() const ythrow() \
		{ \
			return (_member); \
		}
	#define DefGetterBase(_type, _name, _base) \
		_type _yJOIN(Get, _name)() const ythrow() \
		{ \
			return _base::_yJOIN(Get, _name)(); \
		}
	#define DefGetterMember(_type, _name, _member) \
		_type _yJOIN(Get, _name)() const ythrow() \
		{ \
			return (_member)._yJOIN(Get, _name)(); \
		}

	#define DefPredicate(_name, _member) \
		bool _yJOIN(Is, _name)() const ythrow() \
		{ \
			return (_member); \
		}
	#define DefPredicateBase(_name, _base) \
		bool _yJOIN(Is, _name)() const ythrow() \
		{ \
			return _base::_yJOIN(Is, _name)(); \
		}
	#define DefPredicateMember(_name, _member) \
		bool _yJOIN(Is, _name)() const ythrow() \
		{ \
			return (_member)._yJOIN(Is, _name)(); \
		}

	#define DefStaticGetter(_type, _name, _member) \
		static _type _yJOIN(Get, _name)() ythrow() \
		{ \
			return (_member); \
		}
	#define DefStaticGetterBase(_type, _name, _base) \
		static _type _yJOIN(Get, _name)() ythrow() \
		{ \
			return _base::_yJOIN(Get, _name)(); \
		}

	#define DefStaticPredicate(_name, _member) \
		static bool _yJOIN(Is, _name)() ythrow() \
		{ \
			return (_member); \
		}
	#define DefStaticPredicateBase(_name, _base) \
		static bool _yJOIN(Is, _name)() ythrow() \
		{ \
			return _base::_yJOIN(Is, _name)(); \
		}

	#define DefSetter(_type, _name, _member) \
		void _yJOIN(Set, _name)(_type _tempArgName) ythrow() \
		{ \
			(_member) = _tempArgName; \
		}
	#define DefSetterDe(_type, _name, _member, _defv) \
		void _yJOIN(Set, _name)(_type _tempArgName = _defv) ythrow() \
		{ \
			(_member) = _tempArgName; \
		}
	#define DefSetterBase(_type, _name, _base) \
		void _yJOIN(Set, _name)(_type _tempArgName) ythrow() \
		{ \
			_base::_yJOIN(Set, _name)(_tempArgName); \
		}
	#define DefSetterBaseDe(_type, _name, _base, _defv) \
		void _yJOIN(Set, _name)(_type _tempArgName = _defv) ythrow() \
		{ \
			_base::_yJOIN(Set, _name)(_tempArgName); \
		}
	#define DefSetterMember(_type, _name, _member) \
		void _yJOIN(Set, _name)(_type _tempArgName) ythrow() \
		{ \
			(_member)._yJOIN(Set, _name)(_tempArgName); \
		}
	#define DefSetterMemberDe(_type, _name, _member, _defv) \
		void _yJOIN(Set, _name)(_type _tempArgName = _defv) ythrow() \
		{ \
			(_member)._yJOIN(Set, _name)(_tempArgName); \
		}
	#define DefSetterEx(_type, _name, _member, _tempArgName, _expr) \
		void _yJOIN(Set, _name)(_type _tempArgName) ythrow() \
		{ \
			(_member) = (_expr); \
		}
	#define DefSetterDeEx(_type, _name, _member, _defv, _tempArgName, _expr) \
		void _yJOIN(Set, _name)(_type _tempArgName = _defv) ythrow() \
		{ \
			(_member) = (_expr); \
		}

} //$header Base;

$header Config "config.h" //库编译配置。
{
	!$import;


	//#define NDEBUG //非调试模式。

	#define YC_USE_YASSERT //使用 YCLib 断言。

	// YSLib 选项。

	#define YSL_USE_EXCEPTION_SPECIFICATION //使用 YSLib 异常规范。

	//#define YSL_MULTITHREAD //多线程。

	#define YSL_USE_COPY_ON_WRITE //写时复制。

	#ifdef YSL_MULTITHREAD
	#	undef YSL_USE_COPY_ON_WRITE
	#endif

	//#define YSL_USE_YASLI_VECTOR //使用 yasli::vector 。
	//#define YSL_USE_FLEX_STRING //使用 flex_string 。
	#define YSL_OPT_SMALL_STRING_LENGTH 16 //使用小字符串优化。

	/*
	YSLib No_Cursor
	定义无指针设备。
	消息成员列表中不会包含 Point pt 。
	*/
	//#define YSLIB_NO_CURSOR

	// YSLib Debug 选项。
	/*
	YSLib MSG Debug
	bit0 ： InsertMessage ；
	bit1 ： PeekMessage 。
	注意： PeekMessage 包含 InsertMessage 。
	*/
	#define YSLIB_DEBUG_MSG 0

	//多播事件。
	#define YSL_EVENT_MULTICAST

} //$header Config;


$header YAdaptor "yadaptor.h" //外部库关联。
{
	//编译配置。
	#include "config.h"

	//包含平台文件。
	#include <platform.h>

	//引入 YSLib 命名空间宏。
	#include "base.h"


	//包含 CHRLib 。

	#include "../../CHRLib/chrlib.h"

	namespace stdex
	{
		using CHRLib::uchar_t;
		using CHRLib::uint_t;
	} //namespace stdex;

	YSL_BEGIN

	YSL_BEGIN_NAMESPACE(Text)

		using namespace CHRLib;

	YSL_END_NAMESPACE(Text)

		using Text::fchar_t;
		using Text::uchar_t;
		using Text::uint_t;

	YSL_END

	//包含 YCLib 。

	#include "../../YCLib/ycommon.h"

	YSL_BEGIN

	YSL_BEGIN_NAMESPACE(Drawing)

		using platform::PixelType;
		using platform::BitmapPtr;
		using platform::ConstBitmapPtr;
		using platform::ScreenBufferType;
		using platform::Color;

	YSL_END_NAMESPACE(Drawing)

	YSL_BEGIN_NAMESPACE(Runtime)

		using platform::Key;
		using platform::KeysInfo;
		using platform::CursorInfo;

	YSL_END_NAMESPACE(Runtime)

		using platform::terminate;
		using platform::yassert;
		using platform::HDirectory;

		namespace DS
		{
			using namespace platform;

			using ::swiWaitForVBlank;

			using ::lcdMainOnTop;
			using ::lcdMainOnBottom;
			using ::lcdSwap;
			using ::videoSetMode;
			using ::videoSetModeSub;

			using ::scanKeys;
			using ::touchRead;
		}

	YSL_END


	//包含 FreeType2 。

	#include <ft2build.h>

	#include FT_FREETYPE_H
	#include FT_CACHE_H
	#include FT_BITMAP_H
	#include FT_GLYPH_H
	//#include FT_OUTLINE_H


	//包含 Anti-Grain Geometry 。
	//#include "yagg.h"


	//包含 Loki 。
	#include <loki/Function.h>
	#include <loki/SmartPtr.h>
	#include <loki/StrongPtr.h>

	YSL_BEGIN

	YSL_BEGIN_NAMESPACE(Design)

		//类型操作和类型特征。
		using Loki::Typelist;
		namespace TL = Loki::TL;
		using Loki::NullType;
		using Loki::EmptyType;
		using Loki::Int2Type;
		using Loki::Type2Type;
		using Loki::Select;
		using Loki::IsCustomUnsignedInt;
		using Loki::IsCustomSignedInt;
		using Loki::IsCustomFloat;
		using Loki::TypeTraits;

		// Function 和 Function 。
		using Loki::Function;
		using Loki::Functor;

	//设计模式。
	YSL_BEGIN_NAMESPACE(Pattern)
	YSL_END_NAMESPACE(Pattern)

	YSL_END_NAMESPACE(Design)

		//使用 Loki 智能指针。
		using Loki::SmartPtr;
		using Loki::RefCounted;
		using Loki::AllowConversion;
		using Loki::DisallowConversion;
		using Loki::RejectNull;
		using Loki::DefaultSPStorage;
		using Loki::HeapStorage;
		using Loki::RefToValue;
		using Loki::SmallObject;

	YSL_END

	//使用 Loki 的编译期静态检查。
	#define YSL_STATIC_CHECK(expr, msg) LOKI_STATIC_CHECK(expr, msg)

	//使用 Loki 的 Typelist 。
	#define YSL_TL(n, ...) LOKI_TYPELIST##n(...)

} //$header YAdaptor;


$header YASLIVectorStoragePolicy "yaslivsp.hpp" // yasli::vector 存储策略。
{
	import Adaptor::Base;


	#include <loki/yasli/yasli_vector.h>
	/*
	#include <memory>
	#include <algorithm>
	#include <limits>
	*/

	//字符串存储策略类：使用 yasli::vector 和 空基类优化。
	template <typename _tChar, class _tAlloc = std::allocator<_tChar> >
	class VectorStringStorage : protected yasli::vector<_tChar, _tAlloc>
	{
		typedef yasli::vector<_tChar, _tAlloc> base;

	public: // protected:
		typedef _tChar value_type;
		typedef typename base::iterator iterator;
		typedef typename base::const_iterator const_iterator;
		typedef _tAlloc allocator_type;
		typedef typename _tAlloc::size_type size_type;
		typedef typename _tAlloc::reference reference;

		VectorStringStorage(const VectorStringStorage&);
		VectorStringStorage(const _tAlloc&);
		VectorStringStorage(const value_type*, size_type, const _tAlloc&);
		VectorStringStorage(size_type, _tChar, const _tAlloc&);

		VectorStringStorage&
		operator=(const VectorStringStorage& rhs);

		PDefH(iterator, begin)
			ImplBodyBase(base, begin)

		PDefH(const_iterator, begin) const
			ImplBodyBase(base, begin)

		PDefH(iterator, end)
			ImplRet(base::end() - 1)

		PDefH(const_iterator, end) const
			ImplRet(base::end() - 1)

		PDefH(size_type, size) const
			ImplRet(base::size() - 1)

		PDefH(size_type, max_size) const
			ImplRet(base::max_size() - 1)

		PDefH(size_type, capacity) const
			ImplRet(base::capacity() - 1)

		void
		reserve(size_type);

		template<class _tForIt>
		void
		append(_tForIt, _tForIt);

		void
		resize(size_type, _tChar);

		PDefH(void, swap, VectorStringStorage& rhs)
			ImplBodyBaseVoid(base, swap, rhs)

		PDefH(const _tChar*, c_str) const
			ImplRet(&*begin())

		PDefH(const _tChar*, data) const
			ImplRet(&*begin())

		PDefH(_tAlloc, get_allocator) const
			ImplBodyBase(base, get_allocator)
	};

} //$header YASLIVectorStoragePolicy;


$header Container "cont.h" //容器管理。
{
	$import $header Adaptor::YAdaptor;


	//包含 YASLI 。
	#ifdef YSL_USE_YASLI_VECTOR
	#	include <loki/yasli/yasli_vector.h>
	#else
	#	include <vector>
	#endif

	//包含 flex_string 。
	#ifdef YSL_USE_FLEX_STRING
	#	include <loki/flex/flex_string_shell.h>

	YSL_BEGIN

	YSL_BEGIN_NAMESPACE(Design)

	YSL_BEGIN_NAMESPACE(Policies)

	YSL_BEGIN_NAMESPACE(Storage)

	/*
	#	ifdef YSL_USE_YASLI_VECTOR
	#		include "yaslivsp.hpp"
	#	else
	#		include <loki/flex/vectorstringstorage.h>
	#	endif
	*/
	#	include <loki/flex/allocatorstringstorage.h>
	#	include <loki/flex/smallstringopt.h>
	#	ifdef YSL_USE_COPY_ON_WRITE
	#		include <loki/flex/cowstringopt.h>
	#	endif

	YSL_END_NAMESPACE(Storage)

	YSL_END_NAMESPACE(Policies)

	YSL_END_NAMESPACE(Design)

	YSL_END

	#else
	#	include <string>
	#endif

	//包含标准库容器和容器适配器。
	#include <list>
	#include <set>
	#include <map>
	#include <stack>
	#include <queue>

	YSL_BEGIN

	#ifdef YSL_USE_YASLI_VECTOR
		using yasli::vector;
	#else
		using std::vector;
	#endif

	using std::list;
	using std::map;
	using std::set;
	using std::stack;
	using std::queue;
	using std::priority_queue;

	#ifdef YSL_USE_FLEX_STRING

	template<typename _tChar,
		class _tCharTrait = std::char_traits<_tChar>,
		class _tAlloc = std::allocator<_tChar>,
		class _tStorage = 
	#	if defined(YSL_OPT_SMALL_STRING_LENGTH) && YSL_OPT_SMALL_STRING_LENGTH > 0
			Design::Policies::Storage::SmallStringOpt<
	#	endif
	#	ifdef YSL_USE_COPY_ON_WRITE
			Design::Policies::Storage::CowStringOpt<
	#	endif
				Design::Policies::Storage::AllocatorStringStorage<_tChar, _tAlloc>
	#	ifdef YSL_USE_COPY_ON_WRITE
			>
	#	endif
	#	if defined(YSL_OPT_SMALL_STRING_LENGTH) && YSL_OPT_SMALL_STRING_LENGTH > 0
			, YSL_OPT_SMALL_STRING_LENGTH
		>
	#endif
	>
	struct GSStringTemplate
	{
		typedef flex_string<_tChar, _tCharTrait, _tAlloc, _tStorage> basic_string;
	};

	#else

	template<typename _tChar>
	struct GSStringTemplate
	{
		typedef std::basic_string<_tChar> basic_string;
	};

	#endif

	typedef GSStringTemplate<char>::basic_string string;

	//YSLib 基本字符串（使用 UTF-16LE ）。
	typedef GSStringTemplate<uchar_t>::basic_string ustring;

	YSL_END

} //$header Container;


$header YRefrence "yref.hpp" //用于提供指针和引用访问的间接访问类模块。
{
	$import $header Adaptor::YAdaptor;


	YSL_BEGIN

	YSL_BEGIN_NAMESPACE(Design)

	YSL_BEGIN_NAMESPACE(Policies)

	YSL_BEGIN_NAMESPACE(Operations)

	template<class P>
	struct SmartPtr_Simple
	{
		enum
		{
			destructiveCopy = false
		};

		inline
		SmartPtr_Simple();

		template<class P1>
		inline
		SmartPtr_Simple(const SmartPtr_Simple<P1>& rhs);

		inline static P
		Clone(const P& val)

		inline bool
		Release(const P&);

		static void
		Swap(SmartPtr_Simple&);
	}; //template<class P> class SmartPtr_Simple;

	template<class P>
	class SmartPtr_RefCounted
	{
	private:
		uintptr_t* pCount_;

	protected:
		inline void
		AddRef();

	public:
		enum { destructiveCopy = false };

		inline
		SmartPtr_RefCounted();

		inline
		SmartPtr_RefCounted(const SmartPtr_RefCounted& rhs);

		template<typename P1>
		inline
		SmartPtr_RefCounted(const SmartPtr_RefCounted<P1>& rhs);

		inline P
		Clone(const P& val);

		inline bool
		Release(const P&);

		inline void
		Swap(SmartPtr_RefCounted& rhs);
	}; //template<class P> class SmartPtr_RefCounted;

	YSL_END_NAMESPACE(Operations)

	YSL_END_NAMESPACE(Policies)

	YSL_END_NAMESPACE(Design)


	template<typename T,
		template<class> class OP = Design::Policies::Operations::SmartPtr_RefCounted,
		class CP = AllowConversion,
		template<class> class KP = RejectNull,
		template<class> class SP = DefaultSPStorage,
		typename SPType = SmartPtr<T, OP, CP, KP, SP> >
	class GHResource : public SPType //资源指针类。
	{
	public:
		inline
		GHResource(T* = NULL);
		inline
		GHResource(T&);
		inline
		GHResource(RefToValue<GHResource>);

		inline
		operator RefToValue<GHResource>();

		inline T*
		operator->() const;

		inline GHResource&
		operator=(T& rhs);

		inline T*
		GetPtr() const;

		inline void
		Swap(GHResource& rhs);
	}; //template class GHResource;


	#define YHandleOP Design::Policies::Operations::SmartPtr_Simple
	//句柄不会被自动回收，需要手动释放。
	#define YDelete(h) delete h


	template<typename T,
		template<class> class OP = YHandleOP,
		class CP = AllowConversion,
		template<class> class KP = RejectNull,
		template<class> class SP = DefaultSPStorage,
		typename SPType = SmartPtr<T, OP, CP, KP, SP> >
	class GHHandle : public SPType //句柄类。
	{
	public:
		inline
		GHHandle(T* = NULL);
		inline
		GHHandle(T&);
		inline
		GHHandle(RefToValue<GHHandle>);
		template<class C>
		inline explicit
		GHHandle(GHHandle<C>& h);

		inline
		operator RefToValue<GHHandle>();

		inline T*
		operator->() const;

		inline GHHandle&
		operator=(T& rhs);

		inline T*
		GetPtr() const;

		inline void
		Swap(GHHandle& rhs);
	}; //template<typename T, ... > class GHHandle;


	#undef YHandleOP


	#ifdef YSL_USE_SIMPLE_HANDLE

	template<typename _type>
	inline _type*
	GetPointer(_type*);
	
	template<typename _type, typename _tReference>
	inline _type
	handle_cast(GHHandle<_tReference>);	

	#else

	template<class _type>
	inline _type*
	GetPointer(GHHandle<_type>);

	#endif

	} //namespace YSLib;

} //$unit YRefrence;


$unit YFont "yfont" //平台无关的字体缓存库。
{
	$import $header Core::YFunc, $unit Core::YCoreUtilities, $header Core::String, $unit Core::YFileSystem/*, Helper::YGlobal*/;


	YSL_BEGIN_NAMESPACE(Drawing)

	//默认字体大小（pt）。
	$export const u8 DEFAULT_FONT_SIZE;

	//前向声明。
	class Font;
	class FontFamily;
	class Typeface;
	class FontFile;
	class YFontCache;


	//字体样式。
	struct EFontStyle
	{
	public:
		typedef enum Styles
		{
			Regular = 0, //常规字体。
			Bold = 1, //粗体。
			Italic = 2, //斜体。
			Underline = 4, //下划线。
			Strikeout = 8, //删除线。
		} Styles;

	private:
		Styles style;

	public:
		inline
		EFontStyle(Styles = Regular);

		DefConverter(const Styles&, style);
		inline
		operator Styles&();

		const char*
		GetName() const ythrow(); //取样式名称。
	}; //struct EFontStyle;


	//字型家族 (Typeface Family) 标识。
	$export class FontFamily// : implements GIEquatable<FontFamily>, implements GILess<FontFamily>, implements GIContainer<Typeface>
	{
		friend class Typeface;
		friend class YFontCache;

	public:
		typedef set<const Typeface*> FTypes; //字型组类型。
		typedef map<const FT_String*, const Typeface*, deref_str_comp<FT_String> > FTypesIndex; //字型组索引类型。

		YFontCache& Cache;

	private:
		FT_String* family_name;
		FTypes sTypes; //字型组类型。
		FTypesIndex mTypesIndex; //字型组索引类型。

	public:
		FontFamily(YFontCache&, const FT_String*);
		~FontFamily() ythrow();

		bool
		operator==(const FontFamily&) const;
		bool
		operator<(const FontFamily&) const;

		DefGetter(const FT_String*, FamilyName, family_name)
		const Typeface*
		GetTypefacePtr(EFontStyle) const; //取指定样式的字型指针，若非 Regular 样式失败则尝试取 Regular 样式的字型指针。
		const Typeface*
		GetTypefacePtr(const FT_String*) const; //取指定样式名称的字型指针。

	private:
		void
		operator+=(const Typeface&); //向字型组和字型组索引添加字型对象。
		bool
		operator-=(const Typeface&); //从字型组和字型组索引中移除指定字型对象。
	}; //class FontFamily;


	//字型标识。
	$export class Typeface// : implements GIEquatable<Typeface>, implements GILess<Typeface>
	{
		friend class YFontCache;
		friend FT_Error simpleFaceRequester(FTC_FaceID, FT_Library, FT_Pointer, FT_Face*);

	//	static const FT_Matrix MItalic = {0x10000, 0x5800, 0, 0x1000};
	public:
		YFontCache& Cache;
		const FontFile& File;

	private:
		FontFamily* pFontFamily;
	//	FT_Face face;
	//	bool bBold, bOblique, bUnderline;
		FT_String* style_name;

		FT_Long faceIndex;
		FT_Int cmapIndex;
	/*	FT_Long nGlyphs;
		FT_UShort uUnitPerEM;
		FT_Int nCharmaps;
		FT_Long lUnderlinePos;
		FT_Matrix matrix;
		vector<u8> fixSizes;*/

	public:
		Typeface(YFontCache&, const FontFile&, u32 = 0);
		~Typeface() ythrow();

		bool
		operator==(const Typeface&) const;
		bool
		operator<(const Typeface&) const;

		DefGetter(const FontFamily*, FontFamilyPtr, pFontFamily)
		DefGetter(const FT_String*, FamilyName, pFontFamily ? pFontFamily->GetFamilyName() : NULL)
		DefGetter(const FT_String*, StyleName, style_name)
	}; //class Typeface;


	//字体文件。
	$export class FontFile// : implements GIEquatable<FontFile>, implements GILess<FontFile>
	{
	public:
		static const u8 MaxFontPathLength = YC_MAX_PATH; //最大字体文件路径长度。

	private:
		CPATH path;
		FT_Library& library;
		FT_Long nFace;

	public:
		FontFile(CPATH, FT_Library&);
		FontFile(CPATH, const char*, FT_Library&);

		bool operator==(const FontFile& rhs) const;

		DefGetter(const char*, Path, path)
		DefGetter(s32, FaceN, nFace)

		void ReloadFaces(); //读取字体文件，载入全部字体。
	}; //class FontFile;


	//取默认字型。
	const Typeface* GetDefaultTypefacePtr();

	//取默认字型家族。
	inline const FontFamily*
	GetDefaultFontFamilyPtr();
	inline const FontFamily&
	GetDefaultFontFamily()

	//字体：字模，包含字型和大小。
	$export class Font
	{
	public:
		typedef u8 SizeType;

		static const SizeType
			DefSize = 16, //DEF_SHELL_FONTSIZE,
			MinSize = 4, //DEF_SHELL_FONTSIZE_MIN,
			MaxSize = 72; //DEF_SHELL_FONTSIZE_MAX;

	private:
		static Font* pDefFont; //默认 Shell 字体。

		const FontFamily* pFontFamily;
		EFontStyle Style;
		SizeType Size;

	public:
		explicit
		Font(const FontFamily& = GetDefaultFontFamily(), SizeType = DefSize, EFontStyle = Regular);

		DefPredicate(Bold, Style | Bold)
		DefPredicate(Italic, Style | Italic)
		DefPredicate(Underline, Style | Underline)
		DefPredicate(Strikeout, Style | Strikeout)

		DefStaticGetter(const Font&, Default, *pDefFont)
		DefGetter(const FontFamily&, FontFamily, *pFontFamily)
		DefGetter(EFontStyle, Style, Style)
		DefGetter(SizeType, Size, Size)
		DefGetter(YFontCache&, Cache, GetFontFamily().Cache)
		DefGetterMember(const FT_String*, FamilyName, GetFontFamily())
		DefGetter(const FT_String*, StyleName, Style.GetName())
		const FT_String*
		GetStyleName() const;
		SizeType GetHeight() const;

	/*	FontFamily&
		SetFontFamily(const FontFamily&);*/
		DefSetter(EFontStyle, Style, Style)
		void
		SetSize(SizeType);
		void
		SetFont(const Font&);

		bool
		Update(); //更新字体缓存中当前处理的字体。
		void
		UpdateSize(); //更新字体缓存中当前处理的字体大小。

		static bool
		InitializeDefault(); //初始化默认字体。
		static void
		ReleaseDefault(); //释放默认字体。
	}; //class Font;


	//字符位图。
	$export class CharBitmap
	{
	public:
		typedef FTC_SBit NativeType;
		typedef FT_Byte* BufferType;
		typedef FT_Byte ScaleType;
		typedef FT_Char SignedScaleType;

	private:
		FTC_SBit bitmap;

	public:
		inline
		CharBitmap(const NativeType&);

		DefConverter(NativeType, bitmap)

		DefGetter(BufferType, Buffer, bitmap->buffer)
		DefGetter(ScaleType, Width, bitmap->width)
		DefGetter(ScaleType, Height, bitmap->height)
		DefGetter(SignedScaleType, Left, bitmap->left)
		DefGetter(SignedScaleType, Top, bitmap->top)
		DefGetter(SignedScaleType, XAdvance, bitmap->xadvance)
		DefGetter(SignedScaleType, YAdvance, bitmap->yadvance)
	}; //class CharBitmap;


	//字体缓存。
	$export class YFontCache : public YObject,
		implements GIContainer<const FontFile>, implements GIContainer<const Typeface>, implements GIContainer<FontFamily>
	{
		friend class Typeface;

	private:
		FT_Library library; //库实例。
		FTC_Manager manager; //内存管理器实例。
		FTC_ScalerRec scaler;
		FTC_CMapCache cmapCache;
		FTC_SBitCache sbitCache;
		FTC_SBit sbit;

	public:
		typedef set<const FontFile*> FFiles; //字体文件组类型。
		typedef set<const Typeface*> FTypes; //字型组类型。
		typedef set<const Typeface*> FFaces; //字型家族组类型。
		typedef map<const FT_String*, FontFamily*, deref_str_comp<FT_String> > FFacesIndex; //字型家族组索引类型。

	private:
		FFiles sFiles; //字体文件组。
		FTypes sTypes; //字型组。
		FFaces sFaces; //字型家族组索引。
		FFacesIndex mFacesIndex; //字型家族组索引。

		const Typeface* pDefaultFace; //默认字型指针。
		const Typeface* pFace; //当前处理的字型指针。
		Font::SizeType curSize; //当前处理的字体大小。

	public:
		explicit
		YFontCache(CPATH, u32 cacheSize = GLYPH_CACHE_SIZE); //读取指定路径的字体文件并分配指定大小的缓存空间。
		virtual
		~YFontCache();

	private:
		FT_Face
		GetInternalFaceInfo() const; //取当前处理的内部字型结构体指针。

	public:
		DefGetter(const FFiles&, Files, sFiles) //取字体文件组。
		DefGetter(const FTypes&, Types, sTypes) //取字型组。
		DefGetter(const FFaces&, Faces, sFaces) //取字型家族组。
		DefGetter(const FFacesIndex&, FacesIndex, mFacesIndex) //取字型家族组索引。
		DefGetter(FFiles::size_type, FilesN, sFiles.size()) //取字体文件组储存的文件数。
		DefGetter(FTypes::size_type, TypesN, sTypes.size()) //取字型组储存的字型数。
		DefGetter(FFaces::size_type, FacesN, sFaces.size()) //取字型家族组储存的字型家族数。
	//	Font*
	//	GetFontPtr() const;
		const FontFamily*
		GetFontFamilyPtr(const FT_String*) const; //取指定名称字型家族指针。
		const Typeface*
		GetDefaultTypefacePtr() const; //取默认字型指针。
		DefGetter(const Typeface*, TypefacePtr, pFace) //取当前处理的字型指针。
	//	Typeface*
	//	GetTypefacePtr(u16) const; //取字型组储存的指定索引的字型指针。
		Typeface*
		GetTypefacePtr(const FT_String*, const FT_String*); //取指定名称字型指针。
		DefGetter(u8, FontSize, curSize) //取当前处理的字体大小。
		CharBitmap
		GetGlyph(fchar_t); //取当前字型和大小渲染的指定字符的字形。
		s8
		GetAdvance(fchar_t, FTC_SBit sbit = NULL); //取跨距。
		u8
		GetHeight() const; //取行高。
		s8
		GetAscender() const; //取升部。
		s8
		GetDescender() const; //取降部。

		bool
		SetTypeface(const Typeface*); //设置字型组中指定的字型为当前字型（忽略不属于字型组的字型）。
		void
		SetFontSize(Font::SizeType); //设置当前处理的字体大小（0 表示默认字体大小）。

	public:
		//SetFont;

	private:
		void
		operator+=(const FontFile&); //向字体文件组添加字体文件对象。
		bool
		operator-=(const FontFile&); //从字体文件组中移除指定字体文件对象。

		void
		operator+=(const Typeface&); //向字型组添加字型对象。
		bool
		operator-=(const Typeface&); //从字型组中移除指定字型对象。

		void
		operator+=(FontFamily&); //向字型家族组添加字型对象。
		bool
		operator-=(FontFamily&); //从字型家族组中移除指定字型对象。

		void
		LoadTypefaces(); //从字体文件组中载入字体信息。
		void
		LoadTypefaces(const FontFile&); //从指定字体文件中载入字体信息。

	public:
		void
		LoadFontFileDirectory(CPATH, CPATH = "ttf"); //读取字体文件目录并载入目录下指定后缀名的字体文件。
		void
		LoadFontFile(CPATH) ythrow(); //按路径加入字体文件并载入字体信息。

	private:
		void
		ClearFontFiles();
		void
		ClearTypefaces();
		void
		ClearFontFamilies();
		void
		ClearContainers();

	public:
		void
		ClearCache();
	}; //class YFontCache;


	//以路径 path 创建字体缓存，指针存储至 p 。
	inline void
	CreateFontCache(YFontCache*& p, CPATH path);

	//销毁 p 指向的字体缓存。
	inline void
	DestroyFontCache(YFontCache*& p);

	YSL_END_NAMESPACE(Drawing)

} //$unit YFont;


}; //$code YSLib::Adaptor;


$code YSLib::Core {

$header YShellDefinition "ysdef.h" //宏定义和类型描述模块。
{
	$import $unit YAdaptor::YAdaptor;


	#ifndef YSL_SHLMAIN_NAME
	#	define YSL_SHLMAIN_NAME ShlMain
	#endif

	#ifndef YSL_SHLMAIN_SHLPROC
	#	define YSL_SHLMAIN_SHLPROC ShlProc
	#endif

	#define YSL_MAIN_SHLPROC YSL_SHL_(YSL_SHLMAIN_NAME) YSL_SHLMAIN_SHLPROC


	$import $unit YAdaptor::YRefrence;

	YSL_BEGIN

	//抽象描述接口。

	//值类型相等关系。
	template<typename T>
	DeclInterface(GIEquatable)
		DeclIEntry(bool operator==(const T&) const)
		virtual bool
		operator!=(const T& rhs) const;
	EndDecl

	//值类型小于关系。
	template<typename T>
	DeclInterface(GILess)
		DeclIEntry(bool operator<(const T&) const);
	EndDecl

	//容器。
	template<typename T>
	DeclInterface(GIContainer)
		DeclIEntry(void operator+=(T&))
		DeclIEntry(bool operator-=(T&))
	EndDecl

	//对象复制构造性。
	template<typename T>
	DeclInterface(GIClonable)
		DeclIEntry(T* Clone() const)
	EndDecl


	//前向声明。

	class YObject;
	typedef YObject MEventArgs; //事件参数基类。

	YSL_BEGIN_NAMESPACE(Runtime)
	struct MEventArgs;
	YSL_END_NAMESPACE(Runtime)

	YSL_BEGIN_NAMESPACE(Device)
	class YScreen;
	YSL_END_NAMESPACE(Device)

	YSL_BEGIN_NAMESPACE(Drawing)
	class YFontCache;
	YSL_END_NAMESPACE(Drawing)

	YSL_BEGIN_NAMESPACE(Shells)
	class YMessageQueue;
	class YShell;
	class YShellMain;
	YSL_END_NAMESPACE(Shells)

	YSL_BEGIN_NAMESPACE(Components)

	YSL_BEGIN_NAMESPACE(Controls)
	PDeclInterface(IControl)
	PDeclInterface(IVisualControl)
	YSL_END_NAMESPACE(Controls)

	YSL_BEGIN_NAMESPACE(Forms)
	PDeclInterface(IWindow)
	class YFrameWindow;
	class YForm;
	YSL_END_NAMESPACE(Forms)

	YSL_BEGIN_NAMESPACE(Widgets)
	PDeclInterface(IWidget)
	PDeclInterface(IWidgetContainer)
	YSL_END_NAMESPACE(Widgets)

	class YDesktop;

	YSL_END_NAMESPACE(Components)

	YSL_BEGIN_NAMESPACE(Text)
	typedef std::size_t SizeType; //字符大小类型。
	typedef usize_t SizeType; //字符索引类型。
	class String;
	YSL_END_NAMESPACE(Text)

	class YApplication;
	class YLog;

	using Components::Controls::IControl;
	using Components::Controls::IVisualControl;
	using Components::Forms::IWindow;
	using Components::Forms::YForm;
	using Components::Forms::YFrameWindow;
	using Components::Widgets::IWidget;
	using Components::Widgets::IWidgetContainer;

	using Device::YScreen;

	using Drawing::YFontCache;

	using Shells::YMessageQueue;
	using Shells::YShell;
	using Shells::YShellMain;

	using Text::String;

	#ifdef YSL_USE_SIMPLE_HANDLE
	#define DeclareHandle(type, handle) typedef type* handle
	#define handle_cast reinterpret_cast
	#else
	#define DeclareHandle(type, handle) typedef GHHandle<type> handle
	#endif


	//类型定义。
	typedef s16 SPOS; //屏幕坐标度量。
	typedef u16 SDST; //屏幕坐标距离。
	DeclareHandle(IWindow, HWND);
	DeclareHandle(YShell, HSHL);
	DeclareHandle(YApplication, HINSTANCE);
	typedef enum {RDeg0 = 0, RDeg90 = 1, RDeg180 = 2, RDeg270 = 3} ROT; //逆时针旋转角度指示输出朝向。

	//全局常量。
	extern CSTR G_COMP_NAME, G_APP_NAME, G_APP_VER; //制作机构名称，程序名称和版本号。
	extern CPATH DEF_DIRECTORY;
	extern const SDST SCRW, SCRH;

	//全局变量。
	extern YLog DefaultLog; //全局日志。

	//访问全局程序实例对象。
	extern YScreen*& pDefaultScreen;
	extern YDesktop*& pDefaultDesktop;
	extern YApplication& theApp;
	extern YFontCache*& pDefaultFontCache;
	extern YApplication* const pApp;
	extern const HSHL hShellMain;
	
	YSL_END

}; //$header YShellDefinition;


$header YCounter "ycounter.hpp" //对象计数器。
{
	$import $header YShellDefinition;


	//模板类实例计数器。
	template<class T, typename count_t = u32>
	class GMCounter
	{
	public:
		inline
		GMCounter();
		inline
		GMCounter(const GMCounter&);

	protected:
		inline
		~GMCounter();

	public:
		inline static count_t
		GetCount();
		inline static count_t
		GetTotal();
		inline count_t
		GetID() const;

	protected:
		inline static void
		ResetCount();
		inline static void
		ResetTotal();
		inline void ResetID();
	}; //class GMCounter;

} //$header GMCounter;


$header YFunc "yfunc.hpp" //函数对象封装模块。
{
	$import $header YShellDefinition;


	//函数对象基类。
	template<typename _tPointer>
	class GHBase
	{
	protected:
		mutable _tPointer _ptr; //对象指针。

		inline explicit
		GHBase(_tPointer= NULL);
		template<typename P>
		inline explicit
		GHBase(GHBase<P>);
		inline
		~GHBase();

	public:
		inline
		operator _tPointer() const;

		inline bool
		empty() const;
		inline _tPointer
		GetPtr() const;

	}; //class GHBase;

} //$header YFunc;


$unit YCoreUtilities "ycutil" //核心实用模块。
{
	$import $header YShellDefinition, <cstring>, <functional>;


	YSL_BEGIN_NAMESPACE(Design)

	//不可复制对象：继承此类的对象在外部无法调用复制构造函数和复制赋值操作符。
	class NonCopyable
	{
	//保护非多态类。
	protected:
		NonCopyable();
		~NonCopyable();

	private: 
		NonCopyable(const NonCopyable&);
		NonCopyable& operator=(const NonCopyable&);
	}; //class NonCopyable;

	YSL_END_NAMESPACE(Design)

	using Design::NonCopyable;


	//判断引用相等关系。
	template<typename _type>
	inline bool
	ReferenceEquals(const _type& a, const _type& b);

	//取指定类型的零元素。
	inline int
	GetZeroElement();
	template<typename _type>
	inline _type
	GetZeroElement();


	//取值类型最值。
	template<typename _type>
	inline _type
	vmin(_type, _type);
	template<typename _type>
	inline _type
	vmax(_type, _type);
	template<typename _type, typename _fCompare>
	inline _type
	vmin(_type, _type, _fCompare);
	template<typename _type, typename _fCompare>
	inline _type
	vmax(_type, _type, _fCompare);


	//符号函数，当 a < b 时返回 -1 ，否则当 a = b 时返回 0 ，否则返回 1 。
	inline int
	sgn(int a, int b);
	template<typename _type>
	int
	sgn(const _type& a, const _type& b);

	//判断 d 和以 [a, b](a ≤ b) 或 [b, a](a > b) 区间的关系，无精度修正。
	//返回值意义—— < 0 ：d 在区间外； = 0 ：d 在区间端点上；> 0 ：d 在区间内。
	inline int
	sgnInterval(int d, int a, int b);
	template<typename _type>
	int
	sgnInterval(const _type& d, const _type& a, const _type& b);

	//判断是否在左闭右开区间中。
	template<typename _type = int>
	inline bool
	isInIntervalRegular(_type, _type);
	template<typename _type = int>
	inline bool
	isInIntervalRegular(_type, _type, _type);

	//判断是否在开区间内。
	template<typename _type>
	inline bool
	isInIntervalStrict(_type, _type);
	template<typename _type>
	inline bool
	isInIntervalStrict(_type, _type, _type);

	//约束整数在左闭右开区间中。
	template<typename _type>
	void
	restrictInIntervalRegular(type&, int, int);

	//约束无符号整数在区间上界内。
	template<typename _type>
	void
	restrictUnsigned(_type&, unsigned);
	template<typename _type>
	void
	restrictUnsignedRegular(_type&, unsigned);

	//约束关系： a ≤ b 。
	template<typename _type>
	inline void
	restrictLessEqual(_type& a, _type& b);


	//清除指定的连续区域。
	template<typename _type>
	void
	ClearSequence(_type*, std::size_t);


	// delete 仿函数。
	struct delete_obj
	{
		template<typename _type>
		inline void
		operator()(_type*);
	}; //struct delete_obj;


	//带置空指针操作的 delete 仿函数。
	struct safe_delete_obj
	{
		template<typename _type>
		inline void
		operator()(_type*&);
	}; //struct safe_delete_obj;


	//解引用仿函数。
	template<typename _type>
	struct deref_op : std::unary_function<_type, _type*>
	{
		inline _type*
		operator()(_type&) const;
	}; //template<typename _type> struct deref_op;


	//常量解引用仿函数。
	template<typename _type>
	struct const_deref_op : std::unary_function<const _type, const _type*>
	{
		inline const _type*
		operator()(const _type&) const;
	}; //template<typename _type> struct const_deref_op;


	//间接访问（解引用）比较仿函数。
	template<
		typename _type,
		template<typename _type> class _fCompare = std::less
	>
	struct deref_comp : _fCompare<_type>
	{
		bool
		operator()(_type* const& _x, _type* const& _y) const;
	}; //template<typename _type, ... > struct deref_comp;


	//间接访问字符串（解引用）比较仿函数。
	template<
		typename _tChar,
		int (*_lexi_cmp)(const _tChar*, const _tChar*) = std::strcmp,
		class _fCompare = std::less<int>
	>
	struct deref_str_comp : _fCompare
	{
		bool
		operator()(_type* const&, _type* const&) const;
	}; //template<typename _tChar, ... > struct deref_str_comp;


	//删除指定标准容器中所有相同元素算法。
	template<typename _tContainer>
	typename _tContainer::size_type
	erase_all(_tContainer& _tContainer, const typename _tContainer::value_type& _value);


	//删除指定标准容器中所有满足条件元素算法。
	template<typename _tContainer, typename _fPredicate>
	typename _tContainer::size_type
	erase_all_if(_tContainer& _tContainer, const typename _tContainer::value_type& _pred);

} //$unit YCoreUtilities;


$header YEvent "yevt.hpp" //事件回调模块。
{
	$import $unit YObject, $header YFunc, Adaptor::Container;


	YSL_BEGIN_NAMESPACE(Runtime)

	//事件处理器接口模板。
	template<
		class _tSender = YObject, class _tEventArgs = MEventArgs,
		typename _fEventHandler = void(_tSender&, const _tEventArgs&), typename _pfEventHandler = _fEventHandler*
	>
	DeclBasedInterface(GIEventHandler, GIClonable<GIEventHandler<_tSender, _tEventArgs, _fEventHandler, _pfEventHandler> >)
		typedef _tSender SenderType;
		typedef _tEventArgs EventArgsType;

		DeclIEntry(void operator()(_tSender&, const _tEventArgs&) const)

		DeclIEntry(std::size_t GetSizeOf() const)
	EndDecl

	//标准事件处理器接口。
	typedef GIEventHandler<> IEventHandler;


	//非成员函数事件处理器类模板。
	template<
		class _tSender = YObject, class _tEventArgs = MEventArgs,
		typename _fEventHandler = void(_tSender&, const _tEventArgs&), typename _pfEventHandler = _fEventHandler*
	>
	class GHEventNormal : private GHBase<_pfEventHandler>,
		implements GIEventHandler<_tSender, _tEventArgs>
	{
	public:
		typedef GIEventHandler<_tSender, _tEventArgs> IHEventHandlerType;

		inline
		GHEventNormal();
		inline explicit
		GHEventNormal(const _fEventHandler&);
		template<class _giEventHandler>
		inline explicit
		GHEventNormal(const _giEventHandler&);
		inline virtual
		~GHEventNormal();

		void
		operator()(_tSender&, const _tEventArgs&) const;

		virtual DefGetter(std::size_t, SizeOf, sizeof(*this))

		virtual IHEventHandlerType*
		Clone() const;
	}; //template<class _tSender = ..., ... > class GHEventNormal;

	//成员函数事件处理器类模板。
	template<
		class _type,
		class _tSender = YObject, class _tEventArgs = MEventArgs,
		typename _fEventHandler = void(_tSender&, const _tEventArgs&), typename _pfEventHandler = _fEventHandler*
	>
	class GHEventMember : implements GIEventHandler<_tSender, _tEventArgs>
	{
	public:
		typedef GIEventHandler<_tSender, _tEventArgs> IHEventHandlerType;
		typedef void(_type::*MemFunPtrType)(const _tEventArgs&);

	private:
		MemFunPtrType _ptrMemFun;

	public:
		inline explicit
		GHEventMember(MemFunPtrType = NULL);
		inline virtual
		~GHEventMember();

		virtual void
		operator()(_tSendersender, const _tEventArgs&) const;

		virtual DefGetter(std::size_t, SizeOf, sizeof(*this))

		virtual IHEventHandlerType*
		Clone() const;
	}; //template<class _type, ... > class GHEventMember;

	//成员函数对象绑定事件处理器类模板。
	template<
		class _type,
		class _tSender = YObject, class _tEventArgs = MEventArgs,
		typename _fEventHandler = void(_tSender&, const _tEventArgs&), typename _pfEventHandler = _fEventHandler*
	>
	class GHEventMemberBinder : implements GIEventHandler<_tSender, _tEventArgs>
	{
	public:
		typedef GIEventHandler<_tSender, _tEventArgs> IHEventHandlerType;
		typedef void(_type::*MemFunPtrType)(const _tEventArgs&);

	private:
		_type& _obj;
		MemFunPtrType _ptrMemFun;

	public:
		inline explicit
		GHEventMemberBinder(_type& obj, MemFunPtrType = NULL);
		inline virtual
		~GHEventMemberBinder();

		virtual void
		operator()(_tSender&, const _tEventArgs&) const;

		virtual DefGetter(std::size_t, SizeOf, sizeof(*this))

		virtual IHEventHandlerType*
		Clone() const;
	}; //template<class _type, ... > class GHEventMemberBinder;

	template<class _tSender, class _tEventArgs>
	bool
	operator==(GIEventHandler<_tSender, _tEventArgs>&, GIEventHandler<_tSender, _tEventArgs>&);


	//事件处理器类模板。
	template<
		class _tSender = YObject, class _tEventArgs = MEventArgs,
		typename _fEventHandler = void(_tSender&, const _tEventArgs&), typename _pfEventHandler = _fEventHandler*
	>
	class GEventHandler : implements GIEventHandler<_tSender, _tEventArgs>
	{
	public:
		typedef GIEventHandler<_tSender, _tEventArgs> IHEventHandlerType;

	protected:
		IHEventHandlerType* _h_ptr;

	public:
		inline
		GEventHandler();
		inline explicit
		GEventHandler(const _fEventHandler&);
		// GCC 4.5.0 之前版本对构造函数模板解析有误，无法显式实例化此实例。
		template<class _type>
		inline
		GEventHandler(typename GHEventMember<_type, _tSender, _tEventArgs>::MemFunPtrType);
		//解决方案：调用 NewMemberHandler ，返回值作为参数再调用构造函数。
		inline explicit
		GEventHandler(IHEventHandlerType*);

		inline explicit
		GEventHandler(const GEventHandler&);
		inline virtual
		~GEventHandler();

		bool
		operator==(const GEventHandler&);
		virtual void
		operator()(_tSender&, const _tEventArgs&) const;

		virtual DefGetter(std::size_t, SizeOf, _h_ptr->GetSizeOf())

		virtual IHEventHandlerType*
		Clone() const;
	}; //template<class _tSender = ..., ... > class GEventHandler;

	template<class _type, class _tSender, class _tEventArgs>
	inline GHEventMember<_type, _tSender, _tEventArgs>*
	NewMemberHandler(typename GHEventMember<_type, _tSender, _tEventArgs>::MemFunPtrType);


	//标准事件处理器类。
	typedef GEventHandler<> EventHandler;


	//事件类模板。

	//多播版本。
	template<
		bool _bMulticast = true,
		class _tSender = YObject, class _tEventArgs = MEventArgs,
		class _iEventHandler = _GIEventHandler<_tSender, _tEventArgs>,
		class _tEventHandler = _GEventHandler<_tSender, _tEventArgs>
	>
	class GEvent
	{
	public:
		typedef void FuncType(_tSender&, const _tEventArgs&);
		typedef list<_tEventHandler> ListType;

	protected:
		ListType EventHandlerSet;

	public:
		GEvent();

		GEvent&
		operator+=(const _tEventHandler&);
		inline GEvent&
		operator+=(const FuncType&);
		template<class _type>
		inline GEvent&
		//使显式实例化非必要。
	//	operator+=(typename GHEventMember<_type, _tSender, _tEventArgs>::MemFunPtrType);
		operator+=(void(_type::*)(const _tEventArgs&));
		template<class _type>
		inline GEvent&
		Add(_type& obj, void(_type::*)(const _tEventArgs&));
		GEvent&
		operator-=(const _tEventHandler&);
		inline GEvent&
		operator-=(const FuncType&);
		template<class _type>
		inline GEvent&
		operator-=(typename GHEventMember<_type, _tSender, _tEventArgs>::MemFunPtrType);
		template<class _type>
		inline GEvent&
		Remove(_type& obj, void(_type::*)(const _tEventArgs&));

		void
		operator()(_tSender& sender, const _tEventArgs& e) const;
	}; //template<bool _bMulticast = ...,  ... > class GEvent;

	//单播版本。
	template<
		class _tSender, class _tEventArgs,
		class _iEventHandler,
		class _tEventHandler
	>
	struct GEvent<false, _tSender, _tEventArgs, _iEventHandler, _tEventHandler> : public _tEventHandler
	{
		typedef void FuncType(_tSender&, const _tEventArgs&);

		inline
		GEvent();

		inline GEvent&
		operator=(const _tEventHandler*);
		inline GEvent&
		operator+=(const _tEventHandler&);
		inline GEvent&
		operator+=(const FuncType&);
		inline GEvent&
		operator-=(const _tEventHandler&);
		inline GEvent&
		operator-=(const FuncType&);

		inline _tEventHandler*
		GetHandlerPtr();
	}; //template<class _tSender,  ... > class GEvent;


	//定义事件处理器委托。
	#define DefDelegate(_name, _tSender, _tEventArgs)\
		typedef Runtime::GEventHandler<_tSender, _tEventArgs> _name;


	#ifdef YSL_EVENT_MULTICAST

	//标准多播事件类。
	typedef GEvent<> Event;

	//多播事件类型。
	template<class _tEventHandler>
	struct GSEventTemplate
	{
		typedef Runtime::GEvent<true,
			typename _tEventHandler::SenderType,
			typename _tEventHandler::EventArgsType
		> EventType;
	};

	#else

	//标准单播事件类。
	typedef GEvent<false> Event;

	//单播事件类型。
	template<class _tEventHandler>
	struct GSEventTemplate
	{
		typedef Runtime::GEvent<false,
			typename _tEventHandler::SenderType,
			typename _tEventHandler::EventArgsType
		> EventType;
	};

	#endif


	//定义事件。
	#	define DefEvent(_tEventHandler, _name)\
			Runtime::GSEventTemplate<_tEventHandler>::EventType _name;

	//定义事件接口。
	#	define DeclIEventEntry(_tEventHandler, _name)\
			DeclIEntry(const Runtime::GSEventTemplate<_tEventHandler>::EventType& _yJOIN(Get, _name)() const)

	//定义事件访问器。
	#	define DefEventGetter(_tEventHandler, _name)\
			DefGetter(const Runtime::GSEventTemplate<_tEventHandler>::EventType&, _name, _name)


	//事件映射表模板。
	template<class _tEventSpace, class _tEvent = Event>
	class GEventMap
	{
	public:
		typedef typename _tEventSpace::EventID ID;
		typedef _tEvent Event;

	private:
		map<ID, Event> Map;

	public:
		inline
		GEventMap();
		inline Event&
		operator[](const ID& id);

		inline void
		clear();
	}; //template<class _tEventSpace> class GEventMap;


	//标准事件回调函数抽象类模板。
	template<class _tResponser, class _tEventArgs>
	struct GAHEventCallback : public _tEventArgs
	{
		inline explicit
		GAHEventCallback(const _tEventArgs& e);
		DeclIEntry(bool operator()(_tResponser&))
	}; //template<class _tResponser, ...> struct GAHEventCallback;

	YSL_END_NAMESPACE(Runtime)

	//标准事件处理器委托。
	DefDelegate(EventHandler, YObject, MEventArgs)

} //$unit YEvent;


$unit YObject "yobject" //平台无关的基础对象实现。
{
	$import $header GMCounter;


	//全局静态单例存储器。
	template<class _type>
	class GStaticCache
	{
	private:
		static _type* _ptr = NULL;

		GStaticCache();

		static void
		Check();

	public:
		DefStaticGetter(_type*, PointerRaw, _ptr)
		static _type*
		GetPointer();
		static _type&
		GetInstance();

		inline void
		Release();
	}; //template<class _type> class GStaticCache;

	YSL_BEGIN_NAMESPACE(Drawing)

	//前向声明。

	class BinaryGroup;
	class Point;
	class Vec;
	class Size;
	class Rect;


	class BinaryGroup //屏幕二元组。
	{
	public:
		SPOS x, y; //分量。

		inline
		BinaryGroup()
		inline explicit
		BinaryGroup(const Size&);
		inline template<typename _type>
		explicit
		BinaryGroup(const _type& v);
		inline template<typename _type>
		BinaryGroup(_type, _type);

		inline BinaryGroup
		operator-(); //负运算：返回相反元素。

		DefGetter(SPOS, X, X)
		DefGetter(SPOS, Y, Y)
	}; //class BinaryGroup;

	inline bool
	operator==(const BinaryGroup& a, const BinaryGroup& b);
	inline bool
	operator!=(const BinaryGroup& a, const BinaryGroup& b);


	class Point : public BinaryGroup //屏幕二维点坐标。
	{
	public:
		typedef BinaryGroup ParentType;

		static const Point Zero = Point(); //默认构造参数构造的原点对象。
		static const Point FullScreen = Point(SCRW, SCRH); //默认构造参数构造的屏幕右下角边界（不在屏幕坐标系中）对象。

		inline
		Point()
		inline explicit
		Point(const Size&);
		inline template<typename _type>
		explicit
		Point(const _type& v);
		inline template<typename _type>
		Point(_type, _type);

		inline
		operator Vec() const;

		inline Point
		operator-(); //负运算：返回与原点对称的元素。
		inline Point&
		operator+=(const Vec&);
		inline Point&
		operator-=(const Vec&);
	}; //class Point;


	class Vec : public BinaryGroup //屏幕二维向量。
	{
	public:
		typedef BinaryGroup ParentType;

		static const Vec Zero = Vec(); //默认构造参数构造的零向量对象。
		static const Vec FullScreen = Vec(SCRW, SCRH); //默认构造参数构造的由屏幕坐标系原点到屏幕右下角边界（不在屏幕坐标系中）对象。

		inline
		Vec()
		inline explicit
		Vec(const Size&);
		inline template<typename _type>
		explicit
		Vec(const _type& v);
		inline template<typename _type>
		Vec(_type, _type);

		inline
		operator Point() const;

		inline Vec
		operator-(); //负运算：返回相反向量。
		inline Vec&
		operator+=(const Vec&);
		inline Vec&
		operator-=(const Vec&);
	}; //class Vec;


	//屏幕二维向量二元运算。

	inline Vec
	operator-(const Point&, const Point&);
	inline Vec
	operator+(const Vec&, const Vec&);
	inline Vec
	operator-(const Vec&, const Vec&);


	struct Size //屏幕区域大小。
	{
		SDST Width, Height;

		static const Size Zero = Size(); //默认构造参数构造的零元素对象。
		static const Size FullScreen = Size(SCRW, SCRH); //默认构造参数构造的全屏幕对象。

		inline
		Size()
		inline template<typename _type>
		explicit
		Size(const _type& v);
		inline template<typename _type>
		Size(_type, _type);

		inline
		operator Vec() const;

		DefGetter(SDST, Width, Width)
		DefGetter(SDST, Height, Height)
		DefGetter(u32, Area, Width * Height) //取面积。
	}; //class Size;

	inline bool
	operator==(const Size& a, const Size& b);
	inline bool
	operator!=(const Size& a, const Size& b);


	//二元对象转置。
	template<class _tBinary>
	inline _tBinary
	Transpose(_tBinary& o);


	class Rect : public Point //屏幕坐标系的正则（边平行于水平直线的）矩形：使用左上点屏幕坐标、宽和高表示。
	{
	public:
		SDST w, h; //宽和高。

		static const Rect Empty = Rect(); //默认构造参数构造的空矩形对象。
		static const Rect FullScreen = Rect(Point::Zero, SCRW, SCRH); //默认构造参数构造的全屏幕矩形对象。

		inline
		Rect();
		inline explicit
		Rect(const Point&);
		inline explicit
		Rect(const Size&);
		inline
		Rect(const Point&, const Size&);
		inline
		Rect(const Point&, SDST, SDST);
		inline
		Rect(SPOS, SPOS, const Size&);
		inline
		Rect(SPOS, SPOS, SDST, SDST);

		inline bool
		IsInBounds(const Point&) const; //判断点是否在矩形内或边上。
		inline bool
		IsInBounds(int px, int py) const; //判断点 (px, py) 是否在矩形内或边上。
		inline bool
		IsInBoundsRegular(const Point& p) const; //判断点是否在矩形内或左侧或上侧边上。
		inline bool
		IsInBoundsRegular(int px, int py) const; //判断点 (px, py) 是否在矩形内或左侧或上侧边上。
		inline bool
		IsInBoundsStrict(const Point& p) const; //判断点是否在矩形内。
		inline bool
		IsInBoundsStrict(int px, int py) const; //判断点 (px, py) 是否在矩形内。
		Point
		GetPoint() const; //取左上角位置。
	}; //class Rect;

	inline bool
	operator==(const Rect& a, const Rect& b);
	inline bool
	operator!=(const Rect& a, const Rect& b);

	YSL_BEGIN_NAMESPACE(Drawing)

	//基本对象定义。

	//基本对象类：所有类名以 Y 作前缀类（除模板类、非直接实例化类和模块类）的公共基类。
	class YObject : private NonCopyable
	{
	public:
		virtual
		~YObject();
	}; //class YObject;


	//基本可数对象类：所有可数的基本对象类的公共基类。
	class YCountableObject : public GMCounter<YCountableObject>, public YObject
	{
	public:
		typedef YObject ParentType;

	protected:
		YCountableObject();
	}; //class YCountableObject;

} //$unit YObject;


$unit YException "yexcept" //异常处理模块。
{
	$import $unit YObject, $header <new>, <typeinfo>, Adaptor::Container;


	// YSLib 异常基类。
	class Exception : public std::exception
	{
	public:
		Exception();
		virtual
		~Exception() throw();
	}; //class Exception;


	//一般异常事件类。
	class GeneralEvent : public Exception
	{
	private:
		string what_;

	public:
		GeneralEvent(const string& what);
		virtual
		~GeneralEvent() throw();

		const char*
		what() const throw();
	}; //class GeneralEvent;


	//记录异常事件类。
	class LoggedEvent : public GeneralEvent
	{
	private:
		u8 level;

	public:
		LoggedEvent(const string&, u8 = 0);
		LoggedEvent(const GeneralEvent&, u8 = 0);
		virtual
		~LoggedEvent() throw();

		DefGetter(u8, Level, level);
	}; //LoggedEvent;

} //$unit YException;


$unit YString "ystring" //基础字符串管理。
{
	$import $unit YObject, $header Adaptor::Container;


	YSL_BEGIN_NAMESPACE(Text)

	// YSLib 标准字符串（使用 UTF-16LE ）。
	class String : public ustring
	{
	private:
		static uchar_t* s_str; //内码转换生成字符串临时指针。

	public:
		inline
		String();
		inline
		String(const uchar_t*);
		template<class _tChar>
		String(const _tChar*);
		inline
		String(const ustring&);
	}; //class String;


	//多字节字符串转化为 YSLib 标准字符串。
	String
	MBCSToString(const char*, const CSID& = CS_Local);
	inline String
	MBCSToString(const string& s, const CSID& = CS_Local);

	// YSLib 基本字符串转化为多字节字符串。
	string
	StringToMBCS(const String&, const CSID& = CS_Local);

	YSL_END_NAMESPACE(Text)

} //$unit YString;


$unit YResource "yres" //资源管理模块。
{
	$import $unit YObject, Shell::YGDI;


	//全局默认共享资源生成函数（线程空间内共享；全局资源初始化之后可调用）。
	template<class T>
	GHResource<T>&
	GetGlobalResource();

	//资源定义。

	YSL_BEGIN_NAMESPACE(Drawing)

	class YImage : public GMCounter<YImage>, public YCountableObject, public MBitmapBuffer //图像资源。
	{
	public:
		typedef YCountableObject ParentType;

		explicit
		YImage(ConstBitmapPtr = NULL, SDST = 0, SDST = 0);

		DefGetter(ImagePtr, GetBufferPtr())

		void
		SetImage(ConstBitmapPtr, SDST = SCRW, SDST = SCRH);
	}; //class YImage;

	YSL_END_NAMESPACE(Drawing)

} //$unit YResource;


$unit YEventArgs "yevtarg" //事件参数模块。
{
	$import $unit YObject;

	YSL_BEGIN_NAMESPACE(Runtime)

	//转换指针设备光标位置为屏幕点。
	inline Drawing::Point
	ToSPoint(const CursorInfo& c);


	//屏幕事件参数类。
	struct MScreenPositionEventArgs : public MEventArgs, public Drawing::Point
	{
		static const MEventArgs Empty = MScreenPositionEventArgs();

		inline
		MScreenPositionEventArgs(const Drawing::Point& = Drawing::Point::Zero);
	}; //struct MScreenPositionEventArgs;


	//输入事件参数模块类。
	struct MInputEventArgs : public Key
	{
		static const MInputEventArgs Empty = MInputEventArgs();

		inline
		MInputEventArgs(const Key& = 0);
	}; //struct MInputEventArgs;


	//指针设备输入事件参数类。
	struct MTouchEventArgs : public MScreenPositionEventArgs, public MInputEventArgs
	{
		typedef Drawing::Point InputType;

		static const MTouchEventArgs Empty = MTouchEventArgs();

		inline
		MTouchEventArgs(const InputType& = InputType::Empty);
	}; //struct MTouchEventArgs;


	//键盘输入事件参数类。
	struct MKeyEventArgs : public MEventArgs, public MInputEventArgs
	{
		typedef MInputEventArgs InputType;

		static const MKeyEventArgs Empty = MKeyEventArgs();

		inline
		MKeyEventArgs(const InputType& = InputType::Empty);
		inline
		MKeyEventArgs(const BaseInputType&);
	}; //struct MKeyEventArgs;

	YSL_END_NAMESPACE(Runtime)

} //$unit YEeventArgs;


$unit YDevice "ydevice" //平台无关的设备抽象层。
{
	$import $unit Helper::YGlobal, $unit Core::YShell, Shell::YGDI;


	YSL_BEGIN_NAMESPACE(Device)

	//图形设备。
	class YGraphicDevice : public YObject, protected Drawing::Size
	{
	public:
		typedef YObject ParentType;

	private:
		Drawing::BitmapPtr ptr;

	public:
		inline
		YGraphicDevice(SDST w, SDST h, Drawing::BitmapPtr p = NULL);

		DefGetter(const Size&, Size, *this)
		DefGetterBase(u32, Area, Size)
		virtual DefGetter(Drawing::BitmapPtr, Ptr, ptr)

		virtual DefSetter(Drawing::BitmapPtr, Ptr, ptr)
	}; //class YGraphicDevice;


	//屏幕。
	class YScreen : public YGraphicDevice
	{
		friend class YSLib::Def;

	public:
		typedef YGraphicDevice ParentType;
		typedef int BGType;

	private:
		static bool S_InitScr;

		static void InitScreen();
		static void CheckInit();

		BGType bg;

	public:
		YScreen(SDST, SDST, Drawing::BitmapPtr = NULL);

		static void
		Reset();

		inline virtual Drawing::BitmapPtr
		GetPtr() const ythrow();
		DefGetter(const BGType&, BgID, bg)

		DefSetter(const BGType&, BgID, bg)

		void
		Update(Drawing::BitmapPtr);
		void
		Update(Drawing::Color = 0); //以纯色填充屏幕。
	}; //class YScreen;

	YSL_END_NAMESPACE(Device)

} //$unit YDevice;


$header YShellMessageDefinition "ysmsgdef.h" //标准 Shell 消息列表。
{
	!$import;


	$export list "Message.txt";
} //$header YShellMessageDefinition;

$unit YShellMessage "ysmsg" //消息处理模块。
{
	$import $header Core::YShellDefinition, YShellMessageDefinition, $unit YObject, $header Adaptor::Container, <ctime>, $unit YWindow/* for HWND delete procedure; */;

	$import typedef unsigned char u8;
	using Drawing::Point;

	YSL_BEGIN_NAMESPACE(Shells)

	typedef u32 MSGID;
	typedef u8 MSGPRIORITY;

	$export const time_t DEF_TIMEOUT;

	class Message //消息类定义。
	{
		extern friend class YMessageQueue;

	private:
		HSHL hShl; // Shell 句柄。
		MSGID msg; //消息标识。
		MSGPRIORITY prior; //消息优先级。
		WPARAM wParam; //字长相关参数。
		LPARAM lParam; //字长无关参数。

	#ifndef YSLIB_NO_CURSOR

		Point pt; //光标位置。

	#endif

		std::clock_t timestamp; //消息时间戳：消息产生的进程时间。
		std::clock_t timeout; //消息有效期。

	public:

	#ifdef YSLIB_NO_CURSOR

		Message(HSHL = NULL, MSGID = SM_NULL, MSGPRIORITY = 0, WPARAM = 0, const LPARAM = 0);

	#else

		Message(HSHL = NULL, MSGID = SM_NULL, MSGPRIORITY = 0, WPARAM = 0, const LPARAM = 0, const Point& pt_ = Point::Zero);

	#endif

		bool operator==(const Message&) const;
		inline bool operator!=(const Message&) const;

		DefPredicate(TimeOut, timestamp + timeout < std::clock()) //判断消息是否过期。
		DefPredicate(Valid, msg) //判断消息是否有效。

		DefGetter(HSHL, ShellHandle, hShl) //取关联的 Shell 句柄。
		DefGetter(MSGID, MsgID, msg) //取消息标识。
		DefGetter(MSGPRIORITY, Priority, prior) //取消息优先级。
		DefGetter(WPARAM, WParam, wParam)
		DefGetter(LPARAM, LParam, lParam)

	#ifndef YSLIB_NO_CURSOR

		DefGetter(const Point&, CursorLocation, pt)

	#endif

		DefGetter(std::clock_t, Timestamp, timestamp) //取消息时间戳。

		inline void
		SetParam(WPARAM, LPARAM); //设置消息参数。
		DefSetter(std::clock_t, Timestamp, timestamp) //设置消息时间戳。

		void
		UpdateTimestamp() //更新消息时间戳。
	}; //class Message;


	//消息队列类。
	class YMessageQueue : public YObject
	{
	private:
		//消息优先级比较函数对象。
		struct cmp
		{
			bool
			operator ()(const Message&, const Message&);
		}; //struct cmp;

		//消息优先队列。
		priority_queue<Message, vector<Message>, cmp> q;

		PDefH(const Message&, top) const
			ImplBodyMember(q, top)
		PDefH(void, push, const Message& msg)
			ImplBodyMemberVoid(q, push, msg)
		PDefH(void, pop)
			ImplBodyMemberVoid(q, pop)
	public:

		typedef priority_queue<int, vector<int>, cmp>::size_type size_type;

		YMessageQueue(); //默认构造函数：非内联。
		virtual
		~YMessageQueue() ythrow(); //默认析构函数：非内联。

		PDefH(bool, empty) const //判断消息队列是否为空。
			ImplBodyMember(q, empty)
		PDefH(size_type, size) const //取队列中消息容量。
			ImplBodyMember(q, size)

		void
		GetMessage(Message& m); //从消息队列中取优先级最高的消息存至 m 中（不在队列中保留消息）。
		void
		PeekMessage(Message& m) const; //从消息队列中取优先级最高的消息存至 m 中（在队列中保留消息）。

		size_type
		Clear(); //清除消息队列，并返回清除的消息数。
		void
		Update(); //更新消息队列。
		bool
		InsertMessage(const Message& m); //若消息 m 有效，插入 m 至消息队列中。返回 m 是否有效。

	}; //class YMessageQueue;


	//合并 src 所有消息至 dst 中。
	void
	Merge(YMessageQueue& dst, vector<Message>& src);
	void
	Merge(YMessageQueue& dst, YMessageQueue& src);

	YSL_BEGIN_NAMESPACE(Shells)

	using Shells::Message;

} //$unit YShellMessage;


$unit YShell "yshell" // Shell 定义。
{
	$import $header Helper::YGlobal, $unit YApplication,
		$unit Shell::YWindow, Shell::YControl, Shell::YGUI;


	YSL_BEGIN_NAMESPACE(Shells)

	//外壳程序：实现线程语义。
	class YShell : public YObject,
		implements GIContainer<IWindow>
	{
	public:
		typedef list<HWND> WNDs;

	private:
		WNDs sWnds; //窗口组。

	public:
		YShell();
		virtual
		~YShell() ythrow();

		bool
		IsActive() const; //判断 Shell 是否处于激活状态。

		bool
		Activate(); //激活 Shell 对象： shlProc 控制权转移给此对象以维持单线程运行。

		void
		operator+=(IWindow&); //向窗口组添加窗口对象。
		bool
		operator-=(IWindow&); //从窗口组中移除指定窗口对象。
		WNDs::size_type
		RemoveAll(IWindow&); //从窗口组中移除所有指定窗口对象，返回移除的对象数。
		void RemoveWindow(); //移除窗口队列中首个窗口对象。
		HWND
		GetFirstWindowHandle() const; //取得窗口组中首个窗口对象的句柄。
		HWND
		GetTopWindowHandle() const; //取得窗口组中顶端窗口对象的句柄。
		HWND
		GetTopWindowHandle(YDesktop&, const Point&) const; //取得窗口组中指定屏幕的指定的点所处的最顶层窗口对象的句柄。

		bool
		SendWindow(IWindow&); //向屏幕发送指定窗口对象。

		void
		DispatchWindows(); //向屏幕发送窗口对象。

		void
		ClearScreenWindows(YDesktop&); //清除指定屏幕中属于窗口组的窗口对象。

		static LRES
		DefShlProc(const Message&); //默认 Shell 处理函数。

		virtual PDefH(LRES, ShlProc, const Message& m) // Shell 处理函数：响应线程的直接调用。
			ImplRet(DefShlProc(m))

		virtual LRES
		OnActivated(const Message&); // Shell 处理函数：响应线程的激活。

		virtual LRES
		OnDeactivated(const Message&); // Shell 处理函数：响应线程的撤销。
	}; //class YShell;

	class YShellMain : /*public GMCounter<YShellMain>, public YCountableObject,*/ public YShell
	{
	public:
		YShellMain(HSHL);
		inline virtual
		~YShellMain() ythrow();

		inline virtual LRES
		ShlProc(const Message&);
	}; //class YShellMain;

	typedef LRES FSHLPROC(const Message&);
	typedef FSHLPROC* PFSHLPROC;


	struct HShellProc : public GHBase<PFSHLPROC>
	{
		inline
		HShellProc(const PFSHLPROC = NULL);

		inline LRES
		operator()(const Message&) const;

	}; //struct HShellProc;


	// Shell 终止请求。
	void
	PostQuitMessage(int);

	//默认 Shell 处理函数：调用默认 Shell 过程来为应用程序没有处理的任何 Shell 消息提供缺省的处理，以确保每一个消息得到处理。
	inline LRES
	DefShellProc(const Message&);

	/*
	PeekMessage
	//从全局消息队列中取消息。
	lpMsg：接收消息信息的 Message 结构指针。
	hShl：消息关联（发送目标）的 Shell 的句柄，为 NULL 时无限制（为全局对象）。
	wMsgFilterMin：指定被检查的消息范围里的第一个消息。
	wMsgFilterMax：指定被检查的消息范围里的最后一个消息。
	wRemoveMsg：确定消息如何被处理。此参数可取下列值之一：
		PM_NOREMOVE：PeekMessage处理后，消息不从队列中清除。
		PM_REMOVE：PeekMessage处理后，消息从队列中清除。
	*/
	#define PM_NOREMOVE 0x0
	#define PM_REMOVE 0x1
	IRES
	PeekMessage(Message& msg, HSHL hShl = NULL, MSGID wMsgFilterMin = 0, MSGID wMsgFilterMax = 0, u32 wRemoveMsg = PM_NOREMOVE);

	IRES
	GetMessage(Message& msg, HSHL hShl = NULL, MSGID wMsgFilterMin = 0, MSGID wMsgFilterMax = 0);

	ERRNO
	TranslateMessage(const Message& msg);

	LRES
	DispatchMessage(const Message& msg);

	//备份队列消息。
	ERRNO
	BackupMessage(const Message& msg);

	//恢复消息队列。
	void
	RecoverMessageQueue();

	YSL_END_NAMESPACE(Shells)

} //$unit YShell;


$unit YApplication "yapp" //应用程序实例类抽象。
{
	$import $unit YDevice, YShell, YFileSystem, $header YEvent;


	//程序日志。
	class YLog : public YObject
	{
	public:
		YLog();
		virtual
		~YLog();
		YLog&
		operator<<(char);
		YLog&
		operator<<(const char*);
		YLog&
		operator<<(const string&);

		void
		Error(const char*);
		void
		Error(string&);
		void
		FatalError(const char*);
		void
		FatalError(string&);
	}; //class YLog;


	//程序实例：通过单例实现进程唯一性语义。
	class YApplication : public YObject,
		implements GIContainer<YShell>
	{
	public:
		typedef YObject ParentType;
		typedef set<HSHL> SHLs;

		//全局常量。
		static const IO::Path CommonAppDataPath; //程序默认路径。
		static const String CompanyName; //制作组织名称。
		static const String ProductName; //产品名称。
		static const String ProductVersion; //产品版本。

		//标准程序实例事件。
		DefEvent(EventHandler, ApplicationExit) //资源释放函数。
		DefEvent(EventHandler, Idle)

		//全局资源。
		YLog& Log; //默认程序日志。

	private:
		YMessageQueue* pMessageQueue; //主消息队列：在程序实例中实现以保证单线程。
		YMessageQueue* pMessageQueueBackup; //备份消息队列：在程序实例中实现以保证单线程。

	public:
		YFontCache* pFontCache; //默认字体缓存。

	private:
		SHLs sShls; // Shell 对象组：实现 Shell 存储。
		const HSHL hShellMain; //主 Shell 句柄。
		HSHL hShell; //当前 Shell 句柄：指示当前线程空间中运行的 Shell ；应初始化为主 Shell ：全局单线程，生存期与进程相同。

		YApplication();
		YApplication(const YApplication&);
		YApplication
		operator=(const YApplication&);
		static YApplication*
		GetInstancePtr(); //单例构造函数：取得自身实例指针。

	public:
		virtual
		~YApplication() ythrow();

		void
		operator+=(YShell&); //添加 Shell 对象。
		bool
		operator-=(YShell&); //移除指定 Shell 对象。

		bool
		Contains(HSHL) const; //判断给定句柄的 Shell 是否被实例所有。

		DefStaticGetter(YApplication&, App, *GetInstancePtr()) //取得自身实例引用。
		DefStaticGetter(HINSTANCE, InstanceHandle, HINSTANCE(GetInstancePtr())) //取得自身实例句柄。
		DefGetter(const SHLs, ShellSet, sShls) //取 Shell 对象组。
		DefGetter(HSHL, ShellHandle, hShell) //取得线程空间中当前运行的 Shell 的句柄。
		YMessageQueue&
		GetDefaultMessageQueue() ythrow(LoggedEvent);
		YMessageQueue&
		GetBackupMessageQueue() ythrow(LoggedEvent);

		bool
		SetShellHandle(HSHL h); //设置线程空间中当前运行的 Shell 的句柄。

		void
		ResetShellHandle() ythrow(); //复位线程：设置当前运行的线程为主线程。
	}; //class YApplication;


	//全局默认消息插入函数。
	inline void
	InsertMessage(const Message&);
	inline void
	InsertMessage(const HSHL&, const MSGID&, const MSGPRIORITY&, const WPARAM& = 0, const LPARAM& = 0, const Point& = Point::Zero);

	YSL_END_NAMESPACE(Shells)

} //$unit YApplication;


$unit YFileSystem "yfilesys" //平台无关的文件处理系统。
{
	$import $unit Core::YString, Core::YFunc, Helper::YGlobal, Core::YShell/* for HSHL delete procedure; */, $header <iterator>;


	YSL_BEGIN_NAMESPACE(IO)

	//文件系统常量：前缀 FS 表示文件系统 (File System) 。
	$export const CPATH FS_Root;
	$export const CPATH FS_Seperator;
	$export const CPATH FS_Now;
	$export const CPATH FS_Parent;


	typedef char NativePathCharType; //本机路径字符类型，POSIX 为 char ，Windows 为 wchar_t。
	typedef GSStringTemplate<NativePathCharType>::basic_string NativeStringType; //本地字符串类型。


	//路径类。
	class Path
	{
	public:
		typedef uchar_t ValueType;
		typedef GSStringTemplate<ValueType>::basic_string StringType; //内部字符串类型。
	//	typedef std::codecvt<wchar_t, char, std::mbstate_t> codecvt_type;

		static const ValueType Slash;
		static const Path Now;
		static const Path Parent;

	public:
		//编码转换。
	//	static std::locale imbue(const std::locale&);
	//	static const codecvt_type& codecvt();

		//构造函数和析构函数。
		inline
		Path();
		inline
		Path(const ValueType*);
		inline
		Path(const NativePathCharType*);
		inline
		Path(const NativeStringType&);
		template<class _tString>
		inline
		Path(const _tString&)
		inline
		~Path();

		//追加路径。
		Path&
		operator/=(const Path&);

		//查询。
		DefPredicate(Absolute, platform::IsAbsolute(GetNativeString().c_str()))
		DefPredicate(Relative, !IsAbsolute())
		bool
		HasRootName() const;
		bool
		HasRootDirectory() const;
		bool
		HasRootPath() const;
		bool
		HasRelativePath() const;
		bool
		HasParentPath() const;
		bool
		HasFilename() const;
		bool
		HasStem() const;
		bool HasExtension() const;

		//路径分解。
		Path
		GetRootName() const;
		Path
		GetRootDirectory() const;
		Path
		GetRootPath() const;
		Path
		GetRelativePath() const;
		Path
		GetParentPath() const;
		Path
		GetFilename() const;
		Path
		GetStem() const;
		Path
		GetExtension() const;

		//修改函数。

		Path&
		MakeAbsolute(const Path&);
		Path&
		RemoveFilename();
		Path&
		ReplaceExtension(const Path& = Path());

		//迭代器。
		class iterator : public std::iterator<std::bidirectional_iterator_tag, Path>
		{
		private:
			const value_type* ptr;
			StringType::size_type n;

			inline
			iterator();

		public:
			inline
			iterator(const value_type&);
			inline
			iterator(const iterator&);			

			iterator&
			operator++();
			inline iterator
			operator++(int);

			iterator&
			operator--();
			inline iterator
			operator--(int);

			bool
			operator==(const iterator&) const;

			bool
			operator!=(const iterator&) const;

			value_type
			operator*() const;

			DefGetter(const value_type*, Ptr, ptr)
			DefGetter(StringType::size_type, Position, n)
		};

		typedef iterator const_iterator;

		iterator begin() const;

		iterator end() const;
	}; //class Path;


	inline bool
	operator==(const Path&, const Path&);
	inline bool
	operator!=(const Path&, const Path&);
	inline bool
	operator<(const Path&, const Path&);
	inline bool
	operator<=(const Path&, const Path&);
	inline bool
	operator>(const Path&, const Path&);
	inline bool
	operator>=(const Path&, const Path&);

	inline Path
	operator/(const Path&, const Path&);

	inline void
	swap(Path&, Path&);


	//截取路径末尾的文件名。
	const char*
	GetFileName(CPATH);
	string
	GetFileName(const string&);

	//截取路径中的目录名并返回字符串。
	string
	GetDirectoryName(const string&);

	//截取路径中的目录名和文件名保存至字符串，并返回最后一个目录分隔符的位置。
	string::const_iterator
	SplitPath(const string&, string&, string&);


	//截取文件名开头的主文件名（贪婪匹配）。
	String
	GetStem(const String&, const string&);

	//对于两个字符串，判断前者是否是后者的主文件名。
	bool
	IsStem(const char*, const char*);
	bool
	IsStem(const string&, const string&);

	//判断给定两个文件名的主文件名是否相同（忽略大小写；贪婪匹配）。
	bool
	HaveSameStems(const char*, const char*);
	bool
	HaveSameStems(const string&, const string&);

	//截取文件名末尾的扩展名（非贪婪匹配）。
	const char*
	GetExtendName(const char*);
	string
	GetExtendName(const string&);

	//对于两个字符串，判断前者是否是后者的扩展名。
	bool
	IsExtendName(const char*, const char*);
	bool
	IsExtendName(const string&, const string&);

	//判断给定两个文件名的扩展名是否相同（忽略大小写；非贪婪匹配）。
	bool
	HaveSameExtendNames(const char*, const char*);
	bool
	HaveSameExtendNames(const string&, const string&);


	//切换路径。
	inline int
	ChDir(CPATH);
	int
	ChDir(const string&);

	//取当前工作目录。
	string
	GetNowDirectory();

	//验证绝对路径有效性。
	bool
	ValidateDirectory(const string&);
	inline bool
	ValidateDirectory(const Path&);


	//文件名过滤器。
	typedef bool FNFILTER(const String&);
	typedef FNFILTER* PFNFILTER;

	struct HFileNameFilter : public GHBase<PFNFILTER>
	{
		typedef GHBase<PFNFILTER> ParentType;

		inline
		HFileNameFilter(const PFNFILTER = NULL);

		inline bool
		operator()(const String&) const;
	}; //struct HFileNameFilter;


	//文件列表模块。
	class MFileList
	{
	public:
		typedef String ItemType; //项目名称类型。
		typedef vector<ItemType> ListType; //项目列表类型。

	protected:
		Path Directory; //目录的完整路径。
		ListType List; //目录中的项目列表。

	public:
		MFileList(CPATH = NULL); //参数为空时为根目录。
		virtual
		~MFileList();

		//导航至相对路径。
		bool
		operator/=(const string&) ythrow();
		inline bool
		operator/=(const String&);

		DefGetter(const Path&, Directory, Directory) //取目录的完整路径。
		DefGetter(const ListType&, List, List) //取项目列表。

		ListType::size_type
		LoadSubItems(); //在目录中取子项目。

		ListType::size_type
		ListItems(); //遍历目录中的项目，更新至列表。
	}; //class MFileList;

	YSL_END_NAMESPACE(IO)

} //$unit YFileSystem;


$unit YFile "yfile" //平台无关的文件抽象。
{
	$import $unit YString;


	//文件基类。
	$export class YFile : public YObject
	{
	public:
		typedef YObject ParentType;
		typedef std::size_t SizeType;

	protected:
		FILE* fp; //默认文件指针。
		SizeType fsize; //文件大小。

	public:
		explicit
		YFile(CPATH); //按指定文件路径初始化对象。
		virtual
		~YFile();

		DefPredicate(Valid, fp) //判断文件指针是否有效。
		DefGetter(FILE*, Ptr, fp) //取文件指针。
		DefGetter(SizeType, Size, fsize) //取文件长度。

		inline bool
		Open(CPATH); //打开指定路径的文件。
		long
		ftell() const; //取文件指针的位置，返回值语义同 std::ftell 。
		inline void
		rewind() const; //文件指针返回到文件头，同 std:: rewind 。
		inline int
		fseek(long offset, int whence) const; //设置文件指针位置，参数和返回值语义同 std::fseek 函数。
		inline SizeType
		fread(void* ptr, SizeType size, SizeType nmemb); //连续读 nmemb 个大小为 size 文件块到 ptr 中，返回成功读取的文件块数。
		inline int
		feof() const; //检测文件结束符。
	}; //class YFile;

} //$unit YFile;


$unit YFile_(Text) "yftext" //平台无关的文本文件抽象。
{
	$import $unit YFile;


	//文本文件类。
	$export class YTextFile : public YFile
	{
	public:
		typedef YFile ParentType;

	private:
		SizeType bl; // BOM 大小。
		Text::CSID cp; //编码。

	public:
		explicit
		YTextFile(CPATH); //按指定文件路径初始化对象。
		virtual DefEmptyDtor(YTextFile)

		DefGetter(u8, BOMSize, bl) //取 BOM 大小。
		DefGetter(Text::CSID, CP, cp) //取编码。
		DefGetter(SizeType, TextSize, GetSize() - GetBOMSize()) //取文本区段大小。
		DefGetter(u32, Pos, ftell() - bl) //取文件指针关于文本区段的位置。

		u8
		CheckBOM(Text::CSID&); //检查文件头是否有 BOM (Byte Order Mark) ，若有则据此判断编码，返回 BOM 长度。
		void
		Rewind() const; //文件读位置返回到文本区段头。
		void
		SetPos(u32) const; //设置文件读位置。
		void
		Seek(long, int origin) const; //设置文件读位置， origin 语义同 fseek 函数（SEEK_SET 起始为文本区段头）。
		SizeType
		Read(void* s, SizeType n) const; //从文件读 n 字节到 s 中。
		SizeType
		ReadS(uchar_t* s, SizeType n) const; //从文件读 n 字节（按默认编码转化为 UTF-16LE）到 s 中。
	} //class YTextFile;

} //$unit YFile_(Text);


} //$code YSLib::Core;


$code YSLib::Shell {

$unit YGDI "ygdi" //平台无关的图形设备接口实现。
{
	$import $unit Core::YObject, Adaptor::Font;


	// GDI 基本数据类型和宏定义。

	YSL_BEGIN_NAMESPACE(Drawing)

	//基本函数对象。

	//像素填充器。
	template<typename _tPixel>
	struct FillPixel
	{
		_tPixel Color;

		inline explicit
		FillPixel(_tPixel);
		inline void
		operator()(_tPixel*);
	}; //template<typename _tPixel> struct FillPixel;

	//序列转换器。
	struct transSeq
	{
		template<typename _tPixel, class _fTransformPixel>
		void
		operator()(_tPixel*, std::size_t, _fTransformPixel);
	}; //struct transSeq;

	//竖直线转换器。
	struct transVLine
	{
		template<typename _tPixel, class _fTransformPixel>
		void
		operator()(_tPixel* dst, std::size_t n, SDST dw, _fTransformPixel tp);
	}; //struct transVLine;


	//贴图位置计算器。
	void
	blitScale(const Point& sp, const Point& dp, const Size& ss, const Size& ds, const Size& cs,
			  int& minX, int& minY, int& maxX, int& maxY);


	//正则矩形转换器。
	struct transRect
	{
		template<typename _tPixel, class _fTransformPixel, class _fTransformLine>
		void
		operator()(_tPixel* dst, const Size& ds, const Point& dp, const Size& ss,
			_fTransformPixel tp, _fTransformLine tl);
		template<typename _tPixel, class _fTransformPixel, class _fTransformLine>
		inline void
		operator()(_tPixel* dst, const Size& ds, const Rect& rSrc,
			_fTransformPixel tp, _fTransformLine tl)
		template<typename _tPixel, class _fTransformPixel, class _fTransformLine>
		inline void
		operator()(_tPixel* dst, SDST dw, SDST dh, SPOS dx, SPOS dy, SDST sw, SDST sh,
	}; //struct transRect;


	//显示缓存操作：清除/以纯色像素填充。

	//清除指定位置的 n 个连续像素。
	template<typename _tPixel>
	inline void
	ClearPixel(_tPixel* dst, std::size_t n);

	//使用 n 个指定像素连续填充指定位置。
	template<typename _tPixel>
	inline void
	FillSeq(_tPixel* dst, std::size_t n, _tPixel c);

	//使用 n 个指定像素竖直填充指定位置。
	template<typename _tPixel>
	inline void
	FillVLine(_tPixel* dst, std::size_t n, SDST dw, _tPixel c);

	//使用指定像素填充指定的正则矩形区域。
	template<typename _tPixel>
	inline void
	FillRect(_tPixel* dst, const Size& ds, const Point& sp, const Size& ss, _tPixel c);
	template<typename _tPixel>
	inline void
	FillRect(_tPixel* dst, const Size& ds, const Rect& rSrc, _tPixel c);
	template<typename _tPixel>
	inline void
	FillRect(_tPixel* dst, SDST dw, SDST dh, SPOS sx, SPOS sy, SDST sw, SDST sh, _tPixel c);


	//显示缓存操作：简单复制。

	//显示缓存操作：简单贴图。

	//复制一块矩形区域的像素。
	void
	blit(BitmapPtr dst, const Size& ds,
		 ConstBitmapPtr src, const Size& ss,
		 const Point& sp, const Point& dp, const Size& sc);
	//水平翻转镜像（关于水平中轴对称）复制一块矩形区域的像素。
	void
	blitH(BitmapPtr dst, const Size& ds,
		  ConstBitmapPtr src, const Size& ss,
		  const Point& sp, const Point& dp, const Size& sc);
	//竖直翻转镜像（关于竖直中轴对称）复制一块矩形区域的像素。
	void
	blitV(BitmapPtr dst, const Size& ds,
		  ConstBitmapPtr src, const Size& ss,
		  const Point& sp, const Point& dp, const Size& sc);
	//倒置复制一块矩形区域的像素。
	void
	blitU(BitmapPtr dst, const Size& ds,
		  ConstBitmapPtr src, const Size& ss,
		  const Point& sp, const Point& dp, const Size& sc);

	//复制一块矩形区域的像素（使用第 15 位表示透明性）。
	void
	blit2(BitmapPtr dst, const Size& ds,
		  ConstBitmapPtr src, const Size& ss,
		  const Point& sp, const Point& dp, const Size& sc);
	//水平翻转镜像（关于水平中轴对称）复制一块矩形区域的像素（使用第 15 位表示透明性）。
	void
	blit2H(BitmapPtr dst, const Size& ds,
		   ConstBitmapPtr src, const Size& ss,
		   const Point& sp, const Point& dp, const Size& sc);
	//竖直翻转镜像（关于竖直中轴对称）复制一块矩形区域的像素（使用第 15 位表示透明性）。
	void
	blit2V(BitmapPtr dst, const Size& ds,
		   ConstBitmapPtr src, const Size& ss,
		   const Point& sp, const Point& dp, const Size& sc);
	//倒置复制一块矩形区域的像素（使用第 15 位表示透明性）。
	void
	blit2U(BitmapPtr dst, const Size& ds,
		   ConstBitmapPtr src, const Size& ss,
		   const Point& sp, const Point& dp, const Size& sc);

	//复制一块矩形区域的像素（使用 Alpha 通道表示透明性）。
	void
	blit2(BitmapPtr dst, const Size& ds,
		  ConstBitmapPtr src, const u8* srcA, const Size& ss,
		  const Point& sp, const Point& dp, const Size& sc);
	//水平翻转镜像（关于水平中轴对称）复制一块矩形区域的像素（使用 Alpha 通道表示透明性）。
	void
	blit2H(BitmapPtr dst, const Size& ds,
		   ConstBitmapPtr src, const u8* srcA, const Size& ss,
		   const Point& sp, const Point& dp, const Size& sc);
	//竖直翻转镜像（关于竖直中轴对称）复制一块矩形区域的像素（使用 Alpha 通道表示透明性）。
	void
	blit2V(BitmapPtr dst, const Size& ds,
		   ConstBitmapPtr src, const u8* srcA, const Size& ss,
		   const Point& sp, const Point& dp, const Size& sc);
	//倒置复制一块矩形区域的像素（使用 Alpha 通道表示透明性）。
	void
	blit2U(BitmapPtr dst, const Size& ds,
		   ConstBitmapPtr src, const u8* srcA, const Size& ss,
		   const Point& sp, const Point& dp, const Size& sc);

	//复制一块矩形区域的像素（使用 Alpha 通道表示 8 位透明度）。
	void
	blitAlpha(BitmapPtr dst, const Size& ds,
			  ConstBitmapPtr src, const u8* srcA, const Size& ss,
			  const Point& sp, const Point& dp, const Size& sc);
	//水平翻转镜像（关于水平中轴对称）复制一块矩形区域的像素（使用 Alpha 通道表示 8 位透明度）。
	void
	blitAlphaH(BitmapPtr dst, const Size& ds,
			   ConstBitmapPtr src, const u8* srcA, const Size& ss,
			   const Point& sp, const Point& dp, const Size& sc);
	//竖直翻转镜像（关于竖直中轴对称）复制一块矩形区域的像素（使用 Alpha 通道表示 8 位透明度）。
	void
	blitAlphaV(BitmapPtr dst, const Size& ds,
			   ConstBitmapPtr src, const u8* srcA, const Size& ss,
			   const Point& sp, const Point& dp, const Size& sc);
	//倒置复制一块矩形区域的像素（使用 Alpha 通道表示 8 位透明度）。
	void
	blitAlphaU(BitmapPtr dst, const Size& ds,
			   ConstBitmapPtr src, const u8* srcA, const Size& ss,
			   const Point& sp, const Point& dp, const Size& sc);


	//图形接口上下文。
	class GraphicInterfaceContext
	{
	private:
		BitmapPtr pBuffer;
		Drawing::Size Size;

	public:
		inline
		GraphicInterfaceContext(BitmapPtr, const Drawing::Size&);

		DefPredicate(Valid, pBuffer && Size.Width && Size.Height)

		DefGetter(BitmapPtr, BufferPtr, pBuffer)
		DefGetter(const Drawing::Size&, Size, Size)
		DefGetter(SDST, Width, Size.Width)
		DefGetter(SDST, Height, Size.Height)
	}; //class GraphicInterfaceContext;


	//图形接口上下文操作：绘图。

	//绘制像素：(x, y) 。
	inline void
	PutPixel(GraphicInterfaceContext& g, SPOS x, SPOS y, Color c);

	//绘制点：p(x, y) 。
	inline bool
	DrawPoint(GraphicInterfaceContext& g, SPOS x, SPOS y, Color c);
	inline bool
	DrawPoint(GraphicInterfaceContext& g, const Point& p, Color c);

	//绘制水平线段：指定水平坐标 x1 、 x2 ，竖直坐标 y 。
	bool
	DrawHLineSeg(GraphicInterfaceContext* pGDC, SPOS y, SPOS x1, SPOS x2, Color c);

	//绘制竖直线段：指定水平坐标 x ，竖直坐标 y1 、 y2 。
	bool
	DrawVLineSeg(GraphicInterfaceContext* pGDC, SPOS x, SPOS y1, SPOS y2, Color c);

	//绘制一般线段：顶点 p1(x1, y1), p2(x2, y2) 。
	bool
	DrawLineSeg(GraphicInterfaceContext& g, SPOS x1, SPOS y1, SPOS x2, SPOS y2, Color c);
	inline bool
	DrawLineSeg(GraphicInterfaceContext& g, const Point& p1, const Point& p2, Color c);

	//绘制空心正则矩形：对角线顶点 p1(x1, y1), p2(x2, y2) 。
	bool
	DrawRect(GraphicInterfaceContext& g, SPOS x1, SPOS y1, SPOS x2, SPOS y2, Color c);
	inline bool
	DrawRect(GraphicInterfaceContext& g, const Point& p1, const Point& p2, Color c);
	inline bool
	DrawRect(GraphicInterfaceContext& g, const Point& p, const Size& s, Color c);
	inline bool
	DrawRect(GraphicInterfaceContext& g, const Rect& r, Color c);


	// GDI 逻辑对象。

	class PenStyle //笔样式：字体和笔颜色。
	{
	public:
		Drawing::Font Font; //字体。
		Drawing::Color Color; //笔颜色。

		inline explicit
		PenStyle(const FontFamily& = GetDefaultFontFamily(), Font::SizeType = Font::DefSize, Drawing::Color = Drawing::Color::White);

		DefGetterMember(const FontFamily&, FontFamily, Font)
		DefGetterMember(YFontCache&, Cache, Font)
	}; //class PenStyle;

	struct Padding //边距样式。
	{
		typedef YObject ParentType;

		SDST Left, Right, Top, Bottom; //边距：左、右、上、下。

		explicit
		Padding(SDST = 4, SDST = 4, SDST = 4, SDST = 4); //使用 4 个 16 位无符号整数形式初始化边距。
		explicit
		Padding(u64); //使用 64 位无符号整数形式初始化边距。

		inline SDST
		GetHorizontal() const; //取水平边距和。
		inline SDST
		GetVertical() const; //取竖直边距和。
		u64
		GetAll() const; //取边距（64 位无符号整数形式）。

		inline void
		SetAll(u64); //设置边距（64 位无符号整数形式）。
		inline void
		SetAll(SDST, SDST); //设置边距（2 个 16 位无符号整数形式，分别表示水平边距和竖直边距）。
		void
		SetAll(SDST, SDST, SDST, SDST); //设置边距（4 个 16 位无符号整数形式）。

		Padding&
		operator+=(const Padding&);
		friend Padding
		operator+(const Padding& a, const Padding& b);
	}; //struct Padding;


	class MBitmapBuffer : public Size //矩形图像缓冲区。
	{
	protected:
		BitmapPtr img; //显示缓冲区指针。

	public:
		inline
		MBitmapBuffer();
		MBitmapBuffer(ConstBitmapPtr, SDST, SDST);
		inline virtual
		~MBitmapBuffer();

		inline friend bool
		operator==(const MBitmapBuffer&, const MBitmapBuffer&);

		inline
		operator GraphicInterfaceContext() const; //生成图形接口上下文。

		DefGetter(SDST, Width, Width) //取缓冲区的宽。
		DefGetter(SDST, Height, Height) //取缓冲区的高。
		DefGetter(BitmapPtr, BufferPtr, img) //取缓冲区指针。
		DefGetter(std::size_t, SizeOfBuffer, sizeof(PixelType) * GetArea()) //取缓冲区占用空间。

		//重新设置缓冲区的大小。
		virtual void
		SetSize(SPOS, SPOS); 
		virtual void
		SetSizeSwap(); //交换宽和高；同时交换边距。

		virtual void
		ClearImage() const; //清除缓冲区。
		virtual void
		Fill(Color) const; //以纯色填充显示缓冲区。

		virtual void
		CopyToBuffer(BitmapPtr, ROT = RDeg0, const Size& ds = Size::FullScreen,
			const Point& sp = Point::Zero, const Point& dp = Point::Zero, const Size& sc = Size::FullScreen) const; //复制至屏幕指定区域。
	}; //class MBitmapBuffer;


	class MBitmapBufferEx : public MBitmapBuffer //矩形增强图像缓冲区。
	{
	protected:
		u8* imgAlpha; // Alpha 缓冲区指针。

	public:
		inline
		MBitmapBufferEx();
		inline
		MBitmapBufferEx(ConstBitmapPtr, SDST, SDST);
		inline virtual
		~MBitmapBufferEx();

		inline friend bool
		operator==(const MBitmapBufferEx&, const MBitmapBufferEx&);

		DefGetter(u8*, BufferAlphaPtr, imgAlpha) //取 Alpha 缓冲区的指针。
		DefGetter(std::size_t, SizeOfBufferAlpha, sizeof(u8) * GetArea()) //取 Alpha 缓冲区占用空间。

		//重新设置缓冲区的大小。
		virtual void
		SetSize(SPOS, SPOS); 
		virtual void
		SetSizeSwap(); //交换宽和高；同时交换边距。

		virtual void
		ClearImage() const; //清除缓冲区。

		void
		CopyToBuffer(BitmapPtr, ROT = RDeg0, const Size& ds = Size::FullScreen,
			const Point& sp = Point::Zero, const Point& dp = Point::Zero, const Size& sc = Size::FullScreen) const; //复制至屏幕指定区域。
		void
		BlitToBuffer(BitmapPtr, ROT = RDeg0, const Size& ds = Size::FullScreen,
			const Point& sp = Point::Zero, const Point& dp = Point::Zero, const Size& sc = Size::FullScreen) const; //贴图至屏幕指定区域。
	}; //class MBitmapBufferEx;

	YSL_END_NAMESPACE(Drawing)

} //$unit YGDI;


$unit YGUI "ygui" //平台无关的图形用户界面基础实现。
{
	$import $unit Core::YShellProcessing, Shell::YDesktop, Shell::YForm, Service::YTimer;

	YSL_BEGIN_NAMESPACE(Runtime)

	//从指定 Shell 传递指定屏幕的指针设备光标至 GUI 界面，返回部件指针。
	IWidget*
	GetCursorWidgetPtr(HSHL, YDesktop&, const Point&);

	//取指定屏幕中的当前焦点对象。
	IVisualControl*
	GetFocusedObject(YDesktop&);

	//级联请求可视控件及上层容器焦点。
	void
	RequestFocusCascade(IVisualControl&);

	//级联释放可视控件及上层容器焦点。
	void
	ReleaseFocusCascade(IVisualControl&);


	//标准 GUI 事件回调函数抽象类。
	typedef GAHEventCallback<Components::Controls::IVisualControl, Event> AHEventCallback;
	typedef GAHEventCallback<Components::Controls::IVisualControl, Runtime::MKeyEventArgs> AHKeyCallback;
	typedef GAHEventCallback<Components::Controls::IVisualControl, Runtime::MTouchEventArgs> AHTouchCallback;

	//标准 GUI 事件回调函数类型。
	typedef bool FKeyCallback(Components::Controls::IVisualControl&, const Runtime::MKeyEventArgs&);
	typedef bool FTouchCallback(Components::Controls::IVisualControl&, const Runtime::MTouchEventArgs&);
	typedef FKeyCallback* PFKeyCallback;
	typedef FTouchCallback* PFTouchCallback;

	//标准 GUI 事件回调函数对象类。

	struct HKeyCallback : public GHBase<PFKeyCallback>, public AHKeyCallback
	{
		inline explicit
		HKeyCallback(Runtime::MKeyEventArgs, PFKeyCallback);

		inline bool
		operator()(Components::Controls::IVisualControl&);
	}; //struct HKeyCallback;

	struct HTouchCallback : public GHBase<PFTouchCallback>, public AHTouchCallback
	{
		inline explicit
		HTouchCallback(Runtime::MTouchEventArgs, PFTouchCallback);

		inline bool
		operator()(Components::Controls::IVisualControl&);
	}; //struct HTouchCallback;


	//记录输入保持状态。

	YSL_BEGIN_NAMESPACE(InputStatus)

	typedef enum
	{
		Free = 0,
		Pressed = 1,
		Held = 2
	} HeldStateType;

	extern HeldStateType KeyHeldState, TouchHeldState;

	bool
	IsOnDragging();

	const Vec&
	GetDragOffset();

	void
	SetDragOffset(const Vec& = Vec::FullScreen);

	void
	CheckTouchedControlBounds(Components::Controls::IVisualControl&, const MTouchEventArgs&);

	bool
	RepeatHeld(HeldStateType&, const MKeyEventArgs&, Timers::TimeSpan = 240, Timers::TimeSpan = 120);

	void
	ResetHeldState(HeldStateType&);

	YSL_END_NAMESPACE(InputStatus)


	//响应标准按键状态。
	bool
	ResponseKeyUp(YDesktop&, const Runtime::MKeyEventArgs&);
	bool
	ResponseKeyDown(YDesktop&, const Runtime::MKeyEventArgs&);
	bool
	ResponseKeyHeld(YDesktop&, const Runtime::MKeyEventArgs&);

	//响应标准屏幕点击状态。
	bool
	ResponseTouchUp(IWidgetContainer&, const Runtime::MTouchEventArgs&);
	bool
	ResponseTouchDown(IWidgetContainer&, const Runtime::MTouchEventArgs&);
	bool
	ResponseTouchHeld(IWidgetContainer&, const Runtime::MTouchEventArgs&);

	YSL_END_NAMESPACE(Runtime)

	YSL_BEGIN_NAMESPACE(Drawing)

	//取图形接口上下文。
	inline GraphicInterfaceContext
	GetGraphicInterfaceContext(HWND);


	//绘制界面元素边框。
	void
	DrawBounds(GraphicInterfaceContext&, const Point&, const Size&, PixelType);

	//绘制窗口边框。
	void
	DrawWindowBounds(HWND, PixelType);

	//绘制部件边框。
	void
	DrawWidgetBounds(IWidget&, PixelType);

	YSL_END_NAMESPACE(Drawing)

} //$unit YGUI;


$unit YComponent "ycomp" //平台无关的 Shell 组件实现。
{
	$import $unit Core::YApplication, $header YEvent, $unit YEventArgs;


	YSL_BEGIN_NAMESPACE(Components)

	//基本组件接口。
	DeclInterface(IComponent)
	EndDecl


	//基本组件。
	class YComponent : public GMCounter<YComponent>, public YCountableObject
	{
	public:
		typedef YCountableObject ParentType;
	}; //class YComponent;


	//通用对象组类模板。
	template<class _type, class _tContainer = set<_type*> >
	class GMContainer : public _tContainer,
		implements GIContainer<_type>
	{
	public:
		typedef _tContainer ContainerType; //对象组类型。

		inline
		GMContainer();
		virtual DefEmptyDtor(GMContainer)

		inline ContainerType&
		GetContainer();
		inline const ContainerType&
		GetContainer() const;

		inline void
		operator+=(_type& w); //向对象组添加对象。
		inline bool
		operator-=(_type& w); //从对象组移除对象。
	}; //template<class _type, class = set<_type*> > GMContainer;


	class AFocusRequester;


	//焦点响应器模板。
	template<class _type>
	class GMFocusResponser// : implements GIContainer<_type>
	{
		friend class AFocusRequester;

	protected:
		_type* pFocusing; //焦点对象指针。
		Components::GMContainer<_type> sFOs; //焦点对象组。

		typedef typename Components::GMContainer<_type>::ContainerType FOs; //焦点对象组类型。

		inline
		GMFocusResponser();
		inline
		~GMFocusResponser();

	public:
		//判断给定指针是否和焦点对象指针相等。
		inline bool
		IsFocusing(_type* p) const;

		//取焦点对象指针。
		inline _type*
		GetFocusingPtr() const;
		//取焦点对象组（只读）。
		inline const FOs&
		GetFocusingSet() const;

	protected:
		//设置焦点对象指针。
		bool
		SetFocusingPtr(_type*);

		//向焦点对象组添加焦点对象。
		inline void
		operator+=(_type&);
		//从焦点对象组移除焦点对象。
		inline bool
		operator-=(_type&);

	public:
		//清空焦点指针。
		inline bool
		ClearFocusingPtr();
	}; //template<class _type> class GMFocusReponser;


	//焦点申请器接口模板。
	template<class _type = AFocusRequester>
	DeclInterface(GIFocusRequester)
		DeclIEntry(bool IsFocused() const)
		DeclIEntry(bool IsFocusOfContainer(GMFocusResponser<_type>&) const)

		DeclIEntry(bool CheckRemoval(GMFocusResponser<_type>&) const)

		DeclIEntry(void ReleaseFocus(const MEventArgs& = GetZeroElement<MEventArgs>()))
	EndDecl


	//焦点申请器。
	class AFocusRequester: implements GIFocusRequester<AFocusRequester>
	{
	protected:
		bool bFocused; //是否为所在容器的焦点。

	public:
		inline
		AFocusRequester();
		inline virtual
		~AFocusRequester();

		//判断是否为获得焦点状态。
		inline bool
		IsFocused() const;
		//判断是否已在指定响应器中获得焦点。
		inline bool
		IsFocusOfContainer(GMFocusResponser<AFocusRequester>&) const;
		template<class _type>
		inline bool
		IsFocusOfContainer(GMFocusResponser<_type>&) const;

		//判断是否已在指定响应器中获得焦点，若是则释放焦点。
		bool
		CheckRemoval(GMFocusResponser<AFocusRequester>&) const;
		template<class _type>
		bool
		CheckRemoval(GMFocusResponser<_type>&) const;

		//向指定响应器对应的容器申请获得焦点。
		bool
		RequestFocus(GMFocusResponser<AFocusRequester>&);
		template<class _type>
		bool
		RequestFocus(GMFocusResponser<_type>&);
		//释放焦点。
		bool
		ReleaseFocus(GMFocusResponser<AFocusRequester>&);
		template<class _type>
		bool
		ReleaseFocus(GMFocusResponser<_type>&);

		DeclIEntry(void ReleaseFocus(const MEventArgs& = GetZeroElement<MEventArgs>()))
	}; //class AFocusRequester;


	//序列视图类模板。
	template<class _tContainer>
	class GSequenceViewer
	{
	public:
		typedef typename _tContainer::size_type SizeType; //项目下标类型。
		typedef std::ptrdiff_t SizeType; //项目索引类型。

	private:
		_tContainer& c; //序列容器引用。
		IndexType nIndex, //项目索引：视图中首个项目下标，若不存在则为 -1 。
			nSelected; //选中项目下标，大于等于 GetTotal() 时无效。
		SizeType nLength; //视图长度。
		bool bSelected; //选中状态。

	public:
		explicit
		GSequenceViewer(_tContainer& c_);

		inline GSequenceViewer&
		operator++(); //选中项目下标自增。
		inline GSequenceViewer&
		operator--(); //选中项目下标自减。
		inline GSequenceViewer&
		operator++(int); //视图中首个项目下标自增。
		inline GSequenceViewer&
		operator--(int); //视图中首个项目下标自减。
		inline GSequenceViewer&
		operator>>(IndexType d); //视图中首个项目下标增加 d 。
		inline GSequenceViewer&
		operator<<(IndexType d); //视图中首个项目下标减少 d 。
		inline GSequenceViewer&
		operator+=(IndexType d); //选中项目下标增加 d 。
		inline GSequenceViewer&
		operator-=(IndexType d); //选中项目下标减少 d 。

		DefPredicate(Selected, bSelected) //判断是否为选中状态。

		DefGetter(SizeType, Total, c.size()) //取容器中元素个数。
		DefGetter(SizeType, Length, nLength)
		DefGetter(IndexType, Index, nIndex)
		DefGetter(IndexType, Selected, nSelected)
		DefGetter(SizeType, Valid, vmin(GetTotal() - GetIndex(), GetLength())) //取当前视图有效元素个数。

		bool
		SetIndex(IndexType);
		bool
		SetLength(SizeType);
		bool
		SetSelected(IndexType);

		bool
		ClearSelected(); //取消选中状态。

		bool
		RestrictSelected(); //约束被选中的元素在视图内。
		bool
		RestrictViewer(); //约束视图包含被选中的元素。

		bool
		MoveViewerToBegin(); //移动视图至序列起始。
		bool
		MoveViewerToEnd(); //移动视图至序列结尾。
	}; //template<class _tContainer> class GSequenceViewer;


	//控制台。
	class YConsole : public YComponent
	{
	public:
		YScreen& Screen;

		inline explicit
		YConsole(YScreen& = *pDefaultScreen, bool = true, Drawing::Color = Drawing::Color::White, Drawing::Color = Drawing::Color::Black);
		inline virtual
		~YConsole();

		inline void
		Activate(Drawing::Color = Drawing::Color::White, Drawing::Color = Drawing::Color::Black);

		inline void
		Deactivate();
	}; //class YConsole;

	YSL_END_NAMESPACE(Components)

} //$unit YComponent;


$unit YDesktop "ydesktop" //平台无关的桌面抽象层。
{
	$import $unit YWindow;


	YSL_BEGIN_NAMESPACE(Components)

	//桌面。
	class YDesktop : public YFrameWindow
	{
		friend class YSLib::Def;

	public:
		typedef YComponent ParentType;
		typedef list<IVisualControl*> DOs; //桌面对象组类型。

	private:
		YScreen& Screen; //屏幕对象。
		DOs sDOs; //桌面对象组（末尾表示顶端）。

	public:
		explicit
		YDesktop(YScreen&, Color = 0, GHResource<Drawing::YImage> = NULL);
		virtual DefEmptyDtor(YDesktop)

		DefGetter(const YScreen&, Screen, Screen) //取屏幕对象。
		DefGetter(const Drawing::MBitmapBuffer&, Buffer, *this) //取显示缓冲区。
		DefGetter(BitmapPtr, BackgroundPtr, Screen.GetPtr()) //取背景指针。

		virtual PDefH(IVisualControl*, GetTopVisualControlPtr, const Point& p) const
			ImplBodyBase(YDesktop, GetTopDesktopObjectPtr, p)

		void
		operator+=(IVisualControl&); //向桌面对象组添加桌面对象。
		bool
		operator-=(IVisualControl&); //从桌面对象组中移除指定桌面对象。
		DOs::size_type
		RemoveAll(IVisualControl&); //从桌面对象组中移除所有指定桌面对象，返回移除的对象数。
		bool
		MoveToTop(IVisualControl&); //从桌面对象组中查找指定桌面对象对象并重新插入至顶端。
		void
		RemoveTopDesktopObject(); //移除桌面对象组中首个桌面对象。
		void
		ClearDesktopObjects(); //清除桌面对象组。
		IVisualControl*
		GetFirstDesktopObjectPtr() const; //取得桌面对象组中首个桌面对象的句柄。
		IVisualControl*
		GetTopDesktopObjectPtr() const; //取得桌面对象组中顶端桌面对象的句柄。
		IVisualControl*
		GetTopDesktopObjectPtr(const Point&) const; //取得桌面对象组中包含指定点的顶端桌面对象的句柄。

		virtual void
		DrawBackground();
		void
		DrawDesktopObjects(); //依次绘制窗口组对象。
		virtual void
		Draw();

		virtual void
		Refresh();
		virtual void
		Update(); //更新缓冲区内容至屏幕。
	}; //class YDesktop;

	YSL_END_NAMESPACE(Components)

} //$unit YDesktop;


$unit YWidget "ywidget" //平台无关的图形用户界面部件实现。
{
	$import $unit YComponent, Core::YResource, YText,
		YWindow, YControl;


	YSL_BEGIN_NAMESPACE(Components)

	//前向声明。

	using Drawing::PixelType;
	using Drawing::BitmapPtr;
	using Drawing::ConstBitmapPtr;
	using Drawing::ScreenBufferType;
	using Drawing::Color;

	using Drawing::Point;
	using Drawing::Vec;
	using Drawing::Size;
	using Drawing::Rect;

	using Drawing::YImage;

	YSL_BEGIN_NAMESPACE(Widgets)

	// GUI 部件定义。

	//部件接口。
	DeclInterface(IWidget)
		DeclIEntry(bool IsVisible() const) //判断是否可见。
		DeclIEntry(bool IsTransparent() const) //判断是否透明。
		DeclIEntry(bool IsBgRedrawed() const) //判断是否需要重绘。

		DeclIEntry(bool Contains(const Point&) const) //判断点是否在边界内或边界上。

		DeclIEntry(const Point& GetLocation() const)
		DeclIEntry(const Size& GetSize() const)
		DeclIEntry(IWidgetContainer* GetContainerPtr() const)
		DeclIEntry(HWND GetWindowHandle() const)

		DeclIEntry(void SetVisible(bool = true)) //设置可见。
		DeclIEntry(void SetTransparent(bool = true)) //设置透明。
		DeclIEntry(void SetBgRedrawed(bool = true)) //设置重绘状态。
		DeclIEntry(void SetLocation(const Point&)) //设置左上角所在位置（相对于容器的偏移坐标）。

		DeclIEntry(void DrawBackground()) //绘制背景。
		DeclIEntry(void DrawForeground()) //绘制前景。

		DeclIEntry(void Refresh()) //刷新至窗口缓冲区。

		DeclIEntry(void RequestToTop()) //请求提升至容器顶端。
	EndDecl


	//部件容器接口。
	DeclBasedInterface(IWidgetContainer, IWidget)
		DeclIEntry(void operator+=(IWidget&)) //向部件组添加部件。
		DeclIEntry(bool operator-=(IWidget&)) //从部件组移除部件。
		DeclIEntry(void operator+=(IVisualControl&)) //向焦点对象组添加可视控件。
		DeclIEntry(bool operator-=(IVisualControl&)) //从焦点对象组移除可视控件。
		DeclIEntry(void operator+=(GMFocusResponser<IVisualControl>&)) //向焦点对象组添加子焦点对象容器。
		DeclIEntry(bool operator-=(GMFocusResponser<IVisualControl>&)) //从焦点对象组移除子焦点对象容器。

		DeclIEntry(IWidget* GetTopWidgetPtr(const Point&) const) //取指定的点（屏幕坐标）所处的部件的指针。
		DeclIEntry(IVisualControl* GetTopVisualControlPtr(const Point&) const) //取指定的点（屏幕坐标）所处的焦点对象的指针。
		DeclIEntry(Point GetContainerLocationOffset(const Point& = Point::Zero) const) //取指定的点（相对此容器的坐标）相对于此容器的父容器的偏移坐标。
		DeclIEntry(Point GetWindowLocationOffset(const Point& = Point::Zero) const) //取指定的点（相对此容器的坐标）相对于此容器的父窗口的偏移坐标。

		DeclIEntry(void ClearFocusingPtr()) //清除焦点指针。
	EndDecl


	Point
	GetLocationOffset(IWidget*, const Point&, const HWND&);


	//可视样式模块。
	class MVisual
	{
	public:
		bool Visible; //可见性。
		bool Transparent; //透明性。

	private:
		mutable bool bBgRedrawed; //背景重绘属性。

	protected:
		Point Location; //左上角所在位置（相对于容器的偏移坐标）。
		Drawing::Size Size; //部件大小。

	public:
		Color BackColor; //默认背景色。
		Color ForeColor; //默认前景色。

		explicit
		MVisual(const Rect& = Rect::Empty,
			PixelType = Color::White, PixelType = Color::Black);
		virtual DefEmptyDtor(MVisual)

		DefPredicate(Visible, Visible)
		DefPredicate(Transparent, Transparent)
		DefPredicate(BgRedrawed, bBgRedrawed)

		//判断包含关系。
		PDefH(bool, Contains, const Point& p) const
			ImplBodyMember(GetBounds(), IsInBoundsRegular, p)
		PDefH(bool, Contains, const int& x, const int& y) const //判断点(x, y)是否在边界内或边界上。
			ImplBodyMember(GetBounds(), IsInBoundsRegular, x, y)

		DefGetter(SPOS, X, Location.X)
		DefGetter(SPOS, Y, Location.Y)
		DefGetter(SDST, Width, Size.Width)
		DefGetter(SDST, Height, Size.Height)
		virtual DefGetter(const Point&, Location, Location)
		virtual DefGetter(const Drawing::Size&, Size, Size)
		virtual DefGetter(Rect, Bounds, Rect(Location, Size.Width, Size.Height))

		DefSetterDe(bool, Visible, Visible, true)
		DefSetterDe(bool, Transparent, Transparent, true)
		DefSetterDe(bool, BgRedrawed, bBgRedrawed, true)
		virtual DefSetter(const Point&, Location, Location)
		virtual PDefH(void, SetLocation, SPOS x, SPOS y)
			ImplBodyBaseVoid(MVisual, SetLocation, Point(x, y))
		virtual void
		SetSize(SDST, SDST);
		virtual void
		SetBounds(const Rect& r);
	}; //class MVisual;


	//部件模块。
	class MWidget : public MVisual
	{
	protected:
		HWND hWindow; //从属的窗口的句柄。

	public:
		IWidgetContainer* const pContainer; //从属的部件容器的指针。

		explicit
		MWidget(HWND = NULL, const Rect& = Rect::Empty, IWidgetContainer* = NULL,
			Color = Color::White, Color = Color::Black);

		//判断从属关系。
		inline bool
		BelongsTo(HWND) const;
		inline bool
		BelongsTo(IWidgetContainer*) const;

		virtual DefGetter(IWidgetContainer*, ContainerPtr, pContainer)
		virtual DefGetter(HWND, WindowHandle, hWindow)
		Point
		GetLocationForWindow() const; //取部件相对于最直接的窗口的位置（若无窗口则返回 FullScreen ）。
		Point
		GetLocationForParentContainer() const; //取部件相对于容器的父容器的位置（若无容器则返回 FullScreen ）。
		Point
		GetLocationForParentWindow() const; //取部件相对于容器的父窗口的位置（若无容器则返回 FullScreen ）。

		inline virtual void
		Fill(); //以背景色填充显示缓冲区。
		virtual void
		Fill(Color); //以纯色填充显示缓冲区。
		virtual void
		DrawBackground();
		virtual void
		DrawForeground();

		virtual void
		Refresh();
	}; //class MWidget;


	//部件。
	class YWidget : public GMCounter<YWidget>, public YComponent, public MWidget,
		implements IWidget
	{
	public:
		typedef YComponent ParentType;

		explicit
		YWidget(HWND = NULL, const Rect& = Rect::Empty, IWidgetContainer* = NULL);
		virtual
		~YWidget();

		virtual DefPredicateBase(Visible, MVisual)
		virtual DefPredicateBase(Transparent, MVisual)
		virtual DefPredicateBase(BgRedrawed, MVisual)

		//判断包含关系。
		virtual PDefH(bool, Contains, const Point& p) const
			ImplBodyBase(MVisual, Contains, p)

		virtual DefGetterBase(const Point&, Location, MVisual)
		virtual DefGetterBase(const Drawing::Size&, Size, MVisual)
		virtual DefGetterBase(IWidgetContainer*, ContainerPtr, MWidget)
		virtual DefGetterBase(HWND, WindowHandle, MWidget)

		virtual DefSetterBaseDe(bool, Visible, MVisual, true)
		virtual DefSetterBaseDe(bool, Transparent, MVisual, true)
		virtual DefSetterBaseDe(bool, BgRedrawed, MVisual, true)
		virtual DefSetterBase(const Point&, Location, MVisual)

		virtual PDefH(void, DrawBackground)
			ImplBodyBaseVoid(MWidget, DrawBackground)
		virtual PDefH(void, DrawForeground)
			ImplBodyBaseVoid(MWidget, DrawForeground)

		virtual PDefH(void, Refresh)
			ImplBodyBaseVoid(MWidget, Refresh)

		inline virtual void
		RequestToTop();
	}; //class YWidget;


	//部件容器模块。
	class MWidgetContainer : public GMFocusResponser<IVisualControl>,
		implements GIContainer<IVisualControl>
	{
	public:
		typedef Components::GMContainer<IWidget> WidgetSet;
		typedef WidgetSet::ContainerType WGTs; //部件组类型。
		typedef Components::GMContainer<GMFocusResponser<IVisualControl> > FOCs; //子焦点对象容器组类型。

	protected:
		WidgetSet sWgtSet; //部件对象组模块。
		FOCs sFOCSet; //子焦点对象容器组。

	public:
		MWidgetContainer();
		virtual DefEmptyDtor(MWidgetContainer);

	protected:
		PDefHOperator(void, +=, IVisualControl& r) //向焦点对象组添加焦点对象。
			ImplBodyBaseVoid(GMFocusResponser<IVisualControl>, operator+=, r)
		PDefHOperator(bool, -=, IVisualControl& r) //从焦点对象组移除焦点对象。
			ImplBodyBase(GMFocusResponser<IVisualControl>, operator-=, r)
		PDefHOperator(void, +=, GMFocusResponser<IVisualControl>& c) //向子焦点对象容器组添加子焦点对象容器。
			ImplBodyMemberVoid(sFOCSet, insert, &c)
		PDefHOperator(bool, -=, GMFocusResponser<IVisualControl>& c) //从子焦点对象容器组移除子焦点对象容器。
			ImplBodyMember(sFOCSet, erase, &c)

	public:
		virtual Controls::IComponent*
		GetFocusingPtr() const;
		virtual IWidget*
		GetTopWidgetPtr(const Point&);
		virtual IVisualControl*
		GetTopVisualControlPtr(const Point&);
	}; //class MWidgetContainer;


	//部件容器。
	class YWidgetContainer : public GMCounter<YWidgetContainer>, public YComponent, public MWidget, public MWidgetContainer,
		implements IWidgetContainer
	{
	public:
		typedef YComponent ParentType;

		explicit
		YWidgetContainer(HWND, const Rect& = Rect::Zero, IWidgetContainer* = NULL);
		virtual
		~YWidgetContainer();

		inline void
		operator+=(IWidget&);
		inline bool
		operator-=(IWidget&);
		inline void
		operator+=(IVisualControl&);
		inline bool
		operator-=(IVisualControl&);
		inline virtual void
		operator+=(GMFocusResponser<IVisualControl>&);
		inline virtual bool
		operator-=(GMFocusResponser<IVisualControl>&);

		virtual DefPredicateBase(Visible, MVisual)
		virtual DefPredicateBase(Transparent, MVisual)
		virtual DefPredicateBase(BgRedrawed, MVisual)

		//判断包含关系。
		virtual PDefH(bool, Contains, const Point& p) const
			ImplBodyBase(MVisual, Contains, p)

		virtual DefGetterBase(const Point&, Location, MVisual)
		virtual DefGetterBase(const Drawing::Size&, Size, MVisual)
		virtual DefGetterBase(IWidgetContainer*, ContainerPtr, MWidget)
		virtual DefGetterBase(HWND, WindowHandle, MWidget)
		virtual PDefH(IWidget*, GetTopWidgetPtr, const Point& p) const
			ImplBodyBase(MWidgetContainer, GetTopWidgetPtr, p)
		virtual PDefH(IVisualControl*, GetTopVisualControlPtr, const Point& p) const
			ImplBodyBase(MWidgetContainer, GetTopVisualControlPtr, p)
		virtual Point
		GetContainerLocationOffset(const Point& = Point::Zero) const;
		virtual Point
		GetWindowLocationOffset(const Point& = Point::Zero) const;

		virtual DefSetterBaseDe(bool, Visible, MVisual, true)
		virtual DefSetterBaseDe(bool, Transparent, MVisual, true)
		virtual DefSetterBaseDe(bool, BgRedrawed, MVisual, true)
		virtual DefSetterBase(const Point&, Location, MVisual)

		virtual PDefH(void, ClearFocusingPtr)
			ImplBodyBaseVoid(MWidgetContainer, ClearFocusingPtr)

		virtual PDefH(void, DrawBackground)
			ImplBodyBaseVoid(MWidget, DrawBackground)
		virtual PDefH(void, DrawForeground)
			ImplBodyBaseVoid(MWidget, DrawForeground)

		virtual PDefH(void, Refresh)
			ImplBodyBaseVoid(MWidget, Refresh)

		inline virtual void
		RequestToTop();
	}; //class YWidgetContainer;


	//标签模块。
	class MLabel
	{
	protected:
		GHResource<Drawing::TextRegion> prTextRegion; //文本区域指针。

	public:
		Drawing::Font Font; //字体。
		Drawing::Padding Margin; //文本和容器的间距。
		bool AutoSize; //启用根据字号自动调整大小。
		bool AutoEllipsis; //启用对超出标签宽度的文本调整大小。
		String Text; //标签文本。

		template<class _tChar>
		MLabel(const _tChar*, const Drawing::Font& = Drawing::Font::GetDefault(), GHResource<Drawing::TextRegion> = NULL);

	protected:
		DefEmptyDtor(MLabel)

		void
		PaintText(MWidget&);
	}; //class MLabel;


	//标签。
	class YLabel : public GMCounter<YLabel>, public YWidget, public Widgets::MLabel
	{
	public:
		typedef YWidget ParentType;

	/*
		YImage BackgroundImage; //背景图像。
		YImage Image; //前景图像。
	*/

		//用字符串在窗口中以给定字号初始化标签。
		template<class _tChar>
		YLabel(HWND, const _tChar*, const Rect& = Rect::FullScreen,
			const Drawing::Font& = Drawing::Font::GetDefault(), IWidgetContainer* = NULL, GHResource<Drawing::TextRegion> = NULL);

		virtual void
		DrawForeground();
	}; //class YLabel;

	YSL_END_NAMESPACE(Widgets)

	YSL_END_NAMESPACE(Components)

} //$unit YWidget;


$unit YControl "ycontrol" //平台无关的控件实现。
{
	$import $unit YWidget,
		$unit YWindow, YGUI;


	YSL_BEGIN_NAMESPACE(Components)

	YSL_BEGIN_NAMESPACE(Controls)

	//控件事件参数类型。
	struct MIndexEventArgs : public MEventArgs
	{
		typedef std::ptrdiff_t IndexType;

		IVisualControl& Control;
		IndexType Index;

		inline
		MIndexEventArgs(IVisualControl& c, IndexType i)'
	}; //struct MIndexEventArgs;


	//控件事件类型。
	typedef Runtime::GEvent<true, IControl, MEventArgs> YControlEvent;


	//事件处理器类型。
	DefDelegate(InputEventHandler, IVisualControl, Runtime::MInputEventArgs)
	DefDelegate(KeyEventHandler, IVisualControl, Runtime::MKeyEventArgs)
	DefDelegate(TouchEventHandler, IVisualControl, Runtime::MTouchEventArgs)
	DefDelegate(IndexEventHandler, IVisualControl, MIndexEventArgs)


	//可视控件事件空间。
	struct EControl
	{
		typedef enum EventSpace
		{
		//	AutoSizeChanged,
		//	BackColorChanged,
		//	ForeColorChanged,
		//	LocationChanged,
		//	MarginChanged,
		//	VisibleChanged,

		//	EnabledChanged,
		//	Resize,
		//	Move,

			GotFocus,
			LostFocus,

		//	TextChanged,
		//	FontChanged,
		//	FontColorChanged,
		} EventID;
	}; //struct EControl;


	//控件接口。
	DeclInterface(IControl)
		typedef Runtime::GEventMap<EControl> EventMapType;

		DeclIEntry(EventMapType::Event& operator[](const EventMapType::ID&))

		DeclIEntry(bool IsEnabled() const) //判断是否有效。

		DeclIEntry(void SetEnabled(bool)) //设置有效性。
	EndDecl


	//可视控件接口。
	DeclBasedInterface(IVisualControl, IControl, GIFocusRequester<IVisualControl>)
		DeclIEntry(void RequestFocus(const MEventArgs& = GetZeroElement<MEventArgs>()))
		DeclIEntry(void ReleaseFocus(const MEventArgs& = GetZeroElement<MEventArgs>()))

		DeclIEventEntry(InputEventHandler, Enter)
		DeclIEventEntry(InputEventHandler, Leave)
		DeclIEventEntry(KeyEventHandler, KeyUp)
		DeclIEventEntry(KeyEventHandler, KeyDown)
		DeclIEventEntry(KeyEventHandler, KeyHeld)
		DeclIEventEntry(KeyEventHandler, KeyPress)
		DeclIEventEntry(TouchEventHandler, TouchUp)
		DeclIEventEntry(TouchEventHandler, TouchDown)
		DeclIEventEntry(TouchEventHandler, TouchHeld)
		DeclIEventEntry(TouchEventHandler, TouchMove)
		DeclIEventEntry(TouchEventHandler, Click)
	EndDecl


	//控件模块类。
	class MControl// : implements IControl
	{
	protected:
		bool Enabled; //控件有效性。
		IControl::EventMapType EventMap; //事件映射表。

	public:
		inline explicit
		MControl(bool = true);
		virtual DefEmptyDtor(MControl)

		virtual PDefHOperator(IControl::EventMapType::Event&, [], const IControl::EventMapType::ID& id)
			ImplRet(EventMap[id])

		inline IControl::EventMapType::Event&
		operator[](const IControl::EventMapType::ID&);

		virtual DefPredicate(Enabled, Enabled)

		virtual DefSetterDe(bool, Enabled, Enabled, true)
	}; //struct MControl;


	//可视控件模块类。
	class MVisualControl : public MControl, public AFocusRequester
	{
	public:
		DefEvent(InputEventHandler, Enter)
		DefEvent(InputEventHandler, Leave)
		DefEvent(KeyEventHandler, KeyUp)
		DefEvent(KeyEventHandler, KeyDown)
		DefEvent(KeyEventHandler, KeyHeld)
		DefEvent(KeyEventHandler, KeyPress)
		DefEvent(TouchEventHandler, TouchUp)
		DefEvent(TouchEventHandler, TouchDown)
		DefEvent(TouchEventHandler, TouchHeld)
		DefEvent(TouchEventHandler, TouchMove)
		DefEvent(TouchEventHandler, Click)

	protected:
		GMFocusResponser<IVisualControl>*
		CheckFocusContainer(IWidgetContainer*); //检查给定的容器指针是否有效且指向接受焦点的容器。

	public:
		MVisualControl();

		virtual void
		OnGotFocus(const MEventArgs& = GetZeroElement<MEventArgs>());
		virtual void
		OnLostFocus(const MEventArgs& = GetZeroElement<MEventArgs>());
		virtual void
		OnKeyHeld(const Runtime::MKeyEventArgs&);
		virtual void
		OnTouchDown(const Runtime::MTouchEventArgs& = Runtime::MTouchEventArgs::Empty);
		virtual void
		OnTouchHeld(const Runtime::MTouchEventArgs&);
		virtual void
		OnTouchMove(const Runtime::MTouchEventArgs&);
	}; //class MVisualControl;


	//控件基类。
	class YControl : public GMCounter<YControl>, public YComponent, public MControl
	{
		typedef YComponent ParentType;
	}; //class YControl;


	//可视控件抽象基类。
	class AVisualControl : public Widgets::MWidget, public MVisualControl,
		implements IWidget, implements IVisualControl
	{
	public:
		explicit
		AVisualControl(HWND = NULL, const Rect& = Rect::FullScreen, IWidgetContainer* = NULL);
		~AVisualControl();

		virtual PDefH(EventMapType::Event&, operator[], const EventMapType::ID& id)
			ImplBodyBase(MVisualControl, operator[], id)

		virtual DefPredicateBase(Visible, MVisual)
		virtual DefPredicateBase(Transparent, MVisual)
		virtual DefPredicateBase(BgRedrawed, MVisual)
		virtual DefPredicateBase(Enabled, MControl)
		virtual DefPredicateBase(Focused, AFocusRequester)
		virtual PDefH(bool, IsFocusOfContainer, GMFocusResponser<IVisualControl>& c) const
			ImplBodyBase(AFocusRequester, IsFocusOfContainer, c)

		//判断包含关系。
		virtual PDefH(bool, Contains, const Point& p) const
			ImplBodyBase(MVisual, Contains, p)

		virtual PDefH(bool, CheckRemoval, GMFocusResponser<IVisualControl>& c) const
			ImplBodyBase(MVisualControl, CheckRemoval, c)

		virtual DefGetterBase(const Point&, Location, MVisual)
		virtual DefGetterBase(const Drawing::Size&, Size, MVisual)
		virtual DefGetterBase(IWidgetContainer*, ContainerPtr, MWidget)
		virtual DefGetterBase(HWND, WindowHandle, MWidget)

		virtual DefEventGetter(InputEventHandler, Enter)
		virtual DefEventGetter(InputEventHandler, Leave)
		virtual DefEventGetter(KeyEventHandler, KeyUp)
		virtual DefEventGetter(KeyEventHandler, KeyDown)
		virtual DefEventGetter(KeyEventHandler, KeyHeld)
		virtual DefEventGetter(KeyEventHandler, KeyPress)
		virtual DefEventGetter(TouchEventHandler, TouchUp)
		virtual DefEventGetter(TouchEventHandler, TouchDown)
		virtual DefEventGetter(TouchEventHandler, TouchHeld)
		virtual DefEventGetter(TouchEventHandler, TouchMove)
		virtual DefEventGetter(TouchEventHandler, Click)

		virtual DefSetterBaseDe(bool, Visible, MVisual, true)
		virtual DefSetterBaseDe(bool, Transparent, MVisual, true)
		virtual DefSetterBaseDe(bool, BgRedrawed, MVisual, true)
		virtual DefSetterBase(const Point&, Location, MVisual)
		virtual DefSetterBaseDe(bool, Enabled, MControl, true)

		virtual PDefH(void, DrawBackground)
			ImplBodyBaseVoid(MWidget, DrawBackground)
		virtual PDefH(void, DrawForeground)
			ImplBodyBaseVoid(MWidget, DrawForeground)

		virtual PDefH(void, Refresh)
			ImplBodyBaseVoid(MWidget, Refresh)

		virtual void
		RequestFocus(const MEventArgs& = GetZeroElement<MEventArgs>()); //向部件容器申请获得焦点，若成功则引发 GotFocus 事件。
		virtual void
		ReleaseFocus(const MEventArgs& = GetZeroElement<MEventArgs>()); //释放焦点，并引发 LostFocus 事件。
	}; //class AVisualControl;


	//可视控件基类。
	class YVisualControl : public YComponent, public AVisualControl
	{
	public:
		typedef YComponent ParentType;

		explicit
		YVisualControl(HWND = NULL, const Rect& = Rect::FullScreen, IWidgetContainer* = NULL);
		~YVisualControl();

		virtual void
		RequestToTop()
		{}
	}; //class YVisualControl;


	//按钮模块。
	class MButton
	{
	protected:
		bool bPressed;

		explicit
		MButton(bool = false);

	public:
		DefPredicate(Pressed, bPressed)
	}; //class MButton;


	//滚动条模块。
	class MScrollBar
	{
	protected:
		SDST MaxThumbSize, PrevButtonSize, NextButtonSize;
		bool bPrevButtonPressed, bNextButtonPressed;

		explicit
		MScrollBar(SDST = 10, SDST = 10, SDST = 10);

	public:
		DefGetter(SDST, MaxThumbSize, MaxThumbSize)
		DefGetter(SDST, PrevButtonSize, PrevButtonSize)
		DefGetter(SDST, NextButtonSize, NextButtonSize)
	}; //class MScrollBar;


	//滚动条。
	class AScrollBar : public AVisualControl, public MScrollBar
	{
		DefGetter(SDST, ScrollAreaLength, GetWidth() - PrevButtonLength - NextButtonLength)
		DefGetter(SDST, ScrollAreaFixedLength, GetScrollAreaLength() - MaxScrollBlockLength)

		DeclIEntry(void DrawPrevButton())
		DeclIEntry(void DrawNextButton())
		DeclIEntry(void DrawScrollArea())
		virtual void
		DrawForeground();
	}; //class AScrollBar;

	YSL_END_NAMESPACE(Controls)

	YSL_END_NAMESPACE(Components)

} //$unit YControl;


$unit YGUIComponent "yguicomp" //样式相关图形用户界面组件实现。
{
	$import $unit YWidget,
		$unit YWindow, YGUI;


	YSL_BEGIN_NAMESPACE(Components)

	YSL_BEGIN_NAMESPACE(Widgets)

	YSL_BEGIN_NAMESPACE(Widgets)

	YSL_BEGIN_NAMESPACE(Controls)

	//按钮。
	class YButton : public GMCounter<YButton>, public YVisualControl, public MButton, public Widgets::MLabel
	{
	public:
		typedef YVisualControl ParentType;

	/*
		YImage BackgroundImage; //背景图像。
		YImage Image; //前景图像。
	*/

		//用字符串在窗口中以给定字号初始化标签。
		template<class _tChar>
		YButton(HWND, const _tChar*, const Rect& = Rect::FullScreen,
		const Drawing::Font& = Drawing::Font::GetDefault(), IWidgetContainer* = NULL, GHResource<Drawing::TextRegion> = NULL);

	protected:
		void
		_m_init();

	public:
		virtual void
		DrawForeground();

		virtual void
		OnEnter(const Runtime::MInputEventArgs&);
		virtual void
		OnLeave(const Runtime::MInputEventArgs&);
		virtual void
		OnKeyDown(const Runtime::MKeyEventArgs&);
		virtual void
		OnClick(const Runtime::MTouchEventArgs&);
	}; //class YButton;


	//水平滚动条。
	class YHorizontalScrollBar : public AScrollBar
	{
		explicit
		YHorizontalScrollBar(SDST = 8, SDST = 10, SDST = 10);

		void
		DrawPrevButton();
		void
		DrawNextButton();
		void
		DrawScrollArea();
	}; //class YHorizontalScrollBar;


	//垂直滚动条。
	class YVerticalScrollBar
	{

	}; //class YVerticalScrollBar;


	//文本列表框。
	class YListBox : public GMCounter<YListBox>, public YVisualControl
	{
	public:
		typedef YVisualControl ParentType;
		typedef String ItemType; //项目类型：字符串。
		typedef vector<ItemType> ListType; //列表类型。
		typedef GSequenceViewer<ListType> ViewerType; //视图类型。

	protected:
		static const SDST defMarginH = 4, defMarginV = 2;

		GHResource<Drawing::TextRegion> prTextRegion; //文本区域指针。
		const bool bDisposeList;

	public:
		Drawing::Font Font; //字体。
		Drawing::Padding Margin; //文本和容器的间距。
		ListType& List; //列表。

	protected:
		GSequenceViewer<ListType> Viewer; //列表视图。

	public:
		DefEvent(IndexEventHandler, Selected) //项目选择状态改变事件。
		DefEvent(IndexEventHandler, Confirmed) //项目选中确定事件。

		YListBox(HWND, const Rect& = Rect::Empty, IWidgetContainer* = NULL, GHResource<Drawing::TextRegion> = NULL);
		YListBox(HWND, const Rect& = Rect::Empty, IWidgetContainer* = NULL, GHResource<Drawing::TextRegion> = NULL, ListType& List_ = *GetGlobalResource<ListType>()); //外源列表。
		virtual
		~YListBox();

	protected:
		void
		_m_init();

	public:
		DefPredicateMember(Selected, Viewer)

		DefGetter(ListType&, List, List)
		DefGetterMember(ViewerType::IndexType, Index, Viewer)
		DefGetterMember(ViewerType::IndexType, Selected, Viewer)
		ItemType*
		GetItemPtr(ViewerType::IndexType);
		SDST
		GetItemHeight() const;

	//	DefSetter(const ListType&, List, List)
		void
		SetSelected(ViewerType::IndexType);
		void
		SetSelected(SPOS, SPOS);
		inline void
		SetSelected(const Point&);

	public:
		virtual void
		DrawBackground();
		virtual void
		DrawForeground();

	protected:
		ViewerType::IndexType
		CheckPoint(SPOS, SPOS); //检查相对于所在缓冲区的控件坐标是否在选择范围内，返回选择的项目索引。

	public:
		PDefH(void, ClearSelected)
			ImplBodyMemberVoid(Viewer, ClearSelected)

	private:
		void
		CallSelected();
		void
		CallConfirmed();

	public:
		virtual void
		OnKeyDown(const Runtime::MKeyEventArgs&);
		virtual void
		OnTouchDown(const Runtime::MTouchEventArgs&);
		virtual void
		OnClick(const Runtime::MTouchEventArgs&);
		virtual void
		OnSelected(const MIndexEventArgs&);
		virtual void
		OnConfirmed(const MIndexEventArgs&);
	}; //class YListBox;


	//文件列表框。
	class YFileBox : public GMCounter<YFileBox>, public YListBox, public IO::MFileList
	{
	public:
		typedef YListBox ParentType;
		typedef ParentType::ListType ListType;

		ListType& List;

		YFileBox(HWND, const Rect& = Rect::Empty, IWidgetContainer* = NULL, GHResource<Drawing::TextRegion> = NULL);
		virtual
		~YFileBox();

		IO::Path
		GetPath() const;

		virtual void
		DrawBackground();
		virtual void
		DrawForeground();

		virtual void
		OnTouchMove(const Runtime::MTouchEventArgs&);
		virtual void
		OnConfirmed(const MIndexEventArgs&);
	}; //class YFileBox;

	YSL_END_NAMESPACE(Controls)

	YSL_END_NAMESPACE(Components)

} //$unit YGUIComponent;


$unit YWindow "ywindow" //平台无关的图形用户界面窗口实现。
{
	$import $unit YWidget, $unit YControl,
		$unit YDesktop;


	YSL_BEGIN_NAMESPACE(Components)

	YSL_BEGIN_NAMESPACE(Forms)

	//窗口接口。
	DeclBasedInterface(IWindow, IWidgetContainer, IVisualControl)
		DeclIEntry(operator GraphicInterfaceContext() const) //生成图形接口上下文。

		DeclIEntry(bool IsRefreshRequired() const)
		DeclIEntry(bool IsUpdateRequired() const)

		DeclIEntry(YDesktop* GetDesktopPtr() const)
		DeclIEntry(IVisualControl* GetFocusingPtr() const)
		DeclIEntry(const Drawing::MBitmapBuffer& GetBuffer() const) //取显示缓冲区。
		DeclIEntry(BitmapPtr GetBufferPtr() const) //取缓冲区指针。

		DeclIEntry(void SetRefresh(bool = true))
		DeclIEntry(void SetUpdate(bool = true))

		DeclIEntry(void Draw())

		DeclIEntry(void Update()) //按需更新（以父窗口、屏幕优先顺序）。
	EndDecl


	//桌面对象模块。
	class MDesktopObject
	{
	protected:
		YDesktop* pDesktop; //桌面指针。

	public:
		inline explicit
		MDesktopObject(YDesktop*);

	protected:
		DefEmptyDtor(MDesktopObject);

	public:
		//判断从属关系。
		PDefH(bool, BelongsTo, YDesktop* pDsk) const
			ImplRet(pDesktop == pDsk)

		DefGetter(YDesktop*, DesktopPtr, pDesktop)
	}; //class MDesktopObject;


	//窗口模块。
	class MWindow : public Controls::MVisualControl, public MDesktopObject
	{
	protected:
		Drawing::MBitmapBuffer Buffer; //显示缓冲区。
		//基类中的 hWindow 为父窗口对象句柄，若为空则说明无父窗口。
		HSHL hShell;
		GHResource<YImage> prBackImage; //背景图像指针。
		bool bRefresh; //刷新属性：表示有新的绘制请求。
		bool bUpdate; //更新属性：表示绘制结束，缓冲区准备完毕。

	public:
		explicit
		MWindow(const GHResource<YImage> = new YImage(), YDesktop* = ::YSLib::pDefaultDesktop, HSHL = ::YSLib::theApp.GetShellHandle());

		DefPredicate(RefreshRequired, bRefresh)
		DefPredicate(UpdateRequired, bUpdate)

		DefGetter(HSHL, ShellHandle, hShell)
		DefGetter(GHResource<YImage>, Background, prBackImage)

		DefSetterDe(GHResource<YImage>, Background, prBackImage, NULL)
	}; //class MWindow;


	//抽象窗口。
	class AWindow : public Widgets::MWidget, public MWindow,
		implements IWindow
	{
	public:
		explicit
		AWindow(const Rect& = Rect::Empty, const GHResource<YImage> = new YImage(),
			YDesktop* = ::YSLib::pDefaultDesktop, HSHL = ::YSLib::theApp.GetShellHandle(), HWND = NULL);
		virtual DefEmptyDtor(AWindow)

		virtual PDefHOperator(EventMapType::Event&, [], const EventMapType::ID& id)
			ImplBodyBase(MVisualControl, operator[], id)

		virtual DefConverterMember(GraphicInterfaceContext, Buffer)

		virtual DefPredicateBase(Visible, MVisual)
		virtual DefPredicateBase(Transparent, MVisual)
		virtual DefPredicateBase(BgRedrawed, MVisual)
		virtual DefPredicateBase(Enabled, MVisualControl)
		virtual DefPredicateBase(Focused, AFocusRequester)
		virtual PDefH(bool, IsFocusOfContainer, GMFocusResponser<IVisualControl>& c) const
			ImplBodyBase(AFocusRequester, IsFocusOfContainer, c)
		virtual DefPredicateBase(RefreshRequired, MWindow)
		virtual DefPredicateBase(UpdateRequired, MWindow)

		//判断从属关系。
		PDefH(bool, BelongsTo, HSHL h) const
			ImplRet(hShell == h)
		PDefH(bool, BelongsTo, YDesktop* pDsk) const
			ImplBodyBase(MDesktopObject, BelongsTo, pDsk)

		//判断包含关系。
		virtual PDefH(bool, Contains, const Point& p) const
			ImplBodyBase(MVisual, Contains, p)

		virtual PDefH(bool, CheckRemoval, GMFocusResponser<IVisualControl>& c) const
			ImplBodyBase(MVisualControl, CheckRemoval, c)

		virtual DefGetterBase(const Point&, Location, MVisual)
		virtual DefGetterBase(const Drawing::Size&, Size, MVisual)
		virtual DefGetterBase(IWidgetContainer*, ContainerPtr, MWidget)
		virtual DefGetterBase(HWND, WindowHandle, MWidget)
		virtual DefGetterBase(YDesktop*, DesktopPtr, MDesktopObject)
		virtual DefGetter(const Drawing::MBitmapBuffer&, Buffer, Buffer)
		virtual DefGetterMember(BitmapPtr, BufferPtr, Buffer)
		DefGetter(HWND, Handle, HWND(const_cast<AWindow*>(this)))
		DefGetterBase(HSHL, ShellHandle, MWindow)
		DefGetterBase(GHResource<YImage>, Background, MWindow)
		BitmapPtr
		GetBackgroundPtr() const;

		virtual DefEventGetter(Controls::InputEventHandler, Enter)
		virtual DefEventGetter(Controls::InputEventHandler, Leave)
		virtual DefEventGetter(Controls::KeyEventHandler, KeyUp)
		virtual DefEventGetter(Controls::KeyEventHandler, KeyDown)
		virtual DefEventGetter(Controls::KeyEventHandler, KeyHeld)
		virtual DefEventGetter(Controls::KeyEventHandler, KeyPress)
		virtual DefEventGetter(Controls::TouchEventHandler, TouchUp)
		virtual DefEventGetter(Controls::TouchEventHandler, TouchDown)
		virtual DefEventGetter(Controls::TouchEventHandler, TouchHeld)
		virtual DefEventGetter(Controls::TouchEventHandler, TouchMove)
		virtual DefEventGetter(Controls::TouchEventHandler, Click)

		virtual DefSetterBaseDe(bool, Visible, MVisual, true)
		virtual DefSetterBaseDe(bool, Transparent, MVisual, true)
		virtual DefSetterBaseDe(bool, BgRedrawed, MVisual, true)
		virtual DefSetterBase(const Point&, Location, MVisual)
		virtual DefSetterDe(bool, Refresh, bRefresh, true)
		virtual DefSetterDe(bool, Update, bUpdate, true)
		virtual void
		SetSize(SDST, SDST);
		virtual void
		SetBounds(const Rect&);
		virtual DefSetterBaseDe(bool, Enabled, MVisualControl, true)
		virtual DefSetterBaseDe(GHResource<YImage>, Background, MWindow, NULL)

		PDefH(void, ClearBackground) const //清除背景。
			ImplExpr(Buffer.ClearImage())

	public:
		virtual void
		Fill(PixelType); //以纯色填充显示缓冲区。
		bool
		DrawBackgroundImage();
		virtual void
		DrawBackground();
		virtual void
		DrawForeground();
		DeclIEntry(bool DrawWidgets())
		virtual void
		Draw();

		virtual void
		Refresh();
		virtual void
		Update();

	private:
		virtual PDefH(bool, ReleaseFocus, GMFocusResponser<IVisualControl>& c)
			ImplBodyBase(MVisualControl, ReleaseFocus, c)

	public:
		virtual void
		RequestFocus(const MEventArgs& = GetZeroElement<MEventArgs>()); //向部件容器申请获得焦点。
		virtual void
		ReleaseFocus(const MEventArgs& = GetZeroElement<MEventArgs>()); //释放焦点。
		virtual void
		RequestToTop();

		inline virtual void
		UpdateToScreen() const; //更新至屏幕。
		inline virtual void
		UpdateToWindow() const; //更新至上层窗口缓冲区。
		void
		UpdateToScreen(YDesktop&) const; //更新至指定桌面所在的屏幕。
		void
		UpdateToWindow(IWindow&) const; //更新至指定窗口缓冲区。
		void
		Show();

		static void
		OnGotFocus(IControl&, const MEventArgs& = GetZeroElement<MEventArgs>());
		static void
		OnLostFocus(IControl&, const MEventArgs& = GetZeroElement<MEventArgs>());
	}; //class AWindow;


	//框架窗口。
	class YFrameWindow : public GMCounter<YFrameWindow>, public YComponent, public AWindow, public Widgets::MWidgetContainer
	{
	public:
		typedef YComponent ParentType;

		explicit
		YFrameWindow(const Rect& = Rect::Empty, const GHResource<YImage> = new YImage(),
			YDesktop* = ::YSLib::pDefaultDesktop, HSHL = ::YSLib::theApp.GetShellHandle(), HWND = NULL);
		virtual
		~YFrameWindow();

		virtual PDefHOperator(void, +=, IWidget& w)
			ImplExpr(sWgtSet += w)
		virtual PDefHOperator(bool, -=, IWidget& w)
			ImplRet(sWgtSet -= w)
		virtual PDefHOperator(void, +=, IVisualControl& c)
			ImplBodyBaseVoid(MWidgetContainer, operator+=, c)
		virtual PDefHOperator(bool, -=, IVisualControl& c)
			ImplBodyBase(MWidgetContainer, operator-=, c)
		virtual PDefHOperator(void, +=, GMFocusResponser<IVisualControl>& c)
			ImplBodyBaseVoid(MWidgetContainer, operator+=, c)
		virtual PDefHOperator(bool, -=, GMFocusResponser<IVisualControl>& c)
			ImplBodyBase(MWidgetContainer, operator-=, c)

		virtual PDefH(IWidget*, GetTopWidgetPtr, const Point& p) const
			ImplBodyBase(MWidgetContainer, GetTopWidgetPtr, p)
		virtual PDefH(IVisualControl*, GetTopVisualControlPtr, const Point& p) const
			ImplBodyBase(MWidgetContainer, GetTopVisualControlPtr, p)
		virtual Point
		GetContainerLocationOffset(const Point& = Point::Zero) const;
		virtual Point
		GetWindowLocationOffset(const Point& = Point::Zero) const;
		virtual DefGetterBase(IVisualControl*, FocusingPtr, GMFocusResponser<IVisualControl>)

		virtual PDefH(void, ClearFocusingPtr)
			ImplBodyBaseVoid(MWidgetContainer, ClearFocusingPtr)

		virtual bool
		DrawWidgets();
	}; //class YFrameWindow;

	YSL_END_NAMESPACE(Forms)

	YSL_END_NAMESPACE(Components)

} //$unit YWindow;


$unit YForm "yform" //平台无关的图形用户界面窗体实现。
{
	$import $unit YWindow, YControl;


	YSL_BEGIN_NAMESPACE(Components)

	YSL_BEGIN_NAMESPACE(Forms)

	//窗体。
	class YForm : public GMCounter<YForm>, public YFrameWindow
	{
	public:
		typedef YFrameWindow ParentType;

	//	Widgets::YWidgetContainer Client;

	public:
		explicit
			YForm(const Rect& = Rect::Zero, const GHResource<YImage> = new YImage(),
			YDesktop* = ::YSLib::pDefaultDesktop, HSHL = ::YSLib::theApp.GetShellHandle(), HWND = NULL);
		virtual
		~YForm();

		HWND GetHandle();

		virtual void
		SetSize(SDST, SDST);
		virtual void
		SetBounds(const Rect&);

		virtual void
		DrawBackground();
		virtual void
		DrawForeground();
		virtual void
		Draw();
	}; //class YForm;

	YSL_END_NAMESPACE(Forms)

	YSL_END_NAMESPACE(Components)

} //$unit YForm;


$unit YText "ytext" //基础文本显示。
{
	$import $unit Core::YString, YFile_(Text), YGDI, $header <cwctype>;


	YSL_BEGIN_NAMESPACE(Drawing)

	$export const u8 Alpha_Threshold;

	class TextState : public PenStyle //文本状态：笔样式、边框样式、字体缓存和行距。
	{
	public:
		typedef PenStyle ParentType;

		Padding Margin; //显示区域到边框的距离。

	protected:
		YFontCache* pCache; //字体缓存。
		SPOS penX, penY; //笔坐标。
		u8 lnGap; //行距。

	public:
		TextState();
		explicit
		TextState(Drawing::Font&);
		explicit
		TextState(YFontCache&);

		inline TextState&
		operator=(const PenStyle& ps); //从 ts 中恢复样式。
		inline TextState&
		operator=(const Padding& ms); //从 ms 中恢复样式。

		DefGetter(SPOS, PenX, penX)
		DefGetter(SPOS, PenY, penY)
		DefGetter(u8, LineGap, lnGap) //取当前字体设置对应的行距。
		SDST
		GetLnHeight() const; //取当前字体设置对应的行高。
		SDST
		GetLnHeightEx() const; //取当前字体设置对应的行高与行距之和。
		u16
		GetLnNNow() const; //取笔所在的当前行数。

	//	Typeface*
	//	SetFont(CPATH); //设置字体。
		inline void
		SetPen(); //按字体大小在设置笔的默认位置（区域左上角）。
		DefSetter(SPOS, PenX, penX)
		DefSetter(SPOS, PenY, penY)
		inline void
		SetPen(SPOS, SPOS); //设置笔位置。
		inline void
		SetMargins(u64); //设置边距（64 位无符号整数形式）。
		inline void
		SetMargins(SDST, SDST); //设置边距（2 个 16 位无符号整数形式，分别表示水平边距和竖直边距）。
		inline void
		SetMargins(SDST, SDST, SDST, SDST); //设置边距（4 个 16 位无符号整数形式）。
		DefSetter(u8, LineGap, lnGap) //设置行距。
		void
		SetLnNNow(u16); //设置笔的行位置。
	}; //class TextState;


	//打印单个字符。
	void
	PrintChar(MBitmapBuffer&, TextState&, fchar_t); 
	void
	PrintCharEx(MBitmapBufferEx&, TextState&, fchar_t);


	class TextRegion : public TextState, public MBitmapBufferEx //文本区域。
	{
	public:
		typedef TextState ParentType;

		TextRegion();
		explicit
		TextRegion(Drawing::Font&);
		explicit
		TextRegion(YFontCache&);
		~TextRegion();

		inline TextRegion&
		operator=(const TextState& ts); //从 ts 中恢复状态。

		DefGetter(SDST, BufWidthN, Width - Margin.GetHorizontal()) //取缓冲区的文本显示区域的宽。
		DefGetter(SDST, BufHeightN, Height - Margin.GetVertical()) //取缓冲区的文本显示区域的高。
		SDST
		GetMarginResized() const; //根据字体大小、行距和缓冲区的高调整边距，返回调整后的底边距值。
		SDST
		GetBufferHeightResized() const; //取根据字体大小和行距调整后的缓冲区的高（不含底边距）。
		u16
		GetLnN() const; //取按当前行高和行距所能显示的最大行数。
		u16
		GetLnNEx() const; //取按当前行高和行距（行间距数小于行数 1）所能显示的最大行数。
		SPOS
		GetLineLast() const; //取最底行的基线位置。

		void
		SetLnLast(); //设置笔的行位置为最底行。

		void
		ClearLine(u16 l, SDST n); //清除缓冲区第 l 行起始的 n 行像素（n 为 0 时清除之后的所有行）。
		void
		ClearLn(u16 l); //清除缓冲区第 l 个文本行。
		void
		ClearLnLast(); //清除缓冲区最后一个文本行。

		void
		Move(s16 n); //缓冲区（除上下边界区域）特效：整体移动 n 像素（n > 0 时下移， n < 0 时上移）。
		void
		Move(s16 n, SDST h); //缓冲区（从缓冲区顶端起高 h 的区域内，除上下边界区域）特效：整体移动 n 像素（n > 0 时下移， n < 0 时上移）。

		void
		PutNewline(); //输出换行。
		u8
		PutChar(fchar_t); //输出单个字符。

		template<typename _tOut>
		_tOut
		PutLine(_tOut s); //输出迭代器 s 指向字符串，直至行尾或字符串结束，并返回输出迭代器。
		template<typename _tOut, typename _tChar>
		_tOut
		PutLine(_tOut s, _tOut g, _tChar f = '\0'); //输出迭代器 s 指向字符串，直至行尾、遇到指定迭代器 g 或遇到指定字符 f ，并返回输出迭代器。
		inline String::size_type
		PutLine(const String&); //输出字符串，直至行尾或字符串结束，并返回输出字符数。

		template<typename _tOut>
		_tOut
		PutString(_tOut s); //输出迭代器 s 指向字符串，直至区域末尾或字符串结束，并返回输出迭代器。
		template<typename _tOut, typename _tChar>
		_tOut
		PutString(_tOut s, _tOut g , _tChar f = '\0'); //输出迭代器 s 指向字符串，直至区域末尾、遇到指定迭代器 g 或遇到指定字符 f ，并返回输出迭代器。
		inline String::size_type
		PutString(const String&); //输出字符串，直至区域末尾或字符串结束，并返回输出字符数。
	}; //class TextRegion;

	YSL_END_NAMESPACE(Drawing)

	YSL_BEGIN_NAMESPACE(Text)

	//以 cache 为字体缓存，width 为宽度，从当前文本迭代器 p （不含）开始逆向查找字符 f （满足 p != --g ）。
	template<typename _tOut, typename _tChar>
	_tOut
	rfind(YFontCache& cache, SDST width, _tOut p, _tOut g, _tChar f);

	//在 r 中取当前文本迭代器 p 的前 l 行首对应文本迭代器（满足 p != --g ）。
	template<typename _tOut>
	_tOut
	GetPreviousLinePtr(const Drawing::TextRegion& r, _tOut p, _tOut g, u16 l = 1)

	//在 r 中取当前文本迭代器 p 至后一行首对应文本迭代器（满足 p != g ）。
	template<typename _tOut>
	_tOut
	GetNextLinePtr(const Drawing::TextRegion& r, _tOut p, _tOut g);


	u32
	ReadX(YTextFile& f, Drawing::TextRegion& txtbox, u32 n); //无文本缓冲方式从文本文件 f 中读取 n 字节（按默认编码转化为 UTF-16LE）到 txtbox 中。

	YSL_END_NAMESPACE(Text)

} //$unit YText;

} //Code YSLib::Shell;


$code YSLib::Service {

$unit YSystemUtilities "ysutil" //系统实用模块。
{
	$import $unit Core::YShellDefinition;


} //$unit YSystemUtilities;


$unit YShellInitialization "ysinit" //程序启动时的通用初始化代码段。
{
	$import $unit Core::YShellDefinition, Adaptor::Font;
	$import extern CPATH DEF_FONT_PATH, DEF_FONT_DIRECTORY;


	//初始化主控制台。
	void
	InitYSConsole();


	//默认字型路径和目录。
	extern CPATH DEF_FONT_PATH;
	extern CPATH DEF_FONT_DIRECTORY;

	//初始化系统字体缓存：以默认字型路径创建默认字体缓存并加载默认字型目录中的字体文件。
	void
	InitializeSystemFontCache()

	//注销系统字体缓存。
	inline void
	DestroySystemFontCache();

	void
	EpicFail();

	void
	LibfatFail();

	void
	CheckInstall();

	void
	CheckSystemFontCache();

} //$unit YShellInitialization;


$unit YTextManager "ytmgr" //平台无关的基础文本管理服务。
{
	$import $unit Core::YString, YFile_(Text),
		Core::YApplication;


	YSL_BEGIN_NAMESPACE(Text)


	//文本缓冲区。
	class TextBuffer : private NonCopyable;
	{
	private:
		const SizeType capacity; //最大长度（字符数）。

	protected:
		//文本缓冲区的首地址和长度。
		uchar_t* const text;
		SizeType len;

		explicit
		TextBuffer(SizeType tlen);
		inline
		~TextBuffer();

	public:
		uchar_t&
		operator[](SizeType) ythrow(); //按下标返回字符，无运行期范围检查。

		DefGetter(SizeType, MaxLength, capacity) //取最大文本长度。
		DefGetter(SizeType, SizeOfBuffer, sizeof(uchar_t) * capacity) //取文本缓冲区的大小。
		DefGetter(uchar_t*, Ptr, text) //取文本缓冲区的指针。
		DefGetter(SizeType, Length, len) //取文本缓冲区的长度。
		SizeType
		GetPrevChar(SizeType o, uchar_t c); //从文本缓冲区下标 o （不含）起逆序查找字符 c 。返回结果的直接后继下标；查找失败时返回 0 。
		SizeType
		GetNextChar(SizeType o, uchar_t c); //从文本缓冲区下标 o （含）起顺序查找字符 c 。返回结果的下标；查找失败时返回缓冲区长度（o 原值小于缓冲区长度）或 o 原值（大于等于缓冲区长度时）。
		inline SizeType
		GetPrevNewline(SizeType o); //从文本缓冲区下标 o （不含）起逆序查找换行符。返回结果的直接后继下标；查找失败时返回 0 。
		inline SizeType
		GetNextNewline(SizeType o); //从文本缓冲区下标 o （含）起顺序查找字符 c 。返回结果的下标；查找失败时返回缓冲区长度（o 原值小于缓冲区长度）或 o 原值（大于等于缓冲区长度时）。

		uchar_t&
		at(SizeType) ythrow(std::out_of_range); //按下标返回字符，当越界时抛出 std::out_of_range 。

		inline void
		ClearText(); //清空缓冲区。

		inline bool
		Load(const uchar_t* s); //从起始地址 s 中读取连续的 capacity 个 uchar_t 字符。
		bool
		Load(const uchar_t* s, SizeType n); //从起始地址 s 中读取连续的 n 个（超过最大长度则放弃读取）uchar_t 字符。
		inline u32
		Load(YTextFile& f); //从文本文件 f 中读取连续的 capacity 个字符（自动校验换行并转换为 Unix / Linux 格式），并返回成功读取的字符数。
		SizeType
		Load(YTextFile& f, SizeType n); //从文本文件 f 中读取连续的 n 个（超过最大长度则放弃读取）uchar_t字符（自动校验换行并转换为 Unix / Linux 格式），并返回成功读取的字符数。

		SizeType
		LoadN(YTextFile& f, SizeType n); //从文本文件 f 中读取连续的 n 个字节，并返回成功读取的字符数。

		bool
		Output(uchar_t* d, SizeType p, SizeType n) const; //从偏移 p 个字符起输出 n 个 uchar_t 字符到 d 。

	}; //class TextBuffer;


	//文本缓冲块。
	class TextBlock : public TextBuffer
	{
	public:
		typedef u16 BlockSizeType;
		typedef TextBuffer::SizeType SizeType;

		SizeType Index;

		inline
		TextBlock(BlockSizeType, SizeType);
		inline virtual
		~TextBlock();
	}; //class TextBlock;


	//文本缓冲块映射。
	class TextMap
	{
	public:
		typedef TextBlock::BlockSizeType BlockSizeType;
		typedef map<BlockSizeType, TextBlock*> MapType;

	protected:
		MapType Map;

	public:
		inline virtual
		~TextMap();

		inline TextBlock*
		operator[](const BlockSizeType&);
		inline void
		operator+=(const TextBlock&);
		inline void
		operator-=(const BlockSizeType&);

		void
		clear();
	}; //class YTextMap;


	//文本文件块缓冲区。
	class TextFileBuffer : public TextMap
	{
	public:
		typedef TextMap::BlockSizeType BlockSizeType; //块索引类型。

		static const SizeType nBlockSize = 0x2000; //文本块容量。

		//只读文本循环迭代器类。
		class HText
		{
			friend class TextFileBuffer;

		public:
			typedef TextFileBuffer ContainerType;
			typedef ContainerType::BlockSizeType BlockSizeType;

		private:
			TextFileBuffer* pBuffer;
			//文本读取位置。
			BlockSizeType blk;
			SizeType idx;

		public:
			HText(TextFileBuffer* = NULL, BlockSizeType = 0, SizeType = 0) ythrow(); //指定文本读取位置初始化。

			HText&
			operator++() ythrow();

			HText&
			operator--() ythrow();

			uchar_t
			operator*() ythrow();

			HText
			operator+(std::ptrdiff_t);

			HText
			operator-(std::ptrdiff_t);

			friend bool
			operator==(const HText&, const HText&) ythrow();

			inline friend bool
			operator!=(const HText&, const HText&) ythrow();

			friend bool
			operator<(const HText&, const HText&) ythrow();

			inline friend bool
			operator>(const HText&, const HText&) ythrow();

			inline friend bool
			operator<=(const HText&, const HText&) ythrow();

			inline friend bool
			operator>=(const HText&, const HText&) ythrow();

			HText&
			operator+=(std::ptrdiff_t);

			HText&
			operator-=(std::ptrdiff_t);

			DefGetter(TextFileBuffer*, BufferPtr, pBuffer)
			DefGetter(BlockSizeType, BlockN, blk)
			DefGetter(SizeType, IndexN, idx)
			const uchar_t*
			GetTextPtr() const ythrow();
			IndexType
			GetBlockLength() const ythrow();
			IndexType
			GetBlockLength(BlockSizeType) const ythrow();
		}; //class HText;

		YTextFile& File; //文本文件。

	private:
		SizeType nTextSize; //文本区段长度。
		HText it; //文本迭代器。

	public:
		explicit
		TextFileBuffer(YTextFile&);

		TextBlock&
		operator[](const BlockSizeType&);

		DefGetter(SizeType, TextSize, nTextSize)

		HText
		begin() ythrow();

		HText
		end() ythrow();	
	}; //class TextFileBuffer;

	YSL_END_NAMESPACE(Text)

} //$unit YTextManager;


$unit YTimer "ytimer" //平台无关的计时器服务。
{
	$import $unit Core::YObject, $header Adaptor::Container;


	YSL_BEGIN_NAMESPACE(Timers)

	typedef u32 TimeSpan;

	//计时器。
	class YTimer : public YCountableObject
	{
	private:
		typedef map<u32, YTimer*> TMRs; //计时器组。

		static bool NotInitialized;
		static vu32 SystemTick;
		static TMRs Timers;

		TimeSpan nInterval;
		TimeSpan nBase;

	public:
		explicit
		YTimer(TimeSpan = 1000, bool = true);

		DefStaticGetter(TimeSpan, SystemTick, S_Timer)
		DefGetter(TimeSpan, Interval, nInterval)
		DefGetter(TimeSpan, BaseTick, nBase)

		inline void
		SetInterval(TimeSpan);

	private:
		static void
		InitializeSystemTimer();
		static void
		ResetSystemTimer();
		static void
		Synchronize();

		bool
		RefreshRaw();

	public:
		bool
		Refresh();
		static bool
		RefreshAll();

		void
		Activate();
		void
		Deactivate();
		inline void
		Reset();
		static void
		ResetAll();
		static void
		ResetYTimer();
	}; //class YTimer;

	YSL_END_NAMESPACE(Timers)

} //$unit YTimer;

} //$code YSLib::Service;


$code Helper {

$export $unit YGlobal "yglobal" //全局对象和函数定义。
{
	$import $header YSBuild, <exception>,
		$unit Core::YShellMessage, YException;


	//全局常量。
	$export #define MAX_FILENAME_LENGTH
	$export #define MAX_PATH_LENGTH
	$export #define DEF_SHELL_FONTSIZE;
	$export #define DEF_SHELL_FONTSIZE_MIN;
	$export #define DEF_SHELL_FONTSIZE_MAX;
	const SDST SCRW(SCREEN_WIDTH), SCRH(SCREEN_HEIGHT);

	$export const char DEF_PATH_DELIMITER; //文件路径分隔符。
	$export const char* const DEF_PATH_SEPERATOR; //文件路径分隔字符串。
	$export #define DEF_PATH_ROOT DEF_PATH_SEPERATOR

	//全局变量。
	$export YScreen *pScreenUp, *pScreenDown;
	$export YDesktop *pDesktopUp, *pDesktopDown;
	$export YLog DefaultLog;

	//类型定义。
	typedef char PATHSTR[MAX_PATH_LENGTH];
	typedef char FILENAMESTR[MAX_FILENAME_LENGTH];

	//全局变量映射。
	YDesktop*& pDefaultDesktop(pDesktopUp);
	YApplication& theApp(YApplication::GetApp());
	YFontCache*& pDefaultFontCache(theApp.pFontCache);
	YApplication* const pApp(&theApp);
	const HSHL hShellMain(new YShellMain); //取主 Shell 句柄。


	struct Def
	{
		static void
		Idle(); //默认消息发生函数。

		static void
		InitVideo(); //初始化屏幕。
		static void
		InitScreenAll(); //默认屏幕初始化函数。
		static void
		InitScrUp(); //默认上屏初始化函数。
		static void
		InitScrDown(); //默认下屏初始化函数。
		static bool
		InitConsole(YScreen&, Drawing::PixelType, Drawing::PixelType); //以指定前景色和背景色初始化指定屏幕的控制台。

		static void
		Destroy(YObject&, const MEventArgs&); //资源释放函数。

		static LRES
		ShlProc(HSHL, const Message&); //公共消息处理函数。
	}; //struct Def;

	//全局函数。

	YSL_BEGIN_SHELL(YSL_SHLMAIN_NAME)

	LRES
	YSL_SHLMAIN_SHLPROC(const Message&);

	YSL_END_SHELL(YSL_SHLMAIN_NAME)


	//默认 Shell 消息处理函数。
	inline LRES
	DefaultMainShlProc(const Message& msg);

} //$unit YGlobal;

} //$code YSLib::Helper;


// std 命名空间扩展。
namespace std
{
	$unit YString;
} //namespace std;

//命名空间单元分布。

namespace Components
{
	$unit Shell::YComponents;
	$unit Shell::YDesktop;
	namespace Controls
	{
		$unit Shell::Controls;
	} //namespace Controls;
	namespace Forms
	{
		$unit Shell::YWindow;
		$unit Shell::YForm;
	} //namespace Forms;
	namespace Widgets
	{
		$unit Shell::YWidgets;
	} //namespace Widgets;
}

namespace Design
{
	$unit Core::YCoreUtilities;
	namespace Policies
	{
		namespace Operations
		{
			$header Adaptor::Reference;
		} //namespace Operations;
	} //namespace Policies;
} //namespace Design;

namespace Device
{
	$unit Core::YGraphicDevice;
} //namespace Device;

namespace Drawing
{
	$unit Adaptor::Font;
	$unit Core::YObject;
	$unit Core::YResourse;
} //namespace Drawing;

namespace IO
{
	$unit Core::YFile;
} //namespace IO;

namespace Runtime
{
	$header Core::YEvent;
	$unit Shell::Control;
	$unit Shell::YGUI;
} //namespace Runtime;

namespace Shells
{
	$unit Core::YShell;
	$unit Core::YShellMessage;
	$unit Core::YShellMessageMapping;
	$unit Core::YShellProcessing;
} //namespace Shells;

namespace Timers
{
	$unit Service::YTimer;
} //namespace Timers;

namespace Text
{
	$unit Core::YString;
	$unit Service::YTextManager;
} //namespace Text;

// std 命名空间兼容性污染列表。

$header <platform.h>
{
	typedef ::uint16_t char16_t;
	typedef ::uint32_t char32_t;
} //$header <platfrom.h>

//既定 stdex 命名空间污染列表。

$header YAdaptor
{
	using CHRLib::uchar_t;
	using CHRLib::uint_t;
} //$header YAdaptor;

//既定内部命名空间污染列表。

$header Adaptor::YAdaptor
{
	namespace Text
	{
		using namespace CHRLib;
	} //namespace Text;
	using Text::fchar_t, Text::uchar_t, Text::uint_t;	

	namespace Drawing
	{
		using platform::BitmapPtr;
		using platform::ConstBitmapPtr;
		using platform::Color;
	} //namespace Drawing;
	namespace Runtime
	{
		using platform::Key;
		using platform::KeysInfo;
		using platform::CursorInfo;
	} //namespace Runtime;
	using platform::terminate;
	using platform::yassert;
	using platform::HDirectory;
} //$header Adaptor::YAdaptor;

$Adaptor::Container : Adaptor::YAdaptor
{
	using yasli::vector;
	using std::list, std::map, std::set, std::stack, std::queue, std::priority_queue, std::basic_string, std::string;
} //$header Adaptor::Container;

$header Core::YShellDefinition : Adaptor::YAdaptor
{
	using Components::Controls::IControl, Components::Controls::IVisualControl;
	using Components::Forms::YForm, Components::Forms::YFrameWindow;
	using Components::Widgets::IWidget, Components::Widgets::IWidgetContainer;
	using Components::YDesktop;

	using Device::YScreen;

	using Drawing::YFontCache;

	using Shells::YMessageQueue;
	using Shells::YShell, Shells::YShellMain;
	
	using Text::String;
} //$header Core::YShellDefinition;

$header Core::YCoreUtilities : Core::YShellDefinition
{
	using Design::NonCopyable;
}

$header Core::YShellMessage : Core::YShellDefinition
{
	using Drawing::Point;

	using Shells::Message, Shells::InsertMessage;
} //$header Core::YCoreUtilities;

//$header Core::YResource : Shell::YGDI;

$header Shell::YGDI
{
} //$header Shell::YGDI;

$header Shell::YComponent : YShellMessage;

$header Shell::YWidget : Shell::YComponent, Core::YResource
{
	namespace Components
	{
		using Drawing::PixelType, Drawing::BitmapPtr, Drawing::ConstBitmapPtr, Drawing::ScreenBufferType, Drawing::Color;

		using Drawing::Point, Drawing::Vec, Drawing::Size, Drawing::Rect;
		using Drawing::YImage;
	} //namespace Components;
} //$header Shell::YWidget;

$header Shell::YControl : Shell::YWidget
{
	namespace Components
	{
		using namespace Drawing;
	} //namespace Components;
} //$header Shell::YControl;

} //$code YSLib;

///

#region synopsis(end)

