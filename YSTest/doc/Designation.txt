// YSLib -> Designation by Franksoft 2009 - 2010
// CodePage = UTF-8;
// CTime = 2009-12-2 5:14:30;
// UTime = 2010-7-26 7:53;
// Version = 0.2910;


// Designation ：设计说明文档。

// Shell 消息列表见 YSLib.txt 。
// 接口定义见 Interface.txt 。

/*
//E; = experimental;
*/

/*

 YSLib 设计思路：

@1 基本思路和编码风格：
库设计的出发点。不保证内容的连贯性。

@1.1 设计目的：
以标准 C++ 环境为基础的嵌入式设备等平台为基础，建立常规应用程序界面。

@1.2 构建原则：

@1.2.1 可移植性基础：
基于标准 C++ 环境（ISO/IEC C++ 2003 基本语言特性和库函数）和基本的 I/O 系统调用。

@1.2.1.1
格式化输出及结构对齐时注意平台字长差异。

@1.2.2 实现特征概述：
便于扩展。
尽可能地平台无关，且注重效率。
能够保持必要的运行时安全性。
实现一部分操作系统的较高级功能，例如消息服务。

@1.2.3 广义的契约式设计：

@1.2.3.1
由于语言的限制，语句（块）级别仅使用断言约束。

@1.2.3.2 面向接口：

@1.2.3.2.1
使用不含状态（成员变量）的纯虚类作为接口。

@1.2.3.2.2
如有必要，接口可以包含静态常量域。

@1.2.3.2.3
可选虚继承，但考虑到性能，应该尽量避免。

@1.2.3.2.4
合理使用接口回调、模板或混合实现。

@1.2.3.2.5
接口类型转换可选 dynamic_cast ，但能保证类型安全时首选 static_cast ，以提升性能。

@1.2.4 抽象构建方法：

@1.2.4.1 保守封装性：
按需封装类的继承体系，尽可能使用 private 成员而不是 protected 成员。
允许合理使用友元。

@1.2.4.2 强继承性：
使用模块类多重继承获得高度可复用性。
仅在必要时实现接口。

@1.2.4.3 保守多态性：
仅在必要时或可预见的扩展前提下使用虚函数。
尽可能避免虚继承。

@1.2.4.4
除非必要或有可预见的使用场合，使用聚合而不是组合来构建类。

@1.2.4.5
合理地使用类的成员变量保存状态，仅在必要时通过成员函数实现属性。

@1.2.5 运行期错误处理：

@1.2.5.1 常规处理：
使用特定的函数返回值（如 NULL ）表示非预期的结果。

@1.2.5.2 异常：
仅在必要时使用。
异常类的设计可使用多重继承。
除异常类设计外，不显式使用异常规范。
在无异常抛出保证的场合，使用异常规范注释。

@1.2.5.2.1 异常中立：
除非属于内部实现或异常能够被合适地完全处理，总是向调用者重新抛出捕获的异常。

@1.2.5.2.2
优先使用 RAII（Resource Acquisition Is Initialization ，资源获取即初始化）实现异常安全的设计。

@1.2.5.2.3 最低异常安全性保证：
总是保证最低安全性，避免异常处理造成资源泄露。

@1.2.5.2.4 强异常安全性保证：
如果可能，考虑实现回滚状态。

@1.2.5.2.5
除非有必要，不使用嵌套 try 块。

@1.2.5.3 日志： //E;
输出可选的、可组织的日志文档。

@1.3 语言相关但具体设计内容无关的编码风格（一般性建议）：

@1.3.1 预处理：

@1.3.1.1
尽可能不使用宏。

@1.3.1.1.1
尽可能使用 const 关键字定义常量，而不是宏。

@1.3.1.2
使用条件编译控制文件包含，而不是编译器相关的预处理指令。
除此之外，尽可能不使用条件编译。

@1.3.1.3
可以使用 #error 、 #warning 和 #line ，但仅使用 ANSI 字符，以免出现不符合的预期文本。

@1.3.2 存储类关键字：

@1.3.2.1
不使用表示存储类的关键字 auto ，编译器会隐式地实现。
显式使用会使 C++0x 代码的共用出现问题。

@1.3.2.2
除了平台相关的上下文以外，不使用存储类关键字 register 。
注意 register 仅是建议，而不是命令。

@1.3.2.3 static ：

@1.3.2.3.1
使用编译单元内的无名命名空间代替 static 修饰对象。

@1.3.2.3.2
可以在类的定义中 static ，不必要在类的成员函数定义中重写。

@1.3.2.4 extern ：

@1.3.2.4.1
正确地使用 extern ，并检查语义的合理性。

@1.3.2.4.2
注意在多个编译单元中，extern 声明的类型应该保持一致。

@1.3.3 const 和 volatile 修饰符 ：

@1.3.3.1 const ：
如果有可能，尽可能使用 const 关键字，除了以下给出的$例外 (@1.3.3.1.3) 。

@1.3.3.1.1
如果可能，使用 const 引用类型传递参数。

@1.3.3.1.2
除非必要 (@1.3.3.1.3) ，不使用非 const 引用类型形式参数。

@1.3.3.1.3
$例外：在需要复制构造参数的场合（如某些 copy-and-swap idiom 的实现），使用值类型参数而不是引用，以免传递右值参数时引起不必要的复制构造。

@1.3.3.2
仅在有必要时使用 volatile 关键字。

@1.3.3.3 例外：
在异常捕获块中，省略形式参数顶层的 const 和 volatile 修饰符。

@1.3.3.2
如果有必要，使用 volatile 关键字。

@1.3.3.3 类型关键字：

@1.3.3.1 整数类型：

@1.3.3.1.1
尽可能使用确定大小的整型。

@1.3.3.1.2
在位运算以外的上下文中尽可能不使用无符号整数。

@1.3.3.2
注意 sizeof(void*) == sizeof(int) 并不在所有平台上保证成立。
需要使用和对象指针占用空间大小相同的整数类型时，使用 std::intptr_t 。

@1.3.3.3
根据可访问性的需要选择 struct 或 class 。

@1.3.3.4
在定义模板参数时 class 和 typename 等价，但应该根据语义适当选择：
如果确定仅适用于 class 类型，使用关键字 class ；否则使用关键字 typename 。

@1.3.4 字面量：

@1.3.4.1
关键字 true/false 和 bool 类型对应；宏 TRUE/FALSE 和 int 类型（例如自定义的 BOOL 类型）对应。
尽可能使用前者。

@1.3.4.2
非关键字字面量的表达必须保证符合语法，且兼顾可读性。

@1.3.4.3
整数用0，浮点数用 0.0 、0d，指针用 NULL ，字符（串）用 '\0' （非字面量形式用 NUL 表示）。
有必要使用 float 时，用 0f 。

@1.3.4.4
合理使用字符串字面量前缀 ('L') 。

@1.3.4.5
可以使用字符串字面量初始化 C 风格字符串。
被初始化的若为字符数组，元素（字符类型）必须是 const 类型修饰的。

@1.3.4.6
必要时可以同时使用字符串字面量和断行连接。

@1.3.5 操作符：

@1.3.5.1
尽可能用对象名称代替类型名称作为 sizeof 的操作数，以在重编码时保持一致性。

@1.3.6 控制流：

@1.3.6.1
如果可能，使用 if 结构代替 if-else 结构。

@1.3.6.2
尽可能不使用 goto ：仅在退出多层循环等少数具有明确语义且没有高效结构化控制流替代方式时使用。

@1.3.6.3
合理减少 switch 块中的 break 个数。

@1.3.6.4
关于异常处理相关的部分，参考： @1.2.5.2 。

@1.3.7 类型操作：

@1.3.7.1
注意参数传递中的退化：数组到指针，函数到函数指针。

@1.3.7.2
除非特殊情况，禁止使用变长数组。

@1.3.7.3
使用 C++ 风格而不是 C 风格的类型转换。

@1.3.7.4
如果可能，使用 dynamic_cast 代替 typeid ；
如果可能，使用 static_cast 代替 dynamic_cast ；
如果可能，使用 static_cast 代替 reinterpret_cast 。
参考：@1.2.3.2.5 。

@1.3.8 重载、可见性和可访问性
注意函数重载的使用的清晰性和易读性。

@1.3.8.1
合理地使用缺省函数参数。需要注意参数顺序。

@1.3.8.2
在结构体/类中合理使用 using 声明使被隐藏成员可见。

@1.3.8.3
在结构体/类中合理使用 using 声明使被隐藏成员可见。

@1.3.9
在相同作用域内，前置和后置自增/减被同时定义时，尽量保证它们的语义一致性，并通过前置自增/减来实现后置版本。如果有必要改变，必须给出注释说明。
能使用前置自增/减实现相同效果时，不用后置自增/减。

@1.3.10
可以同时使用流和 printf/scanf 函数族进行格式化输入/输出处理。
正确使用 printf/scanf 函数族格式化输入输出的控制字符。

@1.4 Shell 概念扩展：
 Shell 和 Core 的关系是相对的。高级操作系统对于操作系统内核 (Kernel) 来说，即 Shell 相对于 Core 的关系。基于操作系统 Shell 的应用程序相对于操作系统 Shell 来说，也是这种关系。即这种关系可以级联。对组织虚拟机等仿真程序来说较为方便。
因此， YSLib 中的实现 Shell 的类 YShell 本身位于 "/Core" ，而不是 "/Shell" 。

@1.5 对象特性抽象：

@1.5.1
容器是在逻辑上包含零个或更多个其它对象的对象。

@1.6 概念约束：
实现了容器模板接口 GIContainer 的类，称为容器 (Container) 类。

@1.7 进程内通信：

@1.7.1 事件：
事件是用户发出的信号在进程中的抽象。
事件本身是即时的，包含发生时间和事件内容两个方面的意义（有时后者又包含前者）。

@1.7.1.1 事件空间：
对于有限的不同种类事件，它们内容可以用整数或枚举类型标识，对应的取值集合称为事件空间。

@1.7.1.2 事件回调：
事件可以在生成同时调用预先设置对应关系（注册）的事件处理器，即同步回调；也可以事件发生后延迟调用，即异步回调。
复杂的异步回调要求事件能够被传递。

@1.7.2 简单事件调用：
可以通过把事件本身抽象为具体的类，借用委托（例如函数指针）实现同步回调。

@1.7.3 消息：
为了传递事件，需把其中的事件内容包装至某一可传递的数据结构中。使用消息机制解决这个问题。
消息类型是为了在应用程序进程内部、应用程序进程之间以及应用程序进程和操作系统之间传递数据的数据结构。它的实例称为消息（Message）。
使用消息传递事件内容，需要包含一个主标识和与其语义相关（具体语义可以取决于主标识）的其它参数。除此之外，消息类型中的成员是可定制的。
各个域完全相等的消息是完全相同的。

@1.7.3.1 消息空间：
所有能够在一个处理单元（例如线程）在该单元生存期被处理的消息集合称为消息空间。
任意完全相同的消息在一个消息空间中不应该含有超过一个实例。
消息空间的具体实现可以采用队列等抽象数据结构。

@1.7 组件概述：

@1.7.1 UI（用户界面）设计：
相对于传统 UI 设计，为了适应不确定数量的输出设备，增加中间层 Shell ，负责直接处理 UI（User Interface ，用户界面）相关的部分。
和 Shell 相对的是 Core 。
 Shell 和 Core 相对独立，以方便移植。
 Shell 仅仅负责直接和 UI 相关的部分，包括直接的相关消息处理。
 Shell 本身为单线程。

@1.7.2 控件设计层面的部分解耦：
 GUI（Graphic UI ，图形用户界面）控件退化为组件，组件退化为部件，进而分离控件和部件属性，抽象出独立于部件的控件特征，细分功能以实现高度可配置性。
 YSLib 本身不提供大量成熟的控件，而是着重提供可供组装为控件的基本 GUI 类（部件）、在部件基础上衍生的构件以及部件简单组合的组件。这些设计元件都不具有消息处理功能，因此不是控件。
控件主要由用户通过组装以上的元件定制。但是， YSLib 仍然在 YControl 单元中提供最常用的控件实现。
同时，提供基于观察者模式的基本事件回调模板类和基于责任链模式的消息映射表类，以方便用户实现消息映射和其它间接传递消息的功能。

@1.7.3 对象所有权：
具有所有权的对象（所有者）负责被托管对象的释放。
一旦向对象所有者添加了对象，就不应在从所有者移除该对象前通过所有者以外的途径访问该对象（作用于对象，从所有者移除该对象的操作除外）。
由于所有权最终会导致对象被所有者释放，因此具有栈语义的自动对象不宜被添加所有权，否则容易被误释放超过一次。若自动对象被添加所有权，则应确保所有者释放该对象之前，手动从所有者移除该对象。
以下所有权关系中，被托管对象类包括派生类：
 YApplication 拥有 Shells::YShell 所有权。
 Drawing::YFontCache 拥有 Drawing::MTypeface 、 Drawing::MFontFile 、 Drawing::MFontFamily 的所有权。
 Text::MTextMap 及其派生类 Text::MTextFileBuffer 拥有 Text::MTextBlock 的所有权。

@2 实现概览：
外部库参考 @3 。
一个编译单元一般对应一个或多个头文件，包含类（组件）或 API（Application Programming Interface ，应用程序编程接口）的实现。
多个编译单元组成一个系统。

@2.1 命名空间、对象作用域和全局对象规则：
使用嵌套命名空间。
一个单元可能有多个命名空间。
一个命名空间可能在多个模块中。

@2.1.1 一般准则：
禁止在头文件中使用不具名命名空间 (unnamed namespace) 。
禁止在头文件中使用全局 using 指示符，除非是有意的（例如减少别名个数；需在文档中说明）。
局部对象在声明时同时初始化。
函数内变量尽可能置于最小作用域内——除非效率原因，尽可能使用语句块级对象代替函数级局部对象。
避免在嵌套类中定义被嵌套类的定义，除非能够确保此定义的实现无关性。
有依赖关系的全局对象应置于同一编译单元内。
禁止使用函数返回值初始化全局对象。
除非程序明确为单线程的，禁止使用非 POD(plain-old data) 类型的全局对象。如果非必要，用内建 (built-in) 类型代替 POD 结构体全局对象。
多线程程序中，禁止使用非 const 全局对象。

@2.1.2 YSLib 库的根命名空间为 YSLib ，一般应置于全局命名空间中，即为 ::YSLib 。

@2.1.3 依赖性：
默认显式依赖于库 CHRLib 。具体由适配器系统 (@2.7) 决定。

@2.1.4 命名空间分配：
 YSLib::Components ：组件。
 YSLib::Components::Widgets ：部件。
 YSLib::Components::Controls ：控件。
 YSLib::Components::Forms ：窗体应用。
 YSLib::Design ：编译期基础语言设施（类型操作等）。
 YSLib::Design::Pattern ：设计模式。
 YSLib::Design::TL ：类型表 (Typelist) 操作。
 YSLib::Exceptions ：异常。
 YSLib::Device ：设备抽象。
 YSLib::Drawing ：图形处理。
 YSLib::IO ：输入/输出管理。
 YSLib::Runtime ：运行时对象。
 YSLib::Shells ： Shell 抽象层。
 YSLib::Text ：文本服务。
 YSLib::Timers ：计时器服务。

@2.2 语言特性支持：

@2.2.1 接口

@2.2.2 断言

@2.2.3 成员函数简写

@2.3 类构建：

@2.3.1 命名必须和标识符命名规约兼容。

@2.3.2 类型特性：
空结构体类型 EmptyType 。
除了 I 和 A 前缀的类，都可以被实例化。
 Y 前缀类名的类不可被多继承。

@2.3.3 M 前缀类名的类：
模块类。
作为带有域的形式接口（为了实现效率，不由编译器对此进行语法检查），参与多重继承构建新的类。
可实例化，也可作为类的成员域。
对于模块类，应尽可能减少虚表体积，并降低额外的运行时效率开销。
标准库异常以外的异常公共基类 MException ：派生自std::exception 。
事件参数基类 MEventArgs ：即 EmptyType 。

@2.3.4 Y 前缀类名的类：
一般构件类，包括 YObject 和直接或间接派生自 YObject 的类。
基本对象类 YObject ：所有类名以 Y 作前缀（除模板类、非直接实例化类和模块类）的公共基类，为多态类。
提供引用相等判断等公共方法。
基本可数对象类 YCountableObject ：所有可数的基本对象类的公共基类，通过继承 GMCounter 模板实现静态实例计数器。

@2.3.3 S 前缀类名的类：
屏幕对象类。
尽量实现为 POD 类型。
其它特性类型同模块类。

@2.3.4 E 前缀类名的类：
枚举包装类。
包括事件空间类，即实现了 EventID 类型成员的类，仅作为模板参数使用。 EventID 可以是整数或枚举类型。
其它特性类型同屏幕对象类。

@2.3.5 H 前缀类名的类：
句柄类。
具有引用或迭代器语义的类。

@2.4 核心构件系统：
位于 "/Core" 。
除了通用定义 YSDefinition 以外，主要包含以下几大部分：
对象计数器 YCounter；
函数对象封装模块 YFunc ；
核心实用模块 YCoreUtilities ；
平台无关的基础对象实现 YObject ；
异常处理模块 MException ；
基础字符串管理 YString ；
应用程序实例类抽象 YApplication ；
 Shell 定义 YShell ；
平台无关的设备抽象层 YDevice ；
资源管理模块 YResource ；
平台无关的文件处理系统 YFileSystem；
文件类集 YFile 等。

@2.4.1 设备抽象：
位于命名空间 Device 中。

@2.4.1.1 物理设备：
 YGraphicDevice 是输出设备基类。
 YScreen 由 YGraphicDevice 派生，是二维屏幕的抽象。

@2.4.1.2 虚拟设备：

@2.4.1.2.1 桌面：参考 @2.4.1 。

@2.4.2 通用字符串抽象。

@2.4.3 事件的实现：
位于单元 YEvent 中。
简单事件调用的标准实现位于命名空间 Runtime 中。
传递事件参数的参数基类是 MEventArgs ，可从这个类派生自定义参数类。
除此之外，默认提供以下参数类：
 MScreenPositionEventArgs ，屏幕事件参数类；
 MInputEventArgs ，输入事件参数模块类；
 MTouchEventArgs ，指针设备输入事件参数类；
 MKeyEventArgs ，键盘输入事件参数类；
为了实现和派生上的便利性，包括 MEventArgs 以上类实际为结构体类型。
用模板定义用于事件处理机制的接口和实现类：
事件处理器接口模板 GIHEventHandler ，标准版 IHEventHandler ；
事件处理器模板 GHEvent ，标准版 HEvent ；
事件模板 GEvent ，默认第一参数为 true 时为多播版本，否则为单播版本，标准版 YEvent 为多播版本；
事件映射表模板 GEventMap 。

@2.4.3.1 标准事件处理实现概述：
基于 C++ 语言的局限性和效率考虑，事件处理器调用仅进行空指针检查（若为 NULL 则取消调用）。
单播版本：
添加事件订阅和移除事件订阅复杂度为 O(1) ，同普通的函数指针赋值。调用事件处理器复杂度为 O(1) ，同普通的函数指针调用。
多播版本：
本质上是 std::list 实现的函数指针队列。
调用链维持稳定的顺序（和订阅顺序相同）。
对于重复订阅，仅保留一个实例，添加时移至调用链末尾。
事件处理器调用顺序由调用链决定。
对于调用链长 n ，添加事件订阅、移除事件订阅、调用事件处理器复杂度相对每个事件处理器调用为 O(n) 。
每个事件处理器调用复杂度同单播版本。

@2.4.4 消息的实现：
消息类型是 MMSG 类；
消息主标识是唯一的，简称为消息标识，它的类型为 MSGID（本质上是无符号整数）；
消息队列类型是 YMessageQueue 类，是一个优先队列。
库中的 "/Core/ysmsgdef.h" 文件预定义了一些消息标识。覆盖这些标识的最小连续区间称为系统消息标识区间。
用户可自定义新的标识（用户自定义消息标识），但不应该和原有定义冲突。由于为宏定义实现，可以使多个标识名对应一个实际的标识，但反之无法实现。
应尽可能保持所有用户自定义消息标识在系统消息标识区间之外。
消息的处理的具体实现取决于用户。

@2.4.5 消息队列的实现：
消息队列为优先队列。第一优先级为 unsigned char 型变量。为了适应不支持 clock() 的平台，用消息的计数标识代替产生时间作为第二优先级。

@2.5 图形系统：
位于 "/Shell" 。
包含 GDI/GUI 常用 API 以及其它较底层的绘图函数。更基本的图形抽象和资源管理则来自于 "/Core/YObject" 和 "/Core/YResource" 。

@2.5.1 桌面：
组件命名空间 Components 中的 YDesktop 类是桌面的抽象，自带显示缓冲区，和 YScreen 关联，负责把窗体和其它桌面对象输出至屏幕。

@2.5.2 文本服务：
通用的字符/字符串栅格化处理。字符串本身的逻辑处理在 "/Core" 中，而不在此处。

@2.6 组件 (Components) 系统：
位于 "/Shell" 。
组件/构件 (Component) 是具有一定相互联系的功能集合单元。 YSLib 中的组件是以引用方式传递的类。
组件类是非抽象类，默认基类为 YComponent 。
组件包含部件和控件：
具有基本屏幕输出效果，实现了部件接口 IWidget 的类，称为部件 (Widget) 类；
具有公共事件响应能力，实现了控件接口 IControl 的类，称为控件 (Control) 类；
同时具有基本屏幕输出效果和公共事件响应能力，实现了接口 IWidget 和 IControl 的类，称为可视控件类 (VisualControl) 类。
部件仅仅负责 Shell 直接和 UI 相关的部分，默认不包含任何消息处理。
消息应该被其从属的 YShell 消息处理过程截获并进行处理。
控件是可以处理消息的组件。
控件行为由事件映射表控制（在运行期加载函数）。其它组件行为原则上直接由 YShell 消息处理过程控制，以避免消息转发带来的开销。

@2.6.1 用于 GUI 的对象特性：
所有 GUI 对象继承自组件基类。
部件是实现了 IWidget 接口的类，是基本的 GUI 对象类。
组件容器是能够以引用方式在逻辑上包含其它组件的组件，它实现了 GIContainer 接口模板的实例。
部件容器是实现了 IWidgetContainer 接口（继承 IWidget 接口）的类（标准基类为 YWidgetContainer ），是一般化的组件容器，它能以可视化方式处理其包含的部件（例如顺序显示）。
控件是实现了 IControl 接口的类（标准基类为 YControl ），是具有一般化的事件（不一定是 GUI 事件）响应能力的组件。
可视控件是实现了 IVisualControl 接口（继承 IControl 接口）的类（标准基类为 YVisualControl ），是具有控件特性的组件。 YVisualControl 同时也是部件。
窗口是实现了 IWindow 接口（继承 IWidgetContainer 和 IVisualControl 接口）的类（标准模块基类为 AWindow 抽象类），是作为一种能在桌面显示的自带缓冲区的特殊组件，不涉及界面以外的任务，不通过事件映射方式响应事件（尽管同时是焦点响应类和焦点请求类）。
框架窗口（基类为 YFrameWindow ）是具有一般化的部件容器功能的窗口。
窗体（基类为 YForm ）是增加了事件映射响应能力和客户区布局管理的框架窗口。
默认组件中，除继承自窗口的组件（基类为 YWindow ，缓冲区继承自类 MBitmapBuffer ）外，所有部件默认不带显示缓冲区。实际使用时可以用其它类型成员（如 MTextRegion ）提供显示缓冲区。

@2.6.2 用于 GUI 的焦点特性：
焦点标识当前（通常是用于响应输入的）操作作用的对象。 YSLib 中用指针实现，同时在每个可识别自身焦点状态的对象中用 bool 变量指示状态。
继承 GMFocusResponser 模板类的类具有焦点响应能力（即储存了关于集中焦点于特定的子对象的状态），称为焦点响应类。
实现 AFocusRequester 抽象类的类具有焦点请求能力（即能够从焦点响应类中获取焦点），称为焦点请求类。
 YDesktop 是 IVisualControl 的焦点响应类。
 YWindow 和 YForm 同时是 IVisualControl 的焦点响应类和对于 YDesktop 焦点请求类。

@2.6.2.1 焦点污染：
焦点默认和请求/响应双方相关，而和其它对象无关。即 RequestFocus(...) 函数应该只改变主调对象及其响应对象中描述焦点的状态域，而不产生副作用。
可以在 GotFocus 和 LostFocus 的响应函数中添加相关代码改变这一特性，但会使主调对象和其它对象产生额外的关联。这种关联不符合焦点本身的语义，且难以调试，如非必要，应该避免。

@2.6.2.2 焦点请求链：
在排除 @2.6.2.1 中叙述的副作用的情况下，可以认为不同对象的 RequestFocus(...) 的调用是顺序无关的，可以任意调度。
也因为如此，YSLib 默认实现中，不提供 Enter 和 Leave 事件（不是必要的）。
用 Runtime::RequestFocusCascade(Components::Controls::IVisualControl&) 函数可以实现由 IVisualControl 对象自下向上的嵌套容器焦点申请。注意，会以相同的顺序引发 GotFocus 事件。

@2.6.3 默认 GUI 刷新逻辑：
部件向容器请求得到绘制的过程称为刷新。缓冲区内的图形信息复制到其它缓冲区的过程称为更新。
部件实例存储刷新状态。此外，带缓冲区的部件（包括窗口和桌面）实例存储更新状态。这些状态用 bool 类型变量表示，值为 true 时表示需要进行对应操作。
 DrawBackground() 和 DrawForeground() 分别是绘制背景和前景的接口。 Draw() 作为绘制接口。
 Refresh() 向上层缓冲区传递刷新状态，但不立即绘图。
更新状态为 true 时， Update() 向缓冲区内的下层对象查询刷新状态，若需要刷新则绘图，之后更新至上层缓冲区（对于桌面而言是屏幕）。
在 Shell 处理函数中可以在输入分支后添加桌面对象的 Update() ，按需要更新最近经过重绘但未经过更新的 GUI 对象。

@2.7 适配器 (Adapter) 系统：
位于 "/Adapter" 。
负责衔接和封装外部库，便于移植。
除了 C++ 标准库以外，其它外部库的函数需要在此声明，以便辨别。
直接使用除 C++ 标准库、 POSIX / GNU C 兼容函数库、 YCLib 库和 CHRLib 库之外的外部库的代码段所在文件都从属于 Adapter 或 Helper 。

@2.8 服务系统：
位于 "/Service" 。
对以上组件提供内部和外部的常用类型和函数的封装。

@2.8.1 初始化逻辑的实现

@2.8.2 通用函数

@2.8.3 文本管理类

@2.9 帮助模块系统：
位于 "/Helper" 。
与以上系统不同，这个系统是平台相关的，一般由库用户自行配置。
 YGlobal 是不可缺少的，它封装了 main 函数和必要的全局变量。

@2.10 本体：
以上 YSLib 构成单元中，除了 Adapter 和 Helper 以外的部分的总称。
其中 Adapter 的改变很可能导致整个本体的重新编译。因此新增的平台相关的部分应尽量放在 Helper 中。

@3 库配置：

@3.1 支持库概述：

@3.1.1 基础库：
平台隔离用库 YCLib 。

@3.1.2 通用库：

@3.1.2.1
使用 Loki 库的智能指针实现句柄。

@3.1.3 专用库：

@3.1.3.1
字符串内码支持库 CHRLib 。

@3.1.3.2
字体输出使用 FreeType2 实现矢量字体光栅化支持。

@3.1.3.2.1
头文件版本： 2.3.12 ；
库文件版本：在 VNDS 源代码中提取的 2.3.6 。

@3.1.3.3
图形库：修正的 Anti-Grain Geometry 库 V2.4 。

@3.2 库文件基础结构：
平台设置在 <platform.h> 中。
任何 YSLib 文件，除了 "/Adapter/yadapter.h" 和 "/Core/ysdef.h" 以及仅包含宏定义的文件外，都必须包含 "/Core/ysdef.h" 文件。
所有外部链接库为静态库。除了 CHRLib （未找到替代品）和 YCLib 外，对外部库未经过封装的使用仅在 /Adapter 组件中。这样有利于库的移植。

@4 标识符命名规约：

@4.0
通用指引：

@4.0.1
词与词之间需有 "_" 分隔符或大小写不同以示区分。

@4.0.1.1
被缩写词大小写不改变。如“GUI”缩写后不作“Gui”。

@4.0.2
保留标识符：
一般不应被用户程序使用。

@4.0.2.1
按 ISO/IEC 14882:2003 C++ 标准条款 17.4.3.1.2 [Global Names] 规定，包含双下划线 "__" 或以下划线紧接大写字母起始的标识符保留给（语言和标准库）实现使用。

@4.0.3
以 "_y" 起始的标识符保留给 YSLib 库内部实现使用。

@4.0.4
以 "INCLUDED_" 起始的标识符专用于头文件包含判定。

@4.0.5
以 "_b" / "_p" / "_f" / "_i" / "_t" / "_g" 起始并紧接大写字母的标识符保留给 YSLib 模板参数使用，分别表示布尔类型参数、指针类型参数、函数类型参数、接口类型参数、一般类型参数、模板类型参数。

@4.1
宏定义

@4.1.1
默认使用大写字母。用其它标识符构造的宏以及特殊宏除外。

@4.1.2
特殊宏。

@4.1.2.1
实现语言功能，如interface等。

@4.1.2.2
代码生成器：用宏展开为一段声明或定义的代码。

@4.1.3
 YSLib 保留宏以 "YSL" 起始。

@4.2
类型名

@4.2.1
定长整型：全局命名空间中的类型，以前缀和字长组合的形式以明确整型所占的空间。前缀 s 表示有符号整数，前缀 u 表示无符号整数。

@4.2.2
通用类型：非全局命名空间中的类型，小写字母，以 "_t" 作为后缀。

@4.2.3
同质聚合类型：数组或容器类型，用不少于2个大写字母和后缀 "s" 组成。

@4.2.4
通用模板类：小写字母，词之间以 "_" 分隔。

@4.2.5
保留类型前缀（关于类型前缀，详细参考 @2.3）：

@4.2.5.1
全局专有模板类前缀 G(Global Generics) 。可和其它前缀共用。

@4.2.5.2 类型特性划分：
以下前缀适用于 struct 和 class 类型。
类型前缀至多使用一个。
类型特性参考 @2.3 。

@4.2.5.2.1
接口（纯虚类）前缀 I(Interface) 。
对应的接口模板前缀 GI 。

@4.2.5.2.2
包含默认实现语义的虚函数的非严格接口（实际为抽象类）在此也作为接口处理。

@4.2.5.2.3
抽象类前缀 A(Abstract) 。
对应的接口模板前缀 GA 。

@4.2.5.2.4
模块类前缀 M(Module) 。

@4.2.5.2.5
一般构件类前缀 Y(YSLib Class) 。

@4.2.5.2.6
屏幕对象类前缀 S(Screen) 。

@4.2.5.2.7
枚举包装类前缀 E(Enum) ，供包装枚举的 struct 和 class 类型使用。
含有事件的含义也属于此范畴，即事件空间类 E(Event Space) 。

@4.2.5.2.8
句柄类前缀 H(Handle) 。

@4.4
标号：同通用模板类。

@4.4
函数名

@4.4.1
非成员函数
以命名空间区分，长度不少于2 。

@4.4.2
成员函数
除 @4.4.1 限制外， public 函数首字母须大写。

@4.4.2.1
 "Get" 和 "Set" 不一定类的访问器，但须符合访问器的一般语义。

@4.4.2.2
一般不使用缩写，除非有特殊含义。

@4.4.2.2.1
 "Ln" 表示文本行，区分于表示像素行的 "Line" 。

@4.4.2.2.2
 "N" 表示索引或总数。

@4.5.常量和变量：

@4.5.1
常量首字母大写，除非是局部（函数体或以下级别）的临时性常量。

@4.5.2
静态 public 成员首字母大写。

@4.5.3
同质聚合类型变量以一个小写字母起始，第二个字母起若干连续字符为大写字母，之后接小写字母或数字，后缀 "s" 。

@4.5.4
哑变量
不超过2个小写字母组成。

@4.5.5
其它变量
不限制。一般同标号。

@5 一般实现导引：
自定义应用程序 Shell 类，继承 YShell 类并产生实例。
完成自定义 Shell 类的消息处理过程。一般把多个处理过程的响应封装为单一函数。
对于支持实现对应 Shell 的窗口封装为窗体（Form）类（一般继承自 YWindow 类），在该自定义类中加入所需的 GUI 部件的定义，并实现界面效果。
在响应 SM_CREATE 或 SM_ACTIVATED 的处理过程中加入需要初始化的资源或子 Shell ，在 SM_DEACTIVATED 的处理过程中加入退出程序或转移线程控制权的指令。
在响应输入等事件消息的处理过程中添加对应的代码。

*/
////

