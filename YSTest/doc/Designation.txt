/*
	Copyright (C) by Franksoft 2009 - 2011.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Designation.txt
\ingroup Documentation
\brief 设计规则指定和说明。
\version 0.5182;
\author FrankHB<frankhb1989@gmail.com>
\par 创建时间:
	2009-12-02 05:14:30 +0800;
\par 修改时间:
	2011-07-08 21:27 +0800;
\par 字符集:
	UTF-8;
\par 模块名称:
	YSLib::Documentation::Designation;
*/


// Shell 消息列表见 YSLib.txt 。
// 接口定义见 Interface.txt 。

/*
//E; = experimental;
*/

/*

 YSLib 设计指定和说明：

@0 体例和适用范围：
以字符 @ 起始的行作为章节标题。
本文档适用于 YSLib 本体(@2.10) 的开发。除非有特别说明，编码细节和其它规范也适用于 YCLib 。

@1 基本原理和表达形式：
设计的出发点：构建一个框架库或者操作系统组件。
代码不保证语义角度（例如实现需求）内容的连贯性。

@1.1 设计目的：
在以标准 C++ 环境（宿主实现）为基础的嵌入式设备等平台上，建立常规应用程序框架。

@1.2 理论背景、工具和依据：

@1.2.1 计算理论和方法学：
离散数学：集合论、组合数学、图论、代数结构、数理逻辑……
可计算理论。
计算复杂性理论。
面向重用的(reuse-oriented) 软件设计。
面向过程程序设计、面向对象程序设计、面向接口程序设计。

@1.2.2 开发模式：
迭代增量式开发。

@1.2.3 架构模式(Architectural Patterns) ：

@1.2.3.1 通用抽象设计：
分层(Layers) ；
外观(Facade) ；
调停者(Mediator) ；
管道和过滤器(Pipes and Filters) ；
解释器(Interpreter) 。

@1.2.3.2 交互式设计：
窗体-控件(Form-Control)；
窗口-图标-菜单-指针设备(WIMP, window-icon-menu-pointing device) 。
模型-视图-控制器(Model-View-Controller) /显示-抽象-控制(Presentation-Abstraction-Control) 。

@1.2.3.3 分布式设计：
暂不考虑。

@1.2.4 设计模式(Design Patterns) ：
略。

@1.2.5 解决模式：
错误处理；
任务安排；
数据验证；
同步请求/响应；
……

@1.2.6 实现模式/代码模式/惯用法(Idioms) ：
语言相关。举例：pimpl 、 copy & swap 。

@1.2.7 其它要点：

@1.2.7.1 语义冗余：
相对于目标代码的操作语义，源代码表达指称语义，这些语义（例如名称的语义）中的一部分不可避免地无法通过机器表达，而仅供人类参考。
应控制冗余在适量的程度。

@1.2.7.2 Shell 概念扩展：
静态角度上， Shell 是程序的一部分（除了 Shell 以外的部分称为 Core ），可以作为的代码重用的单位。
动态角度上， Shell 或 Core 是运行中的程序的一部分，和运行时状态相关；但又不同于与控制流直接相关的进程/线程/纤程，仅强调可以保存特定的可随时间改变的状态。
 Shell 和 Core 的关系是相对的。最终用户使用的操作系统上层用户界面和服务相对于操作系统内核(Kernel) 来说，即 Shell 相对于 Core 的关系。基于操作系统 Shell 的应用程序相对于操作系统 Shell 来说，也是这种关系。即这种关系可以是级联的。对组织虚拟机等仿真程序来说有一定意义。
因此， YSLib 中的实现 Shell 的类 YShell 本身位于 "/Core" 。

@1.2.7.2.1 设计意义：
环境隔离：对特定领域相关的上层源代码提供一致的接口。
抽象和封装：提供控制流实体语义的抽象；提供用于封装上层平台相关的模块的支持。

@1.3 构建原则：

@1.3.1 人类接口(human interface) ：
本节阐述仅对于人类用户有意义，并不直接体现在运行时的原则。

@1.3.1.1 易用性：

@1.3.1.1.1 简单接口：
接口在合理表述语义的基础上应该尽可能简单，具有较小的学习成本。

@1.3.1.1.2 最简名称原则：
在接口中使用最少的名称表达合理的语义。
在实现中尽量少引入不必要的名称。即使是为了适应翻译程序（编译器）的功能限制而不得不引入额外的名称，也需要使用有意义的构词，或者至少给出明确的注释。

@1.3.1.2 明确性：

@1.3.1.2.1 过时(deprecated) 控制：
在正式版本释出的(released) 接口若需要废除，在之前不少于一个的临接版本需要标注 deprecated 提醒库用户接口的变化。

@1.3.2 可移植性相关：

@1.3.2.1 基本术语补充定义：
关于平台无关性（或平台独立性）(platform-independent) 和平台中立性(platform-neutral) ：
一般意义上大致相同，但本文档附加约定：
平台无关性是指代码（源代码或目标代码，下同）在任意现代电子计算机系统（硬件和软件平台）上可以具有一致行为的最大公共实现的特性；
平台中立性是指代码通过一定的软件手段（附加编码、提供附加二进制工具，例如构建虚拟机作为中间平台）实现一致行为的特性。
平台中立性逻辑蕴含平台无关性。平台无关性的条件更严格。

@1.3.2.2
标准库/系统库使用：
基于标准 C++ 环境（ISO/IEC C++ 2003 基本语言特性和库函数以及以下扩展）和基本的系统调用（由 YCLib 支持）。

@1.3.2.2.1 允许使用的非 ISO/IEC C++ 2003 扩展：
定义于 ISO/IEC C 1999 和 ISO/IEC C++ 2011(N3242) 中，且有一个以上完整的语言实现。
 Static assertions(N1720) ；
 long long(N1811) ；
 Right angle brackets(N1757) ；
 Built-in type traits(N1836) ；
 auto-typed variables(N1984) ；
 Extern templates(N1987) ；
 Rvalue references(N2118) ；
 Declared type of an expression(N2343) ；
 Defaulted and deleted functions(N2346) ；
 New function declaration syntax for deduced return types(N2541) ；
 Lambda expressions and closures(N2550) 。
仅使用ISO/IEC C++ 2011 中头文件 <array> 、 <type_traits> 、 <tuple> 、 <forward_list> 、 <unordered_map> 、<unordered_set> 和 <utility> 的特性。

@1.3.2.3
 YSLib 的源代码的本体(@2.10) 是平台中立的。其中的一部分在冯·诺依曼体系结构的现代数字式电子计算机的范畴内是平台无关的。

@1.3.2.4
格式化输出及结构对齐时注意平台字长差异。

@1.3.3 可维护性和架构设计：
平衡可重用性和运行期效率。
对于增加重用性导致代码可读性降低的情况，应该提供额外注释表明实现细节。
翻译单元（以下简称单元）是语言提供对实现进行部署的基础单位，应该合理拆分。
语义相关的架构参考 @1.5.2 。

@1.3.4 实现功能特征概述：
便于扩展。
尽可能地平台无关，且注重效率。
能够保持必要的运行时安全性。
实现一部分操作系统的较高级功能，例如消息服务。

@1.3.5 广义的契约式设计：

@1.3.5.1
由于语言的限制，语句（块）级别仅使用断言约束。

@1.3.5.2 面向接口：

@1.3.5.2.1
使用接口类型(@1.6.1) 。

@1.3.5.2.2
可选虚继承，但考虑到性能，应该尽量避免。

@1.3.5.2.3
合理使用接口回调、泛型以及混合实现。
协调接口和抽象类的使用。

@1.3.5.2.4
关于类型转换，参见 @1.4.9.4 。

@1.3.6 抽象构建方法：

@1.3.6.1 接口设计风格：
最小接口优先。

@1.3.6.1.1
涉及类的人本接口应独立于类的定义和实现之外，而不作为成员方法，除非有下列例外。

@1.3.6.1.1.1 例外 1 ：
方法（特别是被超过一次地）在类的实现中使用。

@1.3.6.1.1.2 例外 2 ：
非显式地由语法（例如继承和覆盖）约束的相关接口集合（特别是作为不同类中的签名类似的成员方法）。这样可以方便（跨类或跨文件的）重构（目标可能是一个模板）。

@1.3.6.1.1.3 例外 3 ：
模块类(@2.4.7) 以及由模块类派生的类，如某些一般构件类(@2.4.6) 。

@1.3.6.2 合理封装性：
按需封装类的继承体系，尽可能使用 private 成员而不是 protected 成员。
类不是封装的唯一单位。（头）文件可以作为更大粒度的封装单位使用。
必要时（例如特定操作符重载，或基于操作名称的自然语义考虑）使用友元突破类的封装性限制。除此之外尽可能少使用友元。

@1.3.6.2.1 封装范围限制实例：
对于以类实例的整体为客体的操作（如 Activate 方法；注意无参数的 Clear 、 Reset 等方法不在此列），除了和对象生存期相关的行为（例如构造、析构和初始化），在翻译单元及命名空间内而不是类的内部封装。

@1.3.6.3 有限继承性：
使用模块类(@2.4.7) 的多重继承提供实现获得高度可复用性。
仅在必要时使用接口实现。
尽可能使用组合代替 private 继承，除非需要使用派生类覆盖 private 基类的（纯）虚函数。

@1.3.6.4 保守多态性：
仅在必要时或可预见的扩展前提下使用虚函数。
尽可能避免虚继承。

@1.3.6.5
除非必要或有可预见的使用场合，使用聚合而不是组合来构建类。

@1.3.6.6
合理地使用类的成员变量保存状态，仅在必要时通过成员函数实现属性。

@1.3.7 运行期错误处理：

@1.3.7.1 常规处理：
使用特定的函数返回值（如 NULL ）表示非预期的结果。

@1.3.7.2 异常：

@1.3.7.2.1
仅在必要时使用。

@1.3.7.2.2
异常类的设计可使用多重继承。

@1.3.7.2.3
在非显式使用的异常规范上下文中，使用自定义的异常规范宏代替 throw 关键字。

@1.3.7.2.4
除异常类设计外，不显式地使用异常规范，而用异常规范宏代替。

@1.3.7.2.5
在无异常抛出保证的场合，应该使用异常规范。

@1.3.7.2.1 异常中立：
除非属于内部实现或异常能够被合适地完全处理，总是向调用者重新抛出捕获的异常。

@1.3.7.2.2
优先使用 RAII（Resource Acquisition Is Initialization ，资源获取即初始化）实现异常安全的设计。

@1.3.7.2.3 最低异常安全性保证：
总是保证最低安全性，避免异常处理造成资源泄露。

@1.3.7.2.4 强异常安全性保证：
若有抛出异常，实现状态回滚。

@1.3.7.2.5
除非有必要，不使用嵌套 try 块。

@1.3.7.3 日志：//E;
输出可选的、可组织的日志文档。

@1.4 语言相关但具体设计内容无关的源代码特性使用和编码风格（一般性建议）：

@1.4.1 概述：

@1.4.1.1
禁止使用未定义行为(undefined behavior) 的特性。

@1.4.1.2
避免使用未指定行为(unspecified behavior) 的特性。
禁止接口行为依赖于特定的未指定行为。

@1.4.1.3
需要使用由实现定义行为(implementation-defined behavior) 的特性时，适当注释。
禁止接口行为依赖于特定的由实现定义行为，除非存在显式的接口使用约束；需要给出注释。

@1.4.1.4
注意使用未初始化对象具有未决定值(indeterminate value) 。
禁止接口行为依赖于未决定值。

@1.4.1.5
禁止使用 ISO/IEC 14882:2003 C++ Annex D 中的 deprecated 特性。
避免使用 ISO/IEC 14882:2011 C++ Annex D 中的 deprecated 特性。
应特别注意禁止使用在前者中作为 deprecated 特性，在后者中不支持的特性：
 ISO/IEC 14882:2003 C++ Annex D.2 static keyword [depr.static] ；
 ISO/IEC 14882:2003 C++ Annex D.3 Access declarations [depr.access.dcl] ；
 ISO/IEC 14882:2003 C++ Annex D.4 Implicit conversion from const strings [depr.string] 。

@1.4.3 词法、预处理和内容无关的上下文编码规则：

@1.4.3.1 基本名称限制：
本节“实现”指 C++ 核心语言和标准库实现。
本节中引用的标号表示 ISO/IEC 14882:2003 对应章节。

@1.4.3.1.1
按 17.4.3.1.1 Marco Names [lib.extern.names] 规定，可能使用标准库头文件的用户程序翻译单元不得使用词法上等价于关键字的名称作为宏名。

@1.4.3.1.2
按 17.4.3.1.2 Global Names [lib.global.names] 规定，以下名称保留给（核心语言和标准库）实现使用：
包含连续双下划线 "__" 或以下划线 "_" 紧接大写字母起始的名称；
在全局命名空间和 ::std 命名空间内以下划线 "_" 起始的名称。

@1.4.3.1.3
按 17.4.3.1.3 External linkage [lib.extern.names] 规定，以下名称保留给（核心语言和标准库）实现使用：
在头文件中，在 std 命名空间或在全局命名空间的具有外部链接的对象名称，例如 <cerrno> 中定义的 errno ；
在头文件中，具有外部链接的全局函数签名；
外部链接的全局命名空间的对象和函数以及 std 命名空间的对象；
具有 extern "C" 或 extern "C++" 链接的包含连续双下划线 "__" 的名称；
 C 标准库(Standard C library) 使用的具有 extern "C" 链接，在 std 命名空间或在全局命名空间的名称；
 C 标准库(Standard C library) 声明的具有 extern "C" 或 extern "C++" 链接，在全局命名空间的函数签名。

@1.4.3.1.4
按 17.4.3.1.4 Types [lib.extern.types] 规定，对于 C 标准库的每一个类型名称 T ， ::T 和 std::T 保留给实现使用。

@1.4.3.2
标识符命名风格参见 @4 。

@1.4.3.3
不过度依赖词法分析的贪婪性。对于多个连续的操作符，必须以无误导性的方式使用空白符分隔。

@1.4.3.4
同一层次的缩进统一使用制表符或相同宽度的空格。

@1.4.3.5
除特殊情况外，任意不同语句应该属于不同行。

@1.4.3.5.1 例外 1 ：
声明/初始化相同类型的对象。

@1.4.3.5.2 例外 2 ：
执行顺序无关的多条短语句序列。

@1.4.3.6
有源代码兼容性和可读性良好替代方案的情况下，尽可能不使用宏。

@1.4.3.6.1
尽可能使用 const 关键字定义常量，而不是宏。

@1.4.3.6.2
不在 Adaptor 和 Helper 等确定可以使用平台相关的代码以外区域使用环境、编译器和版本判断宏。

@1.4.3.7
使用条件编译控制文件包含，而不是编译器相关的预处理指令。
除此之外，尽可能不使用条件编译。

@1.4.3.8
可以使用 #error 、 #warning 和 #line ，但仅使用 ANSI 字符，以免出现不符合的预期文本。

@1.4.4 替代表达保留字和字面量：

@1.4.4.1
不使用替代表达保留字。

@1.4.4.2
关键字 true/false 和 bool 类型对应；宏 TRUE/FALSE 和 int 类型（例如自定义的 BOOL 类型）对应。
尽可能使用前者。

@1.4.4.3
非关键字字面量的表达必须保证符合语法，且兼顾可读性。

@1.4.4.4 零值：
整数用0，浮点数用 0.0 。
空指针用 nullptr （考虑 C 兼容性可以在保证定义正确的前提下使用 NULL ） 。
字符（串结束符）用 '\0' （非字面量形式用 NUL 表示）。
有必要使用 float 时，用 0f 。

@1.4.4.4
合理使用字符串字面量前缀 ('L') 。

@1.4.4.5
可以使用字符串字面量初始化 C 风格字符串。
被初始化的若为字符数组，元素（字符类型）必须是 const 类型修饰的，参见 @1.4.1.5 。

@1.4.4.6
必要时可以同时使用字符串字面量和断行连接。

@1.4.5 声明、链接、存储期和内联：

@1.4.5.1
不使用表示存储类的关键字 auto ，使用编译器的隐式实现。
显式使用会使和 C++0x 代码的共用出现问题。

@1.4.5.2
尽量避免使用存储类关键字 register ，参见 @1.4.1.4 。
除了平台相关的上下文以外，不使用 register 。
注意 register 仅是建议，而不是命令。

@1.4.5.3
尽量避免使用静态和全局存储期对象。

@1.4.5.4 static ：

@1.4.5.4.1
禁止使用 static 在命名空间作用域声明对象，参见 @1.4.1.4 。
使用翻译单元内的无名命名空间代替。

@1.4.5.4.2
对于成员函数，在类的定义中直接使用 static ，不在类的成员函数定义中重写。

@1.4.5.5 extern ：

@1.4.5.5.1
正确地使用 extern ，并检查语义的合理性。
不使用冗余的 extern 。

@1.4.5.5.2
在多个翻译单元中，extern 声明的类型应该保持一致。

@1.4.5.6 内联 ：

@1.4.5.6.1 语法：
在必要时使用 inline 关键字。
不使用冗余的 inline 。

@1.4.5.6.2
注意 inline 的内联语义对实现只是建议而非强制。
若能保证不降低源代码的可移植性，在必要时可以使用与编译环境相关的内联语法，但不直接使用非标准的内联关键字，而使用特定的宏定义代替。

@1.4.5.6.3
不连用 static inline ，而在无名命名空间中用 inline 代替。

@1.4.5.6.4
在类的成员函数声明中可以省略 inline 关键字，参见 ISO/IEC 14882:2003 C++ 7.1.2/3 。
若类的成员函数声明和定义分离，在完整定义而不是声明处使用 inline 。

@1.4.5.6.5 inline 函数名的链接：
注意 ISO C 和 ISO C++ 对于内联函数的链接的差异。 ISO C 的内联函数默认具有内部链接，而 ISO C++ 的内联函数默认具有外部链接。
按 ISO/IEC 14882:2003 C++ 标准条款 7.1.2 Function specifiers [dcl.fct.spec] 规定可知，非外部链接的内联函数内的局部静态对象不是同一对象。
按 ISO/IEC 14882:2003 C++ 标准条款 3.5 Program and linkage [basic.link] 规定可知，非外部链接的嵌套类名的成员函数不具有外部链接。
因此需要注意当使用内联成员函数且在其中定义静态对象时类名具有的链接。

@1.4.6 const 和 volatile 修饰符(cv-qulifier) ：

@1.4.6.1 const ：
若有可能，尽可能使用 const 关键字，除了以下给出的例外(@1.4.5.3) 。

@1.4.6.2
仅在有必要时使用 volatile 关键字。

@1.4.6.3 例外：
在函数参数列表中，省略不直接修饰参数的 const 。
在异常捕获块中，省略形式参数顶层的 const 和 volatile 修饰符。
函数参数类型在语义上有必要时，考虑不使用 const ，参见 @1.4.10.2 。

@1.4.7 类型关键字和模板：

@1.4.7.1
除非有必要，用非整数类型代替浮点数类型。

@1.4.7.2 整数类型：

@1.4.7.2.1
尽可能使用确定大小的整数类型。

@1.4.7.2.2
在位运算以外的上下文中尽可能不使用无符号整数。

@1.4.7.3
注意 sizeof(void*) == sizeof(int) 并不在所有平台上保证成立。
需要使用和对象指针占用空间大小相同的整数类型时，使用 std::intptr_t 。

@1.4.7.4
根据可访问性的需要选择 struct 或 class 。

@1.4.7.5
在定义模板类型（非模板）参数时 class 和 typename 等价，但应根据语义适当选择，以提升可读性：
若能确定模板类型参数仅适用于 class 类型，使用关键字 class ；否则使用关键字 typename 。

@1.4.7.6
不使用 export 。由于实现的限制，多数编译器无法支持这一标准特性。

@1.4.8 操作符：

@1.4.8.1
尽可能用对象名称代替类型名称作为 sizeof 的操作数，以在重编码时保持一致性。

@1.4.8.2 操作符重载：
参见 @1.4.10.3 。

@1.4.9 语句和控制流：

@1.4.9.1
合理使用 if 语句代替 if-else 语句。

@1.4.9.2
尽可能不使用 goto ：仅在退出多层循环等少数具有明确语义且没有高效结构化控制流替代方式时使用。

@1.4.9.3
合理减少 switch 块中的 break 个数。

@1.4.9.4
基于 C 兼容性和代码一致性考虑，不在 for 的 condition 子句使用初始化（以“ = ”起始）。

@1.4.9.5
异常处理相关使用参见 @1.3.7.2 。

@1.4.10 类型操作：

@1.4.10.1
注意参数传递中的退化：数组到指针，函数到函数指针。
可以使用 std::decay 显式实现。

@1.4.10.2
禁止使用变长数组，除非兼容性需要。

@1.4.10.3
使用 C++ 风格而不是 C 风格的类型转换。

@1.4.10.4
若有可能，使用 dynamic_cast 代替 typeid ；
若有可能，使用 static_cast 代替 dynamic_cast ；
若有可能，使用 static_cast 代替 reinterpret_cast 。
接口类型(@1.6.1) 转换可选 dynamic_cast ，但能保证类型安全且不被虚继承时首选 static_cast ，以提升性能。

@1.4.10.5
禁止对派生类的成员指针使用转换为基类成员指针的 static_cast ，以避免成员指针实现相关的错误。

@1.4.11 重载、参数、可见性和可访问性：
注意函数重载和默认参数的使用的清晰性和易读性。

@1.4.11.1
避免不必要的重载和歧义。

@1.4.11.2 参数类型：
除非以下讨论的语义上的必要性，不使用 const 左值引用类型以外的参数类型。
在需要完全的值类型语义且复制开销较小（例如传递一个内建整数类型的对象）时，使用非引用类型形式参数。
在需要移动语义时，使用非 const 右值引用类型参数，同时使用 std::move 或等价的显式类型转换包装参数传递。
仅向内部实现中的调用传递参数，外层参数使用非 const 右值引用类型时，同时使用 std::forward 或等价的显式类型转换包装参数传递。
关于复制赋值/移动赋值，参见 @1.4.10.3.2 。

@1.4.11.3 操作符重载：

@1.4.11.3.1
在相同作用域内，前置和后置自增/减被同时定义时，尽量保证它们的语义一致性，并通过前置自增/减来实现后置版本。若有必要改变，必须给出注释说明。
能使用前置自增/减实现相同效果时，不用后置自增/减。

@1.4.11.3.2 重载 operator= ：
经典复制赋值实现使用 copy-and-swap idiom 和 const 左值引用参数，能避免自赋值副作用且具有强异常安全性保证(@1.3.7.2.4) 。
通过使用非引用参数代替 const 左值引用的 operator=(unifying assignment operator) ，可以获得对象复制的优化，但具有以下两个缺点：
重载右值引用参数的 operator= 会引起重载歧义，即无法重载优化移动赋值；
无条件复制，无法根据被复制的对象的状态进行优化。
因此，除非被复制的对象具有完全的（所有子对象均满足）值语义，不重载非引用参数的 operator= ，而分别重载 const 左值引用参数和非 const 右值引用参数的版本（也可能不需要移动赋值，仅重载前者）。
若移动赋值是必要的，应确保存在可访问的移动构造函数。
对于保存存储状态的不完全值语义对象（例如容器），使用最小赋值：在 operator= 的实现中判断状态，以避免分配不必要的存储空间。
对于其它不完全值语义对象，若移动赋值是必要的，使用以下实现：
具有明确的 clear 操作回复值的状态时，使用判断自赋值的 clear-and-swap 实现，可以期望比 copy-and-swap 具有更好的性能（因为通常不需要大量 clear 操作）；
其它情况使用默认简单实现，即对每个子对象进行移动赋值（可以显式使用 = default ）。

@1.4.11.4 默认参数：
合理地使用函数默认参数。需要注意参数顺序。

@1.4.11.4.1
在虚函数中应该避免使用默认参数。
若需要使用默认参数，应在基类中使用具有默认参数的非虚成员函数调用没有默认参数的非 public 虚函数。

@1.4.11.5
在结构体/类中合理使用 using 声明使被隐藏成员可见。

@1.4.12
可以同时使用 C++ 标准流和 printf/scanf 函数族进行格式化输入/输出处理，但在考虑效率（以及目标文件大小）时应该尽量避免使用 C++ 标准流。
正确使用 printf/scanf 函数族格式化输入输出的控制字符。

@1.5 通用语义：
本节讨论和约定对于整个程序及其环境通用的描述和一般性结论，也包括契约和其它约束概念。
关于“对象”的概念，参见 ISO/IEC 14882:2003 。

@1.5.1 可编程性和兼容性：
可编程性是程序表达语义的基础。对于通用程序设计，可编程性受到底层实现（例如硬件驱动程序）的约束，仅能够使用有限的接口。
二进制层次上的可编程性在表达语义上无法摆脱底层实现的影响，不利于平台中立的实现，在 YSLib 中放弃此要求。

@1.5.2 程序模型：
程序模型是具体实现了的架构模式这一结果上进一步抽象的产物，主要从计算机（而不是人类）的角度体现语义表达的一般流程。
在可编程性足够强时，除了实现本身的质量，程序模型几乎只受计算机系统软件（例如语言和操作系统）接口及其实现的约束。
本文档在系统软件领域约定使用以下定义：
程序：有限的指令或其它操作语义方法直接能够表示的内容的集合；
资源：可供计算机系统利用以完成语义表达的实体或信息，可以是硬件或软件；
执行：计算机系统利用资源，使用程序片段实现语义表达的过程；
任务：计算机系统执行特定程序的特定目的。
进程：执行中的程序（一般被作为操作系统调度任务的基本单位）；
线程：进程内部不独占特定资源的最小可执行的调度单位（一般对应于程序设计语言逻辑上的控制流）。

@1.5.2.1 运行时程序模型：
 YSLib 基于单一进程和单一线程的运行时程序模型，类似于单内核操作系统；但内部实现是微内核至无内核的，除了主循环，任意一个 Shell 都可以独立部署。
通过改变线程模型相关的设计和实现，进程内的控制流实体应是可扩充的和自洽的，即不产生自身可执行语义上的矛盾。
在适当的平台上通过扩充能实现多个独立的二进制实体并行运行的多进程程序。

@1.5.2.2 资源分类：
 YSLib 对于资源的直接使用仅限软件资源（硬件资源通过语言抽象和 YCLib 等平台兼容层包装后间接使用）。
（软件）资源分为（软件）系统资源和应用程序资源。
程序本身是系统资源。
作为任务调度单位的进程和线程是系统资源。
处理器资源是硬件资源，由于并不直接出现在源代码中，不是软件资源，不是系统资源；但若实现环境提供直接接口对其进行操作（例如统计 CPU 利用率）时，视作系统资源。
内存储器是硬件资源，经过语言抽象后转换为地址空间。基于实现的原因，地址空间中某些特定的部分最常被利用，如调用栈上的栈帧。这些资源统称为内存资源。内存资源是系统资源。
外存储器是硬件资源，经过实现环境抽象后以文件系统等形式存在，通过应用程序接口等被进程利用。这些形式中的实体（例如文件）在进程中被映射为特定的数据（例如句柄或描述符），这些资源是软件资源，称为外存资源。外存资源是系统资源。
所有被用于直接维持程序调度相关的资源都是系统资源（例如互斥锁）。
其它资源都是应用程序资源。
和内容相关的应用程序资源称为内容资源，包括文本和二进制资源。
二进制资源按内容使用的形式可以分为程序（此处仅指静态的代码集合）、图形、图像、音频、视频等，也包括其它用户自定义格式的数据。

@1.5.2.3 资源管理：
在特定的时间点或控制流中向进程分配和回收具体的资源实例的行为总称为资源管理。资源管理由进程自身在被执行时实现，其逻辑则由程序员在编译期通过源代码对资源的获取和释放操作条件的描述指定。
资源从使用开始到结束的时间段可以认为是连续的，这和对象有相似之处。利用 RAII 惯用法可以把特定的对象和资源实例绑定，此时资源的获取和释放与对象的构造和销毁等价，对象的生存期称为资源的生存期。
 RAII 在异常安全和可维护性等方面具有其它方法不可替代的优势，因此是 YSLib 中最主要使用的资源管理惯用法。

@1.5.3 对象所有权：

@1.5.3.1 概述：
对象所有权是对象组（对象的集合）之间的二元关系，简称所有权。
具有所有权的对象组称为所有者对象组（以下简称所有者，记作 O ），另一方称为被托管对象组（以下记作 P ），且满足 O 和 P 的交集为空集。
当 card(O) 或 card(P) 等于 1 时，约定可以使用其中的唯一元素指代集合本身。
 P 是空集的所有权是空所有权。以下若不另外注明，则“所有权”均指非空所有权。
所有权是一对一或一对多的：所有者拥有的所有权是排他的，即任意被托管对象有且仅有一个所有者（集合）；但反之一个所有者可以拥有超过一个被托管对象组的所有权。
所有者的一个所有权被移除，同时另一个对象组获得该所有权而成为对应的所有者的原子过程(atomic procedure) 称为对对应的 P 的所有权的转移。
所有者负责实现所有语义，即被托管对象的可用性（连续的有效性）的控制。其中最基本的是，实现自身被销毁(destroyed) 时，先行实现对应的 P 的释放(disposition) ，以避免资源泄漏或重复释放。

@1.5.3.2 分类：
由语言特性直接支持，无需显式实现的所有权，称为自动的 (automatic) ；除此之外的所有权，称为显式的 (explicit) 。
根据语言实现的类成员和继承特性对应的语义，一个对象对成员对象和子对象拥有所有权。这些所有权称为平凡的。平凡的所有权是自动的。
非平凡的且的自动的所有权通过语言提供的作用域机制（附带栈语义）实现。
如无说明，以下仅讨论非平凡所有权，即被托管对象组通过添加对象的指针（包括智能指针等实现引用语义的对象）的方式产生的所有关系中的所有权。
一对一的所有权关系称为基本的。平凡的所有权是基本的。
一对多的所有权关系称为共享的。引用计数对象是典型的实例。
释放资源前需要进行判断的所有权称为条件所有权，用于实现非特定对象之间（如基于引用计数的智能指针和被引用对象）的所有权。

@1.5.3.3 行为限制：
一旦向对象所有者添加了对象组，就不应在从所有者移除该对象前通过所有者以外的途径访问该对象组（作用于被托管对象组，从所有者对象组的元素移除该对象组的元素的操作除外）。
由于所有权最终会导致对象被所有者释放，因此具有栈语义的自动对象不宜被添加所有权，否则容易被误释放超过一次。若自动对象被添加所有权，则应确保所有者释放该对象之前，手动从所有者移除该对象。

@1.5.3.4 具体的所有语义：
所有语义并不直接体现为操作，而是通过实现中预先定义的策略影响释放行为体现。
一般可以针对特定所有权关系实现特定的释放器或者删除器(deleter) （可以捆绑在所有者的实现中），在释放时执行具体的操作。
通常默认的释放操作是删除(deletion) ，即通过使被托管对象被销毁，其生存期结束确保所有者对此对象的所有权无效（不可用）。

@1.5.3.5 实现：
所有权关系可以通过自定义指针等任意具有引用语义的对象实现。
可以通过不可共享的（例如 private ） std::unique_ptr 的实例等具有复制构造时所有权转移语义的对象进行简单实现。
所有者可以是多个对象（如引用计数等涉及多对象公共状态策略的智能指针），但通常被托管的对象组只含有一个对象。对于含有超过一个被托管的对象的所有权关系，可以分解为多个所有权关系以简化实现。

@1.5.4 存储和其它资源引用：
对象的存储可以通过直接引用对象自身访问。
除此之外，可以通过一些特殊的对象引用存储，可以是其它完整对象的存储，也可能是未初始化的。

@1.5.4.1 引用对象：
运行期程序资源实例可以通过对象的使用进行表示，构成一个引用关系。被直接访问的对象称为引用对象，被用于表示资源的对象（集合）称为被引用对象（集合）。
被引用的资源也可以不是运行期程序资源实例，例如函数或成员。
一个引用关系中，引用对象是被引用对象的引用源，简称源；被引用资源是引用对象的引用目标，简称目标；源指向目标。
目标通常只有一个元素。以下讨论主要涉及此情况，结论对于多个资源实例的情况仍然适用。
对象具有存储，因此资源和存储之间存在一一映射。此时，对象之间的所有权关系即表示对象与资源、资源与资源之间的所有权关系。
关于引用对象在引用存储时可以对被引用的对象进行附加操作，参见 @1.5.3 。
若一个源对目标存在一对多或一对一的所有权，则源对此资源是完全强引用的。
若一个源对目标存在多对多或多对一的所有权，则源对此资源是不完全强引用的。
完全强引用和不完全强引用统称强引用。
任何非强引用的源或引用关系是弱引用的。弱引用说明源完全没有对目标的所有权。
若能通过一个源直接得到使用语言特性（ C++ 引用类型）对目标的访问，则源对此目标是透明的。
任何非透明的源或引用关系是不透明的。
引用关系可以具有修饰符约束，如 const 约束目标不能通过对源的访问进行修改操作。
源可以通过改变自身状态（值）而改变引用关系，例如对源进行赋值操作。
使源的引用目标在明确的引用目标集合内改变（可以确定在迭代后所给的源指向的具体哪一个目标）的操作，称为对源的引用迭代，简称迭代。
若一个源支持迭代，则此源或引用关系是可迭代的。
任何非可迭代的源或引用关系是不可迭代的。
以下分别讨论几类典型的引用源。

@1.5.4.1 迭代器：
关于“迭代器”的概念，参见 ISO/IEC 14882:2003 。
迭代器的引用目标是对象（集合，下同）。
迭代器应是弱引用的、透明的和可迭代的。

@1.5.4.2 内建指针：
 void* 类型指针引用目标是不确定类型的对象；除此之外，内建对象指针的引用目标是对象（集合）；函数指针的引用目标是非成员或静态成员函数；成员指针的引用目标是非静态成员。
内建指针是语言实现通过地址空间模型实现的引用源，其中对象指针支持算术和关系运算。几乎在所有语言实现中都可以认为是所有引用对象中效率最高的。
内建指针是弱引用的：内建指针的生存期和引用目标的生存期无关。
内建指针是透明的：通过 operator* 访问被引用对象。
 void* 类型以及对象指针是可迭代的：通过 operator++ 等实现迭代操作，且可以通过算术运算实现随机迭代，因此是一种特殊的随机迭代器。

@1.5.4.3 智能指针：
智能指针的引用目标是对象或不确定类型的资源（以 void 类型作为目标类型时）。
直接智能指针：强引用且透明的。
间接智能指针：弱引用且不透明的，不能直接访问目标，需要通过转换为透明的直接智能指针等方式，对被引用对象间接地进行访问。
智能指针一般是不可迭代的。但是对于目标中存在多个对象（例如目标是包含多个元素的一个数组）时，可以在内部迭代。
作为指针，智能指针允许为无效状态，此时指针具有空所有权(@1.5.3.1) ，是空的(null) 、不可解引用的(non-dereferencable) 。
智能指针不一定可以比较或进行指针算术运算，但一般存在用来判断有效性的等效成员 operator bool() 和 bool operator!() ，表现的语义同内建指针在相同操作下一致。

@1.5.4.4 句柄：
智能指针的引用目标是对象或不确定类型的资源。
句柄可以是强引用的，例如对资源进行引用计数。
句柄往往是不透明的：它的值不一定被客户程序明确，可以只通过特定的程序接口访问被引用的资源。
句柄是不可迭代的。

@1.5.4.5 实例：
标准库容器的各种迭代器都是典型的迭代器。
 C++2011 标准库的智能指针中， std::unique_ptr 是完全强引用的透明智能指针， std::shared_ptr 是不完全强引用的透明智能指针， std::weak_ptr 是弱引用的不透明智能指针。

@1.6 对象特性和语义抽象：
本节讨论完成非特定功能但在行为和实现方法上具有显著相似点的某几类对象的性质、意义和行为。

@1.6.1 接口类型：
接口类型是特殊的类类型。接口类型是抽象类，不应被实例化。
接口类型中不含状态（成员数据）；有零个、一个或多个抽象实例方法，但不含具体实例方法。
同常见的其它语言（如 Java 和 C# ）通过语言特性直接支持的接口类型不同，此处约定的接口类型有以下需要注意之处：
允许有静态数据域（无论是否是常量）和静态成员方法：注意 C++ 基类的命名空间独立于派生类，不影响实现；
允许声明类型，包括 typedef 名称和类类型：注意在 C++ 中的基类命名空间和派生类命名空间的独立性，以及嵌套类实例不包含外围类实例指针；
允许声明友元；
允许使用访问权限控制：可以包含非 public 成员；
允许空接口被实例化：为了简化接口模板通过宏的实现；注意在 C++ 中，无法把纯虚析构函数的定义放在类的声明内部。

@1.6.2 容器：
容器是在逻辑上包含零个或更多个其它对象的对象。

@1.6.3 循环迭代器：
经过有限次前置 operator++ 或前置 operator-- 操作，可以得到初始值的迭代器。
理想情况下，通过迭代操作（至少包括前置 operator++ 和前置 operator--）获得的所有临时迭代器状态中，有且仅有一个无效状态。

@1.7 对象通信：
以下仅讨论进程内通信，但实际应用场合可能不仅限于本节讨论范围。

@1.7.1 事件：
事件是用户发出的信号在进程中的抽象。
事件本身是即时的，包含发生时间和事件内容两个方面的意义（有时后者又包含前者）。
需要注意，从实现而言，这种即时性是相对的。原因是使事件发生需要时间（具体实现表现为若干个机器的指令周期）。
所以，发生动作时触发事件指紧接动作完成后产生事件在存储器中的映像。例如，“设置控件位置时产生 Move 事件”指紧随试图设置控件位置的后构造 Move 事件的对象（或进入 Move 事件的处理程序等）。这样的行为在逻辑上有确定的顺序。

@1.7.1.1 事件空间：
对于有限的不同种类事件，它们内容可以用整数或枚举类型标识，对应的取值集合称为事件空间。

@1.7.1.2 事件回调：
事件可以在生成同时调用预先设置对应关系（注册）的事件处理器（事件响应函数），即同步回调；也可以事件发生后延迟调用，即异步回调。
事件处理器可以是对应参数列表的非成员函数或静态成员函数、非静态成员函数和函数对象。
复杂的回调要求事件能够被带有状态地进行传递，此时需要使用函数对象。

@1.7.2 简单事件调用：
可以通过把事件本身抽象为具体的类，借用委托（例如函数指针）实现同步回调。

@1.7.3 消息：
为了传递事件或其它运行时信息，需把其中的事件内容包装至某一可传递的数据结构中。使用消息机制解决这个问题。
消息（类型）是为了在应用程序进程内部、应用程序进程之间以及应用程序进程和操作系统之间传递数据的一种具体数据结构。它的实例称为消息（Message）。
使用消息传递事件内容，需要包含消息目的指针、主标识和与其语义相关（具体语义可以取决于主标识，也可以由其它指针域的实际类型决定）的其它参数。除此之外，消息类型中的成员是可定制的。
消息对自身各个数据域保持所有权。因此，指针域使用带所有权的智能指针。
各个域完全相等的消息是相等的。除此之外，指针域不等但其内容相等的消息也视为相等。

@1.7.3.1 消息空间：
所有能够在一个处理单元（例如线程）在该单元生存期被处理的消息集合称为消息空间。
除临时对象外，任意完全相同的消息在一个消息空间中不应该含有超过一个实例。
消息空间的具体实现可以采用队列等抽象数据结构。

@1.8 基本模型：
本节讨论具体的基本特性相关的模型。

@1.8.1 二维输出设备参考坐标系：
视图坐标系。以输出设备相对于用户的最左上角为原点(0, 0) ，横坐标正方向向右，纵坐标正方向向下。
最基本的实例是屏幕坐标系。

@1.8.2 部件坐标系：
相对于输出所在屏幕的屏幕坐标系直接平移得到的坐标系。
注意原点相对于屏幕坐标系的坐标分量可以有负值。

@1.9 组件和界面设计概述：

@1.9.1 UI（User Interface ，用户界面）设计：
为了适应不确定数量的输出设备，中间层 Shell 可以用于实现程序中处理 UI（User Interface ，用户界面）行为。
输出特性依赖于部件坐标系(@1.8.2) 。
用于实现 UI 的 Shell 一般也包括实现相关消息处理。
和 Shell 相对的是 Core ，不直接参与实现 UI 。
 Shell 和 Core 相对独立，以方便移植。
 Shell 本身为单线程/纤程。

@1.9.2 GUI（Graphic UI ，图形用户界面）设计概述：
界面实现使用精简的主动模型-视图-控制器模式，参照窗体-控件模式。
基于性能考虑，底层不实现观察者模式。

@1.9.2.1 构件实体：
相较于典型的窗体-控件模式，图形用户界面控件(controls) 退化为部件(widgets) ，部件退化为组件(components) ，进而分离可视属性，抽象出独立于这些构件的部件特征，细分功能以实现高度可配置性。
 YSLib 本身不提供大量成熟的控件，而是着重提供可供组装为控件的基本图形用户界面类（部件模块类）、部件类、在部件基础上衍生的构件以及部件简单组合的组件。这些用户界面元素(UI elements) 不一定具有消息处理或事件响应的功能，因此可以不是控件；参见 @1.9.2.4 。
控件主要由用户通过组装以上的构件定制。

@1.9.2.1 模型(model) ：
模型表示数据模型(data model) 和业务逻辑(business logic) 。

@1.9.2.2 视图(view) ：
视图用于向用户呈现数据。可以和控制器(@1.7.2.3) 共享界面和输入逻辑。
视图在图形用户界面响应(@1.7.2.5) 中不会修改模型，但可以向控制器提交状态。
部件模块类是基本的视图类。通过派生或修饰这些类可以得到扩展的视图。

@1.9.2.2.1 视图组织：
构件对象和之间的联系结构的整体称为视图组织。
视图组织可以是无环图，称为视图树。一旦存在环路，对视图的某些操作可能导致不确定的行为。

@1.9.2.3 控制器(controller) ：
控制器包含了根据用户在视图中的行为更新模型的逻辑。
模型和视图不能直接修改控制器的状态，但可以提交状态等待控制器自行更新。

@1.9.2.4 组合构件：
可以自定义任意的模型类来组装部件、控件或其它用户界面元素。
但是，并非每一个成分都是必须的。某些成分可能在具体的类的外部实现。
若组合的结果能处理消息或响应事件，同时能够呈现界面数据，那么就是控件。

@1.9.2.5 焦点概述：
焦点在部件容器（称为焦点上下文）中对图形用户界面对象的标识。
控制器根据焦点选择当前操作（通常是输入）作用的对象。
由于在一个焦点上下文中可能包含多个子上下文（参见 @1.9.2.2.1 ），因此可能有多个焦点。
对于视图树而言，通过迭代访问焦点对象可以得到唯一的路径，称为焦点活动路径；其中的焦点称为活动路径焦点。末端的活动路径焦点称为活动焦点，在确定状态下若存在，则是唯一的。

@2 实现概览：
外部库参见 @3 。
编译单元简称单元，是一组包含源代码的文本文件，包含一个源文件（默认后缀名 .cpp ）和若干个头文件，经过预处理后成为翻译单元(translation unit) 。
编译单元可以包含类/结构体等类型，以及 API（Application Programming Interface ，应用程序编程接口）的实现。
对于必要的默认文件，使用 y 作为文件名的起始。
多个编译单元组成一个系统，置于文件系统的同一个目录中。

@2.1 名称实现规则：
名称使用前提约束：参见 @1.4.3 。
使用嵌套命名空间。
一个单元可能有多个命名空间。
一个命名空间可能在多个单元中。
 YSLib 默认显式依赖于库 YCLib 。具体由适配器系统(@2.6) 决定。

@2.1.1 头文件附加准则：
禁止在头文件中使用不具名命名空间(unnamed namespace) ，除非其中仅含 inline 函数和模板或需要和每一个翻译单元独立地相关的对象。
禁止在头文件中使用全局 using 指示符，除非是有意的（例如减少别名个数；需在文档中说明）。

@2.1.2 全局名称：
 YSLib 库的根命名空间为 YSLib ，应置于全局命名空间中，即为 ::YSLib 。
根据平台特性增设全局对象的定义位于 "/Helper/YGlobal" 中。

@2.1.3 命名空间分配：
 YSLib::Components ：组件。
 YSLib::Components::Controls ：控件。
 YSLib::Components::Forms ：窗体应用。
 YSLib::Components::Styles ：样式和界面定制。
 YSLib::Components::Widgets ：部件。
 YSLib::Patterns ：设计模式。
 YSLib::TL ：类型列表(typelist) 操作。
 YSLib::Devices ：设备抽象。
 YSLib::Drawing ：图形处理。
 YSLib::Messaging ：消息机制。
 YSLib::IO ：输入/输出管理。
 YSLib::Shells ：Shell 抽象层。
 YSLib::Text ：文本相关的服务。
 YSLib::Timers ：计时器服务。

@2.1.4 名称引用限制：
除 Adaptor 外， YSLib 命名空间下不直接使用 YSLib 、 std 和 ystdex 以外的根命名空间以及其中的名称；不直接使用 std::tr1 及其中的名称。
不使用除了 main 以外的全局命名空间中的名称。

@2.2 实体实现规则：

@2.2.1 对象准则：
局部对象在声明时同时初始化。
函数内变量尽可能置于最小作用域内——除非效率原因，尽可能使用语句块级对象代替函数级局部对象。
避免在嵌套类中定义被嵌套类的定义，除非能够确保此定义的实现无关性。
有依赖关系的全局对象应置于同一编译单元内。
禁止使用函数返回值初始化全局对象。
除非程序明确为单线程的，禁止使用非 POD(plain-old data) 类型的全局对象。若非必要，用内建 (built-in) 类型代替 POD 结构体全局对象。
多线程程序中，禁止使用非 const 全局对象。

@2.2.2 对象引用和所有权管理：
注意基于非透明引用计数实现的非侵入式智能指针（如 boost::shared_ptr/std::tr1::shared_ptr 以及 C++0x 的 std::shared_ptr ）具有以下固有的缺点：
无法修改引用计数并直接转移所有权，资源实例的生存期依赖于至少一个具体智能指针对象的生存期；
资源实例对智能指针对象的上述依赖性导致智能指针类型入侵客户程序接口；
并非完全的非侵入式实现（例如可能依赖于 enable_shared_from_this 等），可能入侵客户资源实现，导致耦合扩散；
客户程序无法显式指定引用计数操作而造成不必要的性能负担（特别是异步流程中，无法进行基于调用栈的引用计数优化）。
为了克服前三个缺点，可以使用侵入式方案代替，但可能会引起额外的编码复杂度。最后一个缺点所在的场景一般不适合使用引用计数策略（尽管改用侵入式引用计数方案可能减小开销）。
因此 YSLib 仅在必要时使用基于此类智能指针实现的句柄，如跨 Shell 资源传递（包括 Shell 类实例本身）。
对于需要保持所有权但又要避免重复引用计数的开销的情况，使用 std::unique_ptr 。
其它情况下，使用不含所有权的内建指针，以保持客户程序对资源管理的选择自由和灵活性。若没有在注释或文档注明所有权关系，均应视为由客户程序对象具有指针参数指向对象的所有权。
以下所有权关系中，被托管对象类包括派生类。所有者（基类）中 public 继承了 OwnershipTag<_type> ，其中 _type 是被托管对象类型。实例包括：
 Drawing::FontCache 具有 Drawing::Typeface 、 Drawing::FontFile 、 Drawing::FontFamily 的所有权；
 Components::Controls::MenuHost 具有 Components::Controls::Menu 的所有权；
 Text::TextMap 及其派生类 Text::TextFileBuffer 具有 Text::TextBlock 的所有权。
可以使用 HasOwnership<_tOwner, _type> 判断 _tOwner 是否具有 _type 成员的所有权。

@2.3 语言特性扩展支持：
位于 YCLib 或 Core(@2.5) 中。

@2.3.1 接口

@2.3.2 断言

@2.3.3 成员函数简写（代码生成器）

@2.4 类构建：

@2.4.1 命名必须和标识符命名规约(@4) 兼容。

@2.4.2 类型特性：
空结构体类型 EmptyType 。
除了 I 和 A 前缀的类，都不含有纯虚函数。
 Y 前缀类名的类不可被多继承。
命名中按以下列出的顺序确定分类。

@2.4.3 I 前缀类名的类：
接口类型(@1.6.1) 或纯虚类。

@2.4.4 A 前缀类名的类：
抽象类。
成员函数中至少存在一个纯虚函数；不能被实例化。

@2.4.5 S 前缀类名的类：
静态类。
除了类型定义外，应该仅包含静态成员。但编译时不作检查。
可参与多重继承，例如作为特征类(traits class) 。

@2.4.6 Y 前缀类名的类：
一般构件类，包括 YObject 和直接或间接派生自 YObject 的类。
 YObject 具有虚析构函数，因此这些类都是多态类。
基本对象类 YObject ：所有类名以 Y 作前缀（除模板类、非直接实例化类和模块类）的公共基类，为多态类。
提供引用相等判断等公共方法。

@2.4.6.1 基本可数对象类 YCountableObject ：
所有可数的基本对象类的公共基类，通过继承 GMCounter 模板实现静态实例计数器。

@2.4.7 M 前缀类名的类：
模块类。
具有 public 或 protected 的无参数（或所有参数都有默认参数）的构造函数。不一定能够被复制构造（可能显式地被禁止）。
用于提供实现而非规范接口，可定义人本接口成员。
作为 mixin 类的实现：强调可以参与多重继承组合为其它模块类和一般构件类，也包括被参数化（作为模板类型参数）以构建这些类。
当作为非多态类时析构函数应为 protected （除非它的所有派生类都没有在它的基础上扩展域，或都满足析构函数为 protected ），且不可作为类的成员或被实例化。
其它情况下可实例化，但通常仅用于作为类实例的子对象（mixin 实例）。此时应尽可能减少虚表体积，并降低额外的运行时效率开销（例如，不使用引用类型的成员）。

@2.4.8 H 前缀类名的类：
句柄类。
具有间接访问语义的类（例如指针、引用或迭代器）。

@2.4.9 无前缀类名的类：
一般类。
不属于以上有前缀类的类。无其它限制和特性保证。

@2.4.10.1 事件参数基类 EventArgs ：
即 EmptyType 。

@2.4.9 异常类总览：
专用于被 C++ 异常机制捕获的类称为异常类。
异常类不在特定的命名空间中定义。
标准库异常类以外， YSLib 仅使用派生自 YSLib::Exceptions::Exception 异常类。
以下是 YSLib 命名空间中一般的异常类列表：
 YException 单元中：
 Exception ：YSLib 异常基类。
 GeneralEvent ：一般异常事件类。
 LoggedEvent ：记录异常事件类。

@2.5 核心构件系统：
通称 Core ，位于 "/Core" 。
除了核心定义 YSDefinition 以外，主要包含以下几大部分：
核心实用模块 YCoreUtilities ；
平台无关的基础对象 YObject ；
对象计数器 YCounter；
函数对象封装 YFunc ；
异常处理模块 YException ；
基础字符串管理 YString ；
平台无关的基础图形学对象 YGDIBase ；
平台无关的设备抽象层 YDevice ；
事件回调 YEvent ；
消息处理 YMessage ；
标准 Shell 消息列表 YMessageDefinition ；
全局静态类型存储管理 YStatic ；
平台无关的文件处理系统 YFileSystem ；
 Shell 定义 YShell ；
系统资源和应用程序实例抽象 YApplication 等。

@2.5.1 核心实用模块 YCoreUtilities

@2.5.2 平台无关的基础对象 YObject

@2.5.3 对象计数器 YCounter

@2.5.4 函数对象封装 YFunc

@2.5.5 异常处理模块 YException ：
参见 @2.4.9 。

@2.5.6 基础字符串管理 YString
通用字符串抽象以及相关 API 。

@2.5.7 平台无关的基础图形学对象 YGDIBase ：

@2.5.7.1 基本屏幕对象：
用于实现二维输出设备参考坐标系(@1.8.1) 。
 YSLib 默认使用整数分量坐标，类型为 SPos ，绝对值类型为 SDst 。
以此为基础进一步定义了 Point 、 Vec 、 Size 和 Rect 等基本屏幕对象类。

@2.5.8 平台无关的设备抽象层 YDevice ：
位于命名空间 Devices 中。

@2.5.8.1 设备基类：
 GraphicDevice 是输出设备基类。

@2.5.8.2 物理设备：
 Screen 由 GraphicDevice 派生，是二维屏幕的抽象。

@2.5.8.3 虚拟设备：

@2.5.8.3.1 桌面：
桌面是大小和对应输出屏幕相等的窗口（参见 @2.7.1.2.3 ），默认实现为 Components::Desktop 类，除了 YShellDefinition 的前向声明，并非位于 Core 。

@2.5.9 事件回调 YEvent ：
实现事件。
传递事件参数的参数基类是 EventArgs ，可从这个类派生自定义参数类。
除此之外，默认提供以下参数类：
 ScreenPositionEventArgs ，屏幕事件参数类。
 InputEventArgs ，输入事件参数模块类。
 TouchEventArgs ，指针设备输入事件参数类。
 KeyEventArgs ，键盘输入事件参数类。
为了实现和派生上的便利性，包括 EventArgs 以上类实际为结构体类型。
以下用模板定义用于事件处理机制的接口和实现类：
事件处理器接口模板 GIHEvent ，提供两个参数的 operator() 抽象方法。
事件处理器模板 GHEvent ，标准版 HEvent ；基于 Function 和 list 实现。
事件模板 GEvent 为多播版本。（单播版本已被移除。）
事件依赖项模板 GDependencyEvent ；基于 YObject 模块中的类模板 GDependency 实现共享事件以节约空间。
事件包装类 GEventWrapper ；实现基于复杂性考虑，直接使用 GEvent 而不是 GDependencyEvent 的实例。
事件映射表模板 GEventMap ，映射特定的枚举 ID 到 GEventWrapper 模板实例。

@2.5.9.1 标准事件处理实现概述：
仅实现同步事件。
发送事件的实体成为事件源。接收事件的实体称为订阅者。触发事件的实体称为事件的触发器。
注册事件处理器称为事件订阅。

@2.5.9.1.1 单播版本（自 build 204 起被移除）：
添加事件订阅和移除事件订阅复杂度为 O(1) ，同普通的函数指针赋值。调用事件处理器复杂度为 O(1) ，同普通的函数指针调用。

@2.5.9.1.2 多播版本：
本质上是 std::list 实现的函数指针队列。
调用链维持稳定的顺序（和订阅顺序相同）。
对于重复的事件订阅，允许存在多个实例；也可以在添加时指定仅保留一个实例（移至调用链末尾）。
事件处理器调用顺序由调用链决定。
对于调用链长 n ，添加事件订阅、移除事件订阅、调用事件处理器复杂度相对每个事件处理器调用为 O(n) 。
每个事件处理器调用复杂度同单播版本。

@2.5.10 消息处理 YMessage ：

@2.5.10.1 消息的实现：
在命名空间 YSLib::Messaging 中。
消息类型是 Message 类；
消息主标识是唯一的，简称为消息标识，它的类型为 ID（本质上是无符号整数）；
消息队列类型是 MessageQueue 类，在逻辑上是一个优先队列。
库中的 "/Core/ymsgdef.h" 文件预定义了一些消息标识。覆盖这些标识的最小连续区间称为系统消息标识区间。
用户可自定义新的标识（用户自定义消息标识），但不应该和原有定义冲突。由于为宏定义实现，可以使多个标识名对应一个实际的标识，但反之无法实现。
应尽可能保持所有用户自定义消息标识在系统消息标识区间之外。
消息的处理的具体实现取决于用户。

@2.5.10.2 消息队列的实现：
使用多重集作为消息队列的内部容器实现。
第一优先级为 unsigned char 型变量。

@2.5.10.2.1 自 build 216 起过时的特性：
为了适应不支持 std::clock() 的平台，用消息实例构造时的计数标识代替产生时间作为第二优先级。

@2.5.11 标准 Shell 消息列表 YMessageDefinition

@2.5.12 全局静态类型存储管理 YStatic

@2.5.13 平台无关的文件处理系统 YFileSystem

@2.5.14 Shell 定义 YShell

@2.5.15 系统资源和应用程序实例抽象 YApplication

@2.6 适配器(Adaptor) 系统：
位于 "/Adaptor" 。
负责衔接和封装外部库，便于移植。
除了 C++ 标准库以外，其它外部库的名称需要在此声明。
直接使用除 C++ 标准库、 POSIX / GNU C 兼容函数库、 YCLib 库之外的外部库原代码片段所在文件都从属于 Adaptor 。

@2.6.1 外部库关联 YAdaptor ：
默认行为如下：
包含 "ynew.h" ，引入平台设置和存储调试设施(@2.6.2) 。
包含 <ycommon.h> ， YCLib 公用部分(@3.1.1) 。
包含 <CHRLib/chrlib.h> ， CHRLib (@3.1.3.1)。
在 YSLib 命名空间 using 引用必要的名称。

@2.6.2 通用基础设施 YBase ：
不依赖于其它任何头文件。
定义了各种基础平台无关的宏，用于简化代码等。

@2.6.3 内存调试设施 YNew ：
默认包含编译配置、平台支持文件 <platform.h>(@3.2.1) 和通用基础设施(@2.6.2) 。
定义宏 YSL_USE_MEMORY_DEBUG 后（默认 debug 配置在 "config.h" 有此定义）可以使用 "ynew.h" 声明的宏和类进行内存调试。
重载全局 operator new 和 operator delete 可以用于用户程序调试（ YSLib 中默认并不使用）。
 MemoryList 用于跟踪记录已分配的内存块。 debug 配置下默认定义了一个函数内静态对象，用函数 GetDebugMemoryList 取此对象引用获得默认调试内存信息。
可以用宏 ynew 代替 new/new[] ， ydelete 代替 delete ， ydelete_array 代替 delete[] ，配合 GetDebugMemoryList 检测内存泄露以及重复释放错误；但不适于智能指针，因为未使用 ydelete 和 ydelete_array 。

@2.6.4 引用对象 YReference ：
在 "yref.hpp" 中声明智能指针等引用对象类型。
可以包装 Loki 或 std::tr1 指针智能等实现。
 YSLib 早期包装 Loki 指针实现句柄；
 build 208 起包装 C++2011 标准库智能指针实现；
 build 210 开始直接使用 C++2011 标准库智能指针作为句柄。

@2.6.5 初始化逻辑的实现 YShellInitialization

@2.6.6 平台无关的字体缓存库 YFont ：
基本接口平台无关，但可能提供平台相关的扩展接口，实现也是平台相关的，因此在 Adaptor 中。

@2.7 组件和界面系统：
位于 "/UI" 。
包含基本的部件/控件抽象、图形界面中较常用绘图例程以及样式管理。
更基本的图形抽象、绘图/图像处理例程和图像资源管理则来自于 "/Core/YGDIBase" 、 "/Core/YGDI" 和 "/Core/YResource" 。
组件 (Component) 是具有一定相互联系的功能集合单元。
组件类是非抽象类，默认基类为 YComponent ，继承自 YCountableObject，可以引用方式作为参数传递。
组件对图形用户界面对象进行直接支持。包含部件和控件类：
具有基本屏幕输出效果，实现了部件接口 IWidget 的类，称为部件 (Widget) 类；
具有基本屏幕输出效果和公共事件响应能力，实现了接口 IControl 的类，称为控件(Control) 类。
部件仅仅负责 Shell 直接和 UI 相关的部分，默认不包含任何消息处理。
消息应被其从属的 YShell 消息处理过程截获并进行处理。
控件行为由事件机制(@2.7.2) 控制（在运行期加载函数）。其它组件行为原则上直接由 YShell 消息处理过程控制，以避免消息转发带来的开销。
在 YControl 单元中提供最常用的控件实现。

@2.7.1 用于图形用户界面的对象特性：

@2.7.1.1 视图组织：
默认为视图树，其中的节点实现了 IWidget 接口，非叶子节点进一步实现了 IUIBox 接口。
 Desktop 作为默认视图树的默认根节点。

@2.7.1.2 类组织：

@2.7.1.2.1 接口：
 IWidget ：部件接口。
 IUIBox ：固定部件容器接口。
 IContainer ：部件容器接口。相对 IUIBox ，扩展了动态添加和移除部件的能力。
 IControl ：控件接口。
 IPanel ：面板接口。部件容器控件。
 IWindow ：窗口接口。
功能说明和其它描述参见 @2.7 、 @2.7.1.1 、 @2.7.1.3 。

@2.7.1.2.2 继承：
所有公共图形用户界面元素类继承自 Widgets::Visual 基类。
用于实现的类，除了能够直接和组建基类继承为完整的公共图形用户界面对象的类（如 Widgets::Visual 、 Widgets::Widget 、 Controls::Control 等）使用 public 继承，其它都以模块类使用保护继承。

@2.7.1.2.3 主要图形用户界面元素的具体类：
部件是实现了 IWidget 接口的类，是基本的图形用户界面对象类。
组件容器是能够以引用方式在逻辑上包含其它组件的组件。
部件容器是实现了 IUIBox 接口或 IUIContainer 接口（都继承了 IWidget 接口）的类（标准基类为 YUIContainer ），是一般化的组件容器，它能以可视化方式处理其包含的部件（例如顺序显示）。其中 IUIContainer 限制了添加和移除部件的抽象方法。
控件是实现了 IControl 接口（继承 IWidget 接口和 GIFocusRequester<GMFocusResponser> 接口）的类（标准基类为 YControl ），是具有事件响应特性的可视组件，同时也是部件。
面板是实现了 IPanel 接口（继承 IUIContainer 和 IControl 接口）的类，是部件容器，同时也是控件。
窗口是实现了 IWindow 接口（继承 IPanel 接口）的类（标准模块基类为 AWindow 抽象类），是作为一种能在桌面显示的自带缓冲区的部件容器，同时是焦点响应类和焦点请求类。
标准窗口（基类为 Frame ）是具有一般化的部件容器功能的窗口。
窗体（基类为 Form ）是增加了客户区布局管理的标准窗口。
默认组件中，除继承自窗口的组件（基类为 Frame ，缓冲区继承自类 BitmapBuffer ）外，所有部件默认不带显示缓冲区。实际使用时可以用其它类型成员（如 TextRegion ）提供显示缓冲区。

@2.7.1.2.4 辅助模块类：
默认提供基本事件回调模板类，以方便用户实现消息映射和其它间接传递消息的功能。
此外，还提供对默认图形用户界面输入事件的参数类。

@2.7.2 图形用户界面事件：

@2.7.2.1 默认图形用户界面事件：
即 YControl 单元中定义的标准控件事件。
事件依赖项仅对非映射事件使用。相关类参见 @2.5.9 。
默认图形用户界面事件使用 Core::YEvent 等单元实现，和 YControl 单元和 YGUI 单元相关。
在 YControl 单元中的枚举类型 typedef 名称 VisualEvent 定义了标准控件事件空间，其中定义了标准控件事件，包含视图变更事件、图形用户界面输入事件和焦点事件。
图形用户界面输入事件包含基本图形用户界面输入事件和扩展图形用户界面输入事件，参见 @2.7.2.1.2 。。
事件参数类型由 RoutedEventArgs 派生的称为路由事件。
基本图形用户界面输入事件是路由事件，参见 @2.7.2.1.2 。

@2.7.2.1.1 视图变更事件：
包括 Move 、 Resize 事件等。
事件发送对象类型 IControl ，参数类型 EventArgs ，事件类型为 HVisualEvent 。
在试图变更视图时触发。
需要注意，不包括必然的视图改变后置条件。即使设置控件视图操作的结果与未设置时相同，仍触发事件。

@2.7.2.1.1.1 Move 事件：
设置控件位置后触发。

@2.7.2.1.1.2 Resize 事件：
设置控件大小后触发。

@2.7.2.1.1.3 Paint 事件：
绘制控件（调用 Draw 方法）后触发。
默认实现中， Control 类在 Draw 中调用 DrawControl 后调用 Paint 事件。
AWindow 类会在绘制完毕，设置更新状态之前调用 Paint 事件。
即对于任何控件的默认实现，在直接容器刷新时实际绘制中，更新之前发生 Paint 调用。
自定义类可以通过重写 Draw 方法改变这一行为，但一般不必要。

@2.7.2.1.2 图形用户界面输入事件：
基本用户界面输入事件是图形用户界面输入直接引起的事件，分为基本按键输入事件和基本指针设备（屏幕光标定位设备）输入事件。
基本按键输入事件包含 KeyUp 、 KeyDown 和 KeyHeld 。
基本指针设备输入事件包含 TouchUp 、 TouchDown 和 TouchHeld 。
扩展图形用户界面输入事件有以下几类：复合事件（包括 KeyPress 、 Click 、TouchMove ）、边界事件（包括 Enter 和 Leave ，参见 @2.7.2.1.4 ）等。
路由事件处理具体由 YGUI 单元中的 YGUIShell 实现（目前仅实现 TouchUp 、 TouchDown 和 TouchHeld ）。
包括按键输入事件 KeyUp 、 KeyDown 、 KeyHeld 和 KeyPress；指针设备（屏幕光标定位设备）接触事件 TouchUp 、TouchDown 、 TouchHeld 、 TouchMove 和 Click 。
触发过程：由 YGlobal 等单元完成平台相关的用户输入信号捕获并向 YGUI 单元的 YGUIShell 类传递，后者处理后生成对应输入事件。
当用户按键时，触发 KeyDown 事件；持续时触发 KeyHeld 事件；结束时依次触发 KeyPress 和 KeyUp 事件。
当用户使用指针设备（包括触摸屏）输入时，触发 TouchDown 事件；持续时触发 TouchHeld 事件；持续且移动时可触发 TouchMove 事件；结束时依次触发 Click 和 TouchUp 事件。
在 YControl 单元及其中的控件类 Control 中定义了主要处理程序。
 Control 默认使用成员函数处理 TouchDown 事件，调用本类成员函数 RequestFocus(...) 向容器请求焦点。若请求成功，则默认当前控件以外的控件失去焦点（触发 LostFocus 事件），之后当前控件获得焦点（触发 GotFocus 事件）。
指针设备相关事件中，参数包含了相对于控件的坐标。
最近操作的全局（相对于屏幕的）坐标保存于全局变量 ControlLocation 中。
拖放操作依赖的最近全局坐标保存于全局变量 LastControlLocation 中。

@2.7.2.1.3 焦点事件：
包括 GotFocus 和 LostFocus 事件。
触发条件参见 @2.7.4 。
功能概述参见 @1.9.2.5 。

@2.7.2.1.4 边界事件：
包括 Enter 和 Leave 事件。
指针设备作用于 Control 派生的控件，触发 TouchDown 事件之前判断输入焦点时触发 Enter 事件；触发 TouchHeld 同时移动指针设备出入控件边界可触发 Leave 和 Enter 事件； TouchUp 事件触发后触发 Leave 事件。

@2.7.2.1.3 公用和扩展事件处理程序：
 YControl 单元中定义了部分非成员函数公用事件处理器。
 OnKeyHeld 使用 RepeatHeld 产生有延迟的连续按键输入。
 OnTouchHeld 是 Control 默认加载的 TouchHeld 事件处理器，在其中实现记录坐标偏移（用于拖放）或触发 TouchMove 事件。
 OnTouchMove 可结合 OnTouchHeld 用于处理 TouchMove 事件实现重复触发 TouchDown 事件。
 OnTouchMove_Dragging 可结合 OnTouchHeld 实现控件拖曳。

@2.7.2.1.4 默认实现细节：
默认的事件处理器不适用虚函数，以免在基类添加事件后，在派生类重复添加事件响应。
默认的事件处理器可以是 lambda 表达式。
在派生类定义的和基类同名的事件响应函数（函数名以 On 起始）会被隐藏而不是覆盖基类的事件响应函数，是非 public 方法。一般应该避免在类实现外部调用响应函数。
 Control 类在构造函数中添加了 GotFocus 、 LostFocus 、 TouchDown 、 TouchHeld 的事件处理器，且除了 TouchHeld 外，都是 Control 的成员函数。

@2.7.2.2 自定义图形用户界面事件：
和 YGUI 等单元相关的自定义事件，一般使用 YEvent 等单元实现。可以使用 GDependencyEvent 节约存储。

@2.7.2.3 图形用户界面事件组映射：
事件组映射通过 std::function 等返回被映射事件的参数，并传递给特定的用于映射的事件处理器。
 Control 类使用 BoundControlPtr 取按键-指针设备输入事件映射的控件，默认实现使用 GetBoundControlPtr 。

@2.7.3 图形用户界面输入控制器：
由于设备的特点，图形用户界面输入相对于输出而言是容易规格化的。因此在 YControl 单元中定义了一些默认图形用户界面输入事件（参见 @2.7.2.1 ），且在 YGUI 单元中定义了若干函数/类用于处理默认图形用户界面输入事件。
默认实现输入输出消息及输入状态寄存的控制器类是 YGUIShell ，同时是输入事件的触发器。
在默认的控件实现中，使用上述的默认图形用户界面输入处理程序作为调度控件行为的控制器。在自定义控件实现中，可以另行定义控制器。

@2.7.4 用于图形用户界面的焦点特性：
概述：参见 @1.9.2.5 。

@2.7.4.1 焦点污染：
焦点默认和请求/响应双方相关，而和其它对象无关。即 RequestFocus(...) 函数应该只改变主调对象及其响应对象中描述焦点的状态域，而不产生副作用。
可以在 GotFocus 和 LostFocus 的响应函数中添加相关代码改变这一特性，但会使主调对象和其它对象产生额外的关联。这种关联不符合焦点本身的语义，且难以调试，如非必要，应该避免。

@2.7.4.2 焦点请求链：
在排除 @2.7.4.1 中叙述的副作用的情况下，可以认为不同对象的 RequestFocus(...) 的调用是顺序无关的，可以任意调度。
使用 YGUI 单元声明的函数 void RequestFocusCascade(Components::Controls::IControl&) 可以实现由 IControl 对象自下向上的嵌套容器焦点申请。注意，会以相同的顺序触发 GotFocus 事件。

@2.7.4.3 默认实现相关的定义：
具有焦点响应能力（即储存了关于集中焦点于特定的子对象的状态）的类称为焦点响应类。
实现 GIFocusRequester 模板接口的类具有焦点请求能力（即能够从焦点响应类中获取焦点），称为焦点请求类。

@2.7.4.4 默认实现综述：
默认通过继承 MSimpleFocusResponser 类或 GMFocusResponser 类模板实例实现焦点响应类，继承并实现 AFocusRequester 抽象类实现焦点请求类。
 IUIBox 接口要求实现者需要响应焦点的请求和释放操作。
典型的实现方式是控件类以通过继承 GMFocusResponser 类模板的实例成为焦点响应类。这种方式会储存一个子焦点容器指针的集合，对于具有确定的子对象的控件而言效率较低，因此图形用户界面默认实现中并不都采用此方法。
在图形用户界面实现中独立保存额外的控件独立焦点指针，捕获自由状态的控件指针并判断是否能够据此调用 KeyPress 或 Click 事件。
为了支持拖放操作，指针索引控件时，按位置判断作用的控件并根据上述独立焦点指针和状态变量判断附加操作，而不通过上述的通用焦点。

@2.7.4.5 实例：
 Desktop 是 IControl 的焦点响应类。
 Frame 和 Form 同时是 IControl 的焦点响应类和对于 Desktop 焦点请求类。

@2.7.5 默认图形用户界面响应流程：

@2.7.5.1 概述：
终端用户进行图形用户界面输入；
控制器捕获图形用户界面输入产生图形用户界面输入事件；
视图或控制器处理图形用户界面输入事件，必要时呈递至模型，并向视图同步模型数据；
视图向用户呈现图形用户界面数据。
以上流程在组合构件中可以有相应细节上的变化，但步骤之间的顺序不变。

@2.7.5.2 默认图形用户界面渲染逻辑：
使用视图的方法对缓冲区进行渲染。具体内容由视图的实现决定。

@2.7.5.3 默认图形用户界面刷新逻辑：
部件向容器请求得到绘制的过程称为刷新。缓冲区内的图形信息复制到其它缓冲区的过程称为更新。
部件实例存储背景重绘状态；带缓冲区的部件（包括窗口和桌面）实例存储刷新状态和更新状态。这些状态用 bool 类型变量表示。
背景重绘状态值为 true 时表示背景重绘已经结束，无需再次重绘；刷新状态和更新状态值为 true 时表示准备就绪并需要进行对应操作。
成员方法 DrawContents() 作为一般的缓冲区图形内容绘制接口（可能调用子对象的 Refresh() ）。
成员方法 DrawControl() 是控件的默认绘制接口。
成员方法 Invalidate(const Rect&) 在保证本层缓冲区（若存在）绘制完毕后向最近的上层缓冲区（若存在）传递相对于部件的正则矩形区域无效状态，以便被重绘。对于自带缓冲区的部件，完成绘制后，设置区域无效状态为 false ，更新状态为 true。
 Widgets::Invalidate(IWidget&) 是使用部件自身区域为参数调用 Invalidate 的人本接口。
成员方法 Refresh() 是部件的状态无关的刷新接口，对于部件即绘制接口；对于自带缓冲区的控件，检查刷新状态后，直接或间接调用 Invalidate() 在缓冲区无效化自身区域，调用 DrawControl() 直接绘制控件界面。 
更新状态为 true 或上层容器（若存在）的刷新状态为 true 时，成员方法 Update() 查询区域重绘状态，若区域重绘状态为 true 且上层缓冲区存在，更新至上层缓冲区（对于桌面而言是屏幕），并设置对应容器的更新状态为 true 。
在 Shell 处理函数中可以在输入分支后添加桌面对象的 Refresh() 或 Update() ，按需要更新最近经过重绘但未经过更新的图形用户界面对象。

@2.7.6 图形用户界面特性抽象

@2.7.6.1 图形用户界面样式 YStyle

@2.7.6.2 图形用户界面焦点特性 YFocus

@2.7.6.3 平台无关的图形用户界面 YGUI

@2.7.7 组件

@2.7.7.1 平台无关的 Shell 组件 YComponent

@2.7.7.2 控制台 YComponent

@2.7.8 默认部件

@2.7.8.1 样式无关的图形用户界面部件 YWidget ：
主要类型：
 IWidget 接口；
 Visual 类；
 Widget 类。

@2.7.8.2 样式无关的图形用户界面容器 YUIContainer ：
主要类型：
 IUIBox 接口；
 IUIContainer 接口；
 MUIContainer 类。

@2.7.8.3 样式无关的用户界面标签 YLabel ：
主要类型：
 Label 类。

@2.7.9 默认控件

@2.7.9.1 样式无关的控件 YControl ：
主要类型：
 IControl 接口；
 Control 类。

@2.7.9.2 样式无关的图形用户界面面板 YPanel ：
主要类型：
 IPanel 接口；
 Panel 类。

@2.7.9.3 样式无关的图形用户界面窗口 YWindow ：
主要类型：
 IWindow 接口；
 AWindow 类；
 AFrame 类；
 Frame 类。

@2.7.9.4 桌面 YDesktop ：
组件命名空间 Components 中的 Desktop 类是桌面的抽象，自带显示缓冲区，和 Screen 关联，负责把窗体和其它桌面对象输出至屏幕。

@2.7.10 扩展部件

@2.7.11 扩展控件

@2.8 服务系统：
位于 "/Service" 。
对以上组成部分提供内部和外部的常用功能的实现与封装。
提供了附属的类型和函数供用户程序使用。

@2.8.1 计时器服务 YTimer

@2.8.2 图形库

@2.8.2.1 平台无关的图形设备接口 YGDI

@2.8.2.2 平台无关的二维图形光栅化 YDraw

@2.8.2.3 平台无关的图像块操作 YBlit

@2.8.3 基础文本显示 YText ：
通用的字符/字符串光栅化处理。字符串本身的逻辑处理在 "/Core/YString" 中，而不在此处。

@2.8.4 应用程序资源管理模块 YResource

@2.8.5 文件抽象

@2.8.5.1 平台无关的文件抽象 YFile

@2.8.5.2 平台无关的文本文件抽象 YFile_(Text)

@2.8.6 扩展服务

@2.8.6.1文本管理类 TextManager

@2.9 助手(Helper) 系统：
位于 "/Helper" 。
与以上系统不同，这个系统是平台相关的，一般由库用户自行配置。
 YGlobal 是不可缺少的，它封装了 main 函数和必要的全局变量。
 Core 的头文件不包含 Helper 的头文件，但其它部分的头文件以及所有实现的源文件可能包含 YGlobal 单元头文件 "yglobal.h" 。
 "yhelper.h" 中含有可能被 YSLib 本体(@2.10) 使用的默认接口，包括类名 Global 和 InputContext ， 以及其中 Global 的若干成员方法。其它由平台实现定义。

@2.9.1 YGlobal 单元：
平台相关的全局对象和函数定义。除了以下接口，其它都是不确定的：
const SDst MainScreenWidth, MainScreenHeight;

unspecified_class_type&
FetchGlobalInstance() ynothrow;

void
Idle();

bool
InitConsole(Devices::Screen&, Drawing::PixelType, Drawing::PixelType);

void
ShowFatalError(const char*);

FontCache&
FetchDefaultFontCache();

Devices::Screen&
FetchDefaultScreen();

这里 FetchGlobalInstance 返回类型为平台相关的应用程序类的引用。
 YSLib 在 Helper 以外（本体和 Adaptor）不依赖这些接口以外的特性。

@2.10 本体：
以上 YSLib 构成单元中，除了 Adaptor 和 Helper 以外的部分的总称。
其中 Adaptor 的改变很可能导致整个本体中的很一大部分翻译单元的重新编译。
因此除非是用来实现基本功能的外部的库，新增的平台相关的部分应尽量放在 Helper 而不是 Adaptor 中。
本体的文件只依赖于标准库头文件、 YCLib 或 YSLib 的头文件。
 YSLib 非本体（即 Adaptor 和 Helper ）的头文件除以上外还可能依赖于其它头文件，例如支持环境的平台相关的运行时库。

@2.10.1 Adaptor 和本体文件的源代码依赖性：
源文件(.cpp) 可能依赖于任何 YCLib 、 YSLib 或标准库头文件。

@2.10.1.1 C 标准库的 C++ 标准库版本头文件依赖项：
 "ymsg.h" 包含 <ctime> 。其余不在本体显式包含。

@2.10.1.2 不在本体中显式包含，需要在 "ycont.h" 包含或提供替代品的 C++ 标准库依赖项：
 <array> 、 <deque> 、 <forward_list> 、 <list> 、 <map> 、 <queue> 、 <set> 、 <stack> 、 <string> 、 <unordered_map> 、 <unordered_set> 和  <vector>。
例外：同时需要使用容器和限定标准库容器时，目前仅有一例：
 "yexcept.h" 包含 <string> （鉴于重用标准库异常需要的参数类型 std::string 不一定是 "ycont.h" 配置的类型）。

@2.10.1.3 不在本体的头文件中显式包含，需要在除了 "ycont.h" 的 Adaptor 的头文件直接或间接包含的 C++ 标准库依赖项：
 <algorithm> 、 <new> 和 <utility> 。

@2.10.1.4 不在本体或 Adaptor 的头文件中显式包含的 C++ 标准库依赖项：
基于性能、兼容性或其它因素考虑，Adaptor 和本体不直接使用以下头文件（但 Adaptor 可能会间接依赖）：
<fstream> 、 <iomanip> 、 <ios> 、 <iosfwd>  、 <iostream> 、 <istream> 、 <locale>、 <ostream> 、 <sstream> 、 <streambuf> 和 <strstream> 。

@2.10.1.5 本体的头文件中显式包含的 C++ 标准库依赖项：
<exception> 、 <functional> 、 <iterator> 、 <stdexcept> 和 <typeinfo> 。

@2.10.1.6 本体的头文件中未限定（可能会在将来版本显式包含）的 C++ 标准库依赖项：
 <complex>  、 <bitset> 、 <limits> 、 <numeric> 、 <memory> 和 <valarray> 。

@2.10.2 本体内部头文件依赖性：
 Core 的头文件仅包含 Adaptor 或 Core 的头文件，或 "yglobal.h" 。
实现源文件依赖于同名头文件，应显式包含该头文件，不应重复包含此头文件已经包含的其它头文件。
在 Core 中，以下依赖关系对于头文件包含是确定的：
除了 "ysdef.h" 外都依赖于 "ysdef.h"；
 "yobject.h" 依赖于 "ycutil.h" 、 "yexcept.h" 和 "ycounter.hpp" ；
 "ystring.h" 、 "ymsg.h" 依赖于 "yobject.h" ；
 "yevt.hpp" 依赖于 "yobject.h" 和 "yfunc.h" ；
 "ymsgdef.h" 依赖于 "ymsg.h" ；
 "yshell.h" 依赖于 "ymsgdef.h" ；
 "yfilesys.h" 依赖于 "ystring.h"；
 "yapp.h" 依赖于 "yfilesys.h" 和 "yshell.h" 。
在 Service 中，以下依赖关系对于头文件包含是确定的：
 "yblit.h" 、 "ydraw.h" 和 "ygdi.h" 依赖于 Core 的 "ygdibase.h" ；
 "yblit.h" 依赖于 Core 的 "ycutil.h" ；
 "ygdi.h" 依赖于 Adaptor 的 "yfont.h" ；
 "ytext.h" 依赖于 "ygdi.h" 、 "yftext.h" 和 Core 的 "ystring.h" 。
在 UI 中，以下依赖关系对于头文件包含是确定的：
 "ycomp.h" 依赖于 Core 的 "yshell.h"；
 "ystyle.h" 和 "ytext.h" 依赖于 Service 的 "ygdi.h" ；
 "ystyle.h" 和 "ywidget.h" 依赖于 "ycomp.h" ；
 "ycontrol.h" 和 "yuicont.h" 依赖于 "ywidget.h" ；
 "ygui.h" 依赖于 "ycontrol.h" 和 "ystyle.h" ；
 "ymenu.h" 依赖于 "ygui.h" ；
 "ywindow.h" 和 "uicontx.h" 依赖于 "ycontrol.h" 和 "yuicont.h" 。
在整个 YSLib 头文件中根据以上确定的依赖关系，包含尽可能少的头文件。

@3 程序部署和配置：

@3.1 支持库概述：
目前仅使用静态链接库。

@3.1.1 基础库：
平台隔离用库 YCLib 。
包含平台相关的 API 包装和若干平台无关的独立子库（按头文件路径划分，参见 @3.1.3.1 ）。

@3.1.1.1 全局命名空间：
 ystdex ：从 std 直接扩充的平台无关的实用程序。
 platform ：平台中立：接口平台无关但实现平台相关的实用程序。
 platform_ex ：接口和实现都平台相关的实用程序。
 CHRLib ：子库 CHRLib 的命名空间。

@3.1.2 通用库：

@3.1.2.1
 build 207 前使用 Loki 库的智能指针实现句柄。

@3.1.3 专用库：

@3.1.3.1 包含于 YCLib 中的子库：
字符串内码支持库 CHRLib 。

@3.1.3.2
字体输出使用 FreeType2 实现矢量字体光栅化支持。

@3.1.3.2.1 FreeType2 库版本：
 build 185 前：
头文件版本：2.3.12 ；
库文件版本：在 VNDS 源代码中提取的 2.3.6 。
 build 185 起：
头文件版本：2.4.4 ；
库文件版本：使用 devkitPro 自行编译的对应版本， modules.cfg 配置包含以下行：
FONT_MODULES += truetype
FONT_MODULES += sfnt
HINTING_MODULES += autofit
HINTING_MODULES += pshinter
RASTER_MODULES += smooth
RASTER_MODULES += smooth
AUX_MODULES += psnames
BASE_EXTENSIONS += ftbitmap.c
BASE_EXTENSIONS += ftglyph.c
并使用 -O3 优化。
 build 223 rev 31 起：
头文件版本 2.4.5 ；
库文件版本：使用 devkitPro 自行编译的对应版本， modules.cfg 配置追加行：
BASE_EXTENSIONS += ftbbox.c
BASE_EXTENSIONS += ftstroke.c
BASE_EXTENSIONS += ftsynth.c
其它配置不变。
 build 224 rev 34 起：
使用 2.4.4 的 /src/cache 源文件代替 2.4.5 对应部分并重新编译库文件，以修正不明原因的 FontCache::GetAscender 的结果错误。

@3.1.3.3
图形库：修正的 Anti-Grain Geometry 库 V2.4 。

@3.2 平台文件：
引入平台相关特性。

@3.2.1 <platform.h> ：
定义了必要的平台支持。

@3.2.2 <api.h> ：
定义了扩展的平台 API 。

@3.3 库文件基础结构：
平台设置在 <platform.h>(@3.2.1) 中。
任何 YSLib 头文件，除了 "/Adaptor/" 路径下的文件以及仅包含宏定义的文件外，都直接或间接地包含 "/Core/ysdef.h" 文件。
所有外部链接库为静态库。除了 YCLib 外，对外部库未经过封装的使用仅在 Adaptor 中。这样有利于以子库为单位的移植。

@4 标识符命名规约(naming convention) ：
以下是 YSLib 风格标识符的命名规则和约定。

@4.1
通用指引：

@4.1.1 原则：
接口一致性：相同接口的命名风格应该保持一致。
上下文一致性：尽可能保持上下文命名风格的类似性。
推论：在完善的设计中，若在一个代码片段中存在不同风格的代码，则这些代码不属于同一套接口。
注意：需要存在多套接口的情况下，可能会隐藏潜在的接口设计的不完善性。

@4.1.2 基本例外：
类的 private 成员、函数作用域（注意不包括属于函数声明作用域的参数列表）和无名命名空间中的名称可以不受本规约限制。
经过约定的全局对象名称可以不受本规约限制。

@4.1.3 拼写和构词原则：
基于兼容性考虑，不使用基本字符集（对于本项目即 ASCII ）以外的 Unicode 字符。
以美式英语作为命名标识符的基本自然语言参考。
若不使用以下构词原则或例外，至少应该在原始声明或定义处注释。

@4.1.3.1 基本构词原则：

@4.1.3.1.1 缩略词：
一般除了习惯（例如使用 GUI 表示 Graphic User Interface ），不构造新缩略词。

@4.1.3.1.1.1
被缩写词大小写不改变。
如“GUI”缩写后不作“Gui”。

@4.1.3.1.2 非缩略词和一般词组：
词与词之间需有 "_" 分隔符或大小写不同以示区分。除了 @4.1.3.1.3 中的情况外，通常使用后者。
单词的首字母大写，其它字母保持原形式（通常为小写）不变。
多个单词连用，保持首字母大写，省略其中空格。
这里的单词应该是自然语言中较广泛使用的单词，若存在多种拼写方法，使用较常见形式，特别是语言标准中已经有定义的概念（如使用“adaptor”而不是“adapter”）。

@4.1.3.1.3 专有名词例外：
对于某些专有名词不受以上限制（仍然受语言实现字符集限制）。
例如“GB”（“国标”的汉语拼音缩写）。

$4.1.3.1.4 临时性例外：
例如兼容性考虑的类型名可以全部大写。应注释说明。

@4.1.3.2 框架级名称：
对于公开的可能具有二进制互操作性的接口名称（符号），无论是类名、模板名或函数名，无论是否是成员，都应该使用大写字母起始的名称。
其它名称无此限制，但应避免非框架级名称与之混淆，例如可以使用 C++ 标准库兼容构词方法(@4.1.3.3) 。
（宏名是预处理符号而不是符号，不适合此命名约定。）

@4.1.3.3 非框架级通用名称：
使用以下的 C++ 标准库兼容构词方法。
使用标准库或类似标准库命名风格的库（如 Boost ）时，对应成员使用库的命名风格，以便保持模板内部名称的兼容性和适当的上下文一致性(@4.1.1) 。
注意对于如“valarray”这样的名称，为单词（非专有名词）而不是词组。因此“ValArray”不是“valarray”对应的 YSLib 风格名称。由 @4.1.3.1.2 ，只能保持原文，或者使用同义词组按 @4.1.3.1.2 所述方法得到的“ValueArray”代替。

@4.1.3.4 简单非框架级名称：
在不致混淆的情况下，单字母等（可能是在其它情况下的简单前缀）可以直接作为约束变量（哑变量，如循环变量）或形式参数名称。
下划线和数字组合的名称用于特定模式的参数。

@4.1.3.5 前缀命名法：
慎用前缀。

@4.1.3.5.1
不使用小写字母起始的驼峰命名法，以免和可能使用的习惯匈牙利命名法的名称(@4.1.3.5.3) 混淆。

@4.1.3.5.2
在有限的类型或模板参数命名场合需要使用变形的系统匈牙利命名法，如 @4.3.5.2 。

@4.1.3.5.3
除了类的 public 成员外，对象命名可以使用习惯匈牙利命名法。

@4.1.3.5.4
起始两个大写字母，之后紧接小写字母的类型（此上下文包含参数化类型，下同）标识符，第一个字符会被作为类型前缀。

@4.1.3.5.5
少数特例(@4.3.5.2) 中，出现在类型标识符起始则被视为既定的类型前缀组合。
一般应避免出现起始两个大写字母，之后紧接小写字母的非前缀标识符，以免混淆。

@4.1.4
在同一作用域中可以使用同一名称表示类型和对象。
（此时引用类型名须使用命名空间限定，否则无法正确编译。）

@4.1.5
语义：函数名以谓语动词（不一定是原型）起始。
成员函数名以动词起始，其它成员不使用谓语动词起始，以示区别。

@4.1.5.1
例外：参见 @4.1.3.1.3 ，如 C/C++ 标准库扩展函数。
为保持风格一致，不使用以上命名规约。

@4.1.6
保留标识符：
一般不应被用户程序使用。

@4.1.6.1
参见 @1.4.3.1.3 的名称限制。

@4.1.6.2
以 "_y" 起始的标识符保留给 YSLib 库内部实现使用。

@4.1.6.3
以 "INCLUDED_" 起始的标识符专用于头文件包含标识。

@4.1.6.4
以下前缀保留给的标识符保留给 YSLib 模板参数使用：
 "_b" ：布尔类型参数；
 "_p" ：指针类型参数；
 "_f" ：函数（仿函数）类型参数；
 "_i" ：接口（纯虚类）类型参数；
 "_t" ：其它类型参数；
 "_g" ：泛型类型（模板）参数；
 "_gi" ：泛型接口（纯虚类模板）参数；
 "_gf" ：泛型函数（仿函数模板）参数；
 "_v" ：其它非类型参数（值参数）。

@4.1.7 惯用函数命名：

@4.1.7.1 原语(primitive) ：
动词原型表示的具有合理自然语义的操作，通常对于用户程序来说是原子的(atomic) ，包括：
 Activate ：激活（设置激活状态）。
 Clear ：清除（置参数的主要内容为特定状态；一般置为初始状态）。
 Close ：关闭（释放资源，取消资源使用状态）。
 Copy ：复制（按指定对象构造相等的新对象）。
 Deactivate ：取消（取消激活状态）。
 Delete ：删除（销毁参数指定的对象）。
 Draw ：绘制（光栅化自身或目标对象）。
 Flush ：刷新（刷新对象状态，完成刷新后应保持指定目标和自身同步）。
 Merge ：合并（按大于一个非特定类型对象的引用或值参数构造包含所有参数值的对象）。
 Open ：打开（获得资源，设置资源使用状态）。
 Paint ：绘制（按特定条件完成自身或目标对象的各个组成部分的光栅化）。
 Print ：打印（以特定方式输出）。
 Refresh ：刷新（刷新对象状态，完成刷新后应保持自身和由自身状态决定的目标同步）。
 Reset ：复位（置参数的值为默认状态；一般置为初始状态）。
 Release ：释放（参数作为对象或对象引用）。
 Swap ：交换（参数作为对象或对象引用）。
 Update ：更新（完成参数的特定同步操作）。

@4.1.7.2 模式(schema) ：
具有一定规则的名称组合方式表达同类含义（操作名称为非空字符串；默认为动词原型；可以是原语(@4.1.7.1) ），包括：
 *From ：操作名称起始，第一参数指定源的函数。
 *Ptr ：指针。
 *Ref ：引用。
 *To ：操作名称起始，第一参数指定目标的函数。
 Be*With ：* 为操作名称过去分词（被动语态）；按参数完成特定操作达成特定状态。
 Get* ： * 为目标名称；取特定目标；包括成员读访问器：取对应名称的成员。
 Is* ： * 为目标名称；谓词：计算目标状态，返回类型为 bool 的结果。
 Set* ： * 为目标名称；取特定目标；包括成员写访问器：设置对应名称的成员的值。
 On* ： * 为描述事件及事件响应目标的名称；事件处理器。

@4.2
宏名:

@4.2.1
默认使用大写字母。用其它标识符构造的宏以及特殊宏除外。

@4.2.2
特殊宏。

@4.2.2.1
实现语言功能，如interface等。

@4.2.2.2
代码生成器：用宏展开为一段声明或定义的代码。

@4.2.3
 YSLib 保留宏以 "YSL" 起始。

@4.3
类型名：

@4.3.1
定长整型：全局命名空间中的类型，以前缀和字长组合的形式以明确整型所占的空间。前缀 s 表示有符号整数，前缀 u 表示无符号整数。

@4.3.2
通用类型：非全局命名空间中的类型，小写字母，以 "_t" 作为后缀。

@4.3.3
聚集(aggregate) 类型：数组或容器类型，用不少于2个大写字母和后缀 "s" 组成。

@4.3.4
通用模板类：小写字母，词之间以 "_" 分隔。

@4.3.5
保留类型前缀（关于类型前缀，详细参见 @4.1.2.2 和 @2.4 ）：

@4.3.5.1
全局专有模板类前缀 G(Global Generics) 。可和其它前缀共用。

@4.3.5.2 类型特性划分：
部分使用系统匈牙利命名法。以下前缀适用于 struct 和 class 类型。
非类型参数化的类型前缀（即除了 G 以外的前缀）至多使用两个。
类型特性参见 @2.4 。

@4.3.5.2.1
接口（纯虚类）前缀 I(Interface) 。
对应的接口模板前缀 GI 。

@4.3.5.2.2
包含默认实现语义的虚函数的非严格接口（实际为抽象类）在此也作为接口处理。

@4.3.5.2.3
抽象类前缀 A(Abstract) 。
对应的接口模板前缀 GA 。

@4.3.5.2.4
静态类前缀 S(Static) 。

@4.3.5.2.5
一般构件类前缀 Y(YSLib Class) 。

@4.3.5.2.6
模块类前缀 M(Module) 。

@4.3.5.2.7
句柄类前缀 H(Handle) 。

@4.5
标号：同通用模板类。

@4.5
函数名：

@4.5.1
非成员函数：
以命名空间区分，长度不少于2 。

@4.5.2
成员函数：
除 @4.5.1 限制外， public 函数首字母须大写。

@4.5.2.1
 "Get" 和 "Set" 起始的成员一定是成员函数；不一定为类的访问器，但须符合访问器的一般语义。

@4.5.2.2
一般不使用缩写，除非有特殊含义。

@4.5.2.2.1
 "N" 表示索引或总数。

@4.6.常量和变量：

@4.6.1
常量首字母大写，除非是局部（函数体或以下级别）的临时性常量。

@4.6.2
静态 public 成员首字母大写。

@4.6.3
同质聚合类型变量以一个小写字母起始，第二个字母起若干连续字符为大写字母，之后接小写字母或数字，后缀 "s" 。

@4.6.4
哑变量
不超过2个小写字母组成。

@4.6.5
其它变量
不限制。一般同标号。

@5 一般实现导引：
自定义应用程序 Shell 类，继承 YShell 类并产生实例。
完成自定义 Shell 类的消息处理过程。一般把多个处理过程的响应封装为单一函数。
对于支持实现对应 Shell 的窗口封装为窗体（Form）类（一般继承自 Frame 类），在该自定义类中添加所需的图形用户界面部件的定义，并实现界面效果。
在响应 SM_ACTIVATED 的处理过程中添加需要初始化的资源或子 Shell ，在 SM_DEACTIVATED 的处理过程中添加退出程序或转移线程控制权的指令。
在响应输入等事件消息的处理过程中添加对应的代码。

*/
////

