// YSLib -> Designation by Franksoft 2009 - 2010
// CodePage = UTF-8;
// CTime = 2009-12-02 05:14:30 + 08:00;
// UTime = 2010-11-06 15:21 + 08:00;
// Version = 0.3572;


// Designation ：设计说明文档。

// Shell 消息列表见 YSLib.txt 。
// 接口定义见 Interface.txt 。

/*
//E; = experimental;
*/

/*

 YSLib 设计思路：

@1 基本思路和编码风格：
设计的出发点：作为一个框架库或者操作系统组件。
代码不保证语义角度（例如实现需求）内容的连贯性。

@1.1 设计目的：
以标准 C++ 环境为基础的嵌入式设备等平台为基础，建立常规应用程序界面。

@1.2 理论依据：

@1.2.1 方法学：
面向重用的软件设计。
面向过程程序设计、面向对象程序设计、面向接口程序设计。

@1.2.2 开发模式：
迭代增量式开发。

@1.2.3 架构模式(Architectural Patterns)：

@1.2.3.1 通用抽象设计：
分层(Layers)；
外观(Facade)；
调停者(Mediator)；
管道和过滤器(Pipes and Filters)；
解释器(Interpreter)。

@1.2.3.2 交互式设计：
窗体-控件(Form-Control)；
模型-视图-控制器(Model-View-Controller)/显示-抽象-控制(Presentation-Abstraction-COntrol)。

@1.2.3.3 分布式设计：
暂不考虑。

@1.2.4 设计模式(Design Patterns)：
略。

@1.2.5 解决模式：
错误处理；
任务安排；
数据验证；
同步请求/响应；
……

@1.2.6 实现模式/代码模式/惯用法(Idioms)：
语言相关。举例： pimpl 、 copy & swap 。

@1.2.7 其它要点：

@1.2.7.1 Shell 概念扩展：
 Shell 和 Core 的关系是相对的。高级操作系统对于操作系统内核 (Kernel) 来说，即 Shell 相对于 Core 的关系。基于操作系统 Shell 的应用程序相对于操作系统 Shell 来说，也是这种关系。即这种关系可以级联。对组织虚拟机等仿真程序来说较为方便。
因此， YSLib 中的实现 Shell 的类 YShell 本身位于 "/Core" ，而不是 "/Shell" 。

@1.3 构建原则：

@1.3.1 可移植性相关：

@1.3.1.1
关于平台无关性（或平台独立性）(platform-independent) 和平台中立性(platform-neutral) ：
一般意义上大致相同，但本文档附加约定：
平台无关性是指代码（源代码或目标代码，下同）在任意现代电子计算机系统（硬件和软件平台）上可以具有一致行为的最大公共实现的特性；
平台中立性是指代码通过一定的软件手段（附加编码、提供附加二进制工具，例如构建虚拟机作为中间平台）实现一致行为的特性。
平台中立性逻辑蕴含平台无关性。平台无关性的条件更严格。

@1.3.1.2
标准库/系统库使用：
基于标准 C++ 环境（ISO/IEC C++ 2003 基本语言特性和库函数）和基本的 I/O 系统调用。

@1.3.1.3
 YSLib 的源代码的本体(@2.10) 是平台中立的。其中的一部分是平台无关的。

@1.3.1.4
格式化输出及结构对齐时注意平台字长差异。

@1.3.2 实现特征概述：
便于扩展。
尽可能地平台无关，且注重效率。
能够保持必要的运行时安全性。
实现一部分操作系统的较高级功能，例如消息服务。

@1.3.3 广义的契约式设计：

@1.3.3.1
由于语言的限制，语句（块）级别仅使用断言约束。

@1.3.3.2 面向接口：

@1.3.3.2.1
使用不含状态（成员变量）的纯虚类作为接口。

@1.3.3.2.2
如有必要，接口可以包含静态常量域。

@1.3.3.2.3
可选虚继承，但考虑到性能，应该尽量避免。

@1.3.3.2.4
合理使用接口回调、模板以及混合实现。

@1.3.3.2.5
接口类型转换可选 dynamic_cast ，但能保证类型安全时首选 static_cast ，以提升性能。

@1.3.4 抽象构建方法：

@1.3.4.1 接口设计风格：
最小接口优先。

@1.3.4.1.1
涉及类的人本接口应尽量独立于类的实现之外，而不作为成员方法，除非方法（尤其是被超过一次地）在类的实现中使用。

@1.3.4.1.1.1
例外：模块类(@2.3.7) 以及由模块类派生的类，如某些一般构件类(@2.3.6) 。

@1.3.4.2 强封装性：
按需封装类的继承体系，尽可能使用 private 成员而不是 protected 成员。
尽可能少使用友元。

@1.3.4.3 有限继承性：
使用模块类(@2.3.7) 的多重继承提供实现获得高度可复用性。
仅在必要时使用接口实现。
尽可能使用组合代替私有继承，除非需要使用派生类覆盖私有基类的（纯）虚函数。

@1.3.4.4 保守多态性：
仅在必要时或可预见的扩展前提下使用虚函数。
尽可能避免虚继承。

@1.3.4.5
除非必要或有可预见的使用场合，使用聚合而不是组合来构建类。

@1.3.4.6
合理地使用类的成员变量保存状态，仅在必要时通过成员函数实现属性。

@1.3.5 运行期错误处理：

@1.3.5.1 常规处理：
使用特定的函数返回值（如 NULL ）表示非预期的结果。

@1.3.5.2 异常：

@1.3.5.2.1
仅在必要时使用。

@1.3.5.2.2
异常类的设计可使用多重继承。

@1.3.5.2.3
在非显式使用的异常规范上下文中，使用自定义的异常规范宏代替 throw 关键字。

@1.3.5.2.4
除异常类设计外，不显式地使用异常规范，而用异常规范宏代替。

@1.3.5.2.5
在无异常抛出保证的场合，应该使用异常规范。

@1.3.5.2.1 异常中立：
除非属于内部实现或异常能够被合适地完全处理，总是向调用者重新抛出捕获的异常。

@1.3.5.2.2
优先使用 RAII（Resource Acquisition Is Initialization ，资源获取即初始化）实现异常安全的设计。

@1.3.5.2.3 最低异常安全性保证：
总是保证最低安全性，避免异常处理造成资源泄露。

@1.3.5.2.4 强异常安全性保证：
如果可能，考虑实现回滚状态。

@1.3.5.2.5
除非有必要，不使用嵌套 try 块。

@1.3.5.3 日志： //E;
输出可选的、可组织的日志文档。

@1.4 语言相关但具体设计内容无关的源代码特性使用和编码风格（一般性建议）：

@1.4.1
标识符命名风格参考 @4 。

@1.4.2 空白符、换行符和预处理：

@1.4.2.1
同一层次的缩进统一使用制表符或相同宽度的空格。

@1.4.2.2
除特殊情况外，任意不同语句应该属于不同行。

@1.4.2.2.1 例外 1 ：
初始化相同类型的对象。

@1.4.2.2.2 例外 2 ：
执行顺序无关的多条短语句序列。
 
@1.4.2.3
有源代码兼容性和可读性良好替代方案的情况下，尽可能不使用宏。

@1.4.2.3.1
尽可能使用 const 关键字定义常量，而不是宏。

@1.4.2.3.2
不在 Adaptor 和 Helper 等确定可以使用平台相关的代码以外区域使用环境、编译器和版本判断宏。

@1.4.2.4
使用条件编译控制文件包含，而不是编译器相关的预处理指令。
除此之外，尽可能不使用条件编译。

@1.4.2.5
可以使用 #error 、 #warning 和 #line ，但仅使用 ANSI 字符，以免出现不符合的预期文本。

@1.4.3 存储期和内联：

@1.4.3.1
不使用表示存储类的关键字 auto ，而使编译器隐式地实现。
显式使用会使和 C++0x 代码的共用出现问题。

@1.4.3.2
除了平台相关的上下文以外，不使用存储类关键字 register 。
注意 register 仅是建议，而不是命令。

@1.4.3.3
尽量避免使用静态和全局存储期对象。

@1.4.3.4 static ：

@1.4.3.4.1
使用翻译单元内的无名命名空间代替 static 修饰对象。

@1.4.3.4.2
可以在类的定义中 static ，不必要在类的成员函数定义中重写。

@1.4.3.5 extern ：

@1.4.3.5.1
正确地使用 extern ，并检查语义的合理性。

@1.4.3.5.2
在多个翻译单元中，extern 声明的类型应该保持一致。

@1.4.3.6 内联 ：
在必要时使用 inline 。

@1.4.3.6.1
在类声明内部不使用 inline 。

@1.4.3.6.2
不连用 static inline ，而在无名命名空间中用 inline 代替。

@1.4.3.6.3
注意 inline 仅是建议，而不是命令。
不使用非标准的内联关键字，除非在至少两个编译器上提供不同的实现。

@1.4.4 const 和 volatile 修饰符 ：

@1.4.4.1 const ：
如果有可能，尽可能使用 const 关键字，除了以下给出的$例外(@1.4.4.1.3) 。

@1.4.4.1.1
如果可能，使用 const 引用类型传递参数。

@1.4.4.1.2
除非必要(@1.4.4.1.3) ，不使用非 const 引用类型形式参数。

@1.4.4.1.3
$例外：在需要复制构造参数的场合（如某些 copy-and-swap idiom 的实现），使用值类型参数而不是引用，以免传递右值参数时引起不必要的复制构造。

@1.4.4.2
仅在有必要时使用 volatile 关键字。

@1.4.4.3 例外：
在异常捕获块中，省略形式参数顶层的 const 和 volatile 修饰符。

@1.4.5 类型关键字：

@1.4.5.1
除非有必要，用非整数类型代替浮点数类型。

@1.4.5.2 整数类型：

@1.4.5.2.1
尽可能使用确定大小的整数类型。

@1.4.5.2.2
在位运算以外的上下文中尽可能不使用无符号整数。

@1.4.5.3
注意 sizeof(void*) == sizeof(int) 并不在所有平台上保证成立。
需要使用和对象指针占用空间大小相同的整数类型时，使用 std::intptr_t 。

@1.4.5.4
根据可访问性的需要选择 struct 或 class 。

@1.4.5.5
在定义模板参数时 class 和 typename 等价，但应该根据语义适当选择：
如果确定仅适用于 class 类型，使用关键字 class ；否则使用关键字 typename 。

@1.4.6 字面量：

@1.4.6.1
关键字 true/false 和 bool 类型对应；宏 TRUE/FALSE 和 int 类型（例如自定义的 BOOL 类型）对应。
尽可能使用前者。

@1.4.6.2
非关键字字面量的表达必须保证符合语法，且兼顾可读性。

@1.4.6.3
整数用0，浮点数用 0.0 ，指针用 NULL ，字符（串）用 '\0' （非字面量形式用 NUL 表示）。
有必要使用 float 时，用 0f 。

@1.4.6.4
合理使用字符串字面量前缀 ('L') 。

@1.4.6.5
可以使用字符串字面量初始化 C 风格字符串。
被初始化的若为字符数组，元素（字符类型）必须是 const 类型修饰的。

@1.4.6.6
必要时可以同时使用字符串字面量和断行连接。

@1.4.7 操作符：

@1.4.7.1
尽可能用对象名称代替类型名称作为 sizeof 的操作数，以在重编码时保持一致性。

@1.4.8 控制流：

@1.4.8.1
如果可能，使用 if 结构代替 if-else 结构。

@1.4.8.2
尽可能不使用 goto ：仅在退出多层循环等少数具有明确语义且没有高效结构化控制流替代方式时使用。

@1.4.8.3
合理减少 switch 块中的 break 个数。

@1.4.8.4
关于异常处理相关的部分，参考： @1.3.5.2 。

@1.4.9 类型操作：

@1.4.9.1
注意参数传递中的退化：数组到指针，函数到函数指针。

@1.4.9.2
除非特殊情况，禁止使用变长数组。

@1.4.9.3
使用 C++ 风格而不是 C 风格的类型转换。

@1.4.9.4
如果可能，使用 dynamic_cast 代替 typeid ；
如果可能，使用 static_cast 代替 dynamic_cast ；
如果可能，使用 static_cast 代替 reinterpret_cast 。
参考：@1.3.3.2.5 。

@1.4.9.5
禁止对派生类的成员指针使用转换为基类成员指针的 static_cast ，以避免成员指针实现相关的错误。

@1.4.10 重载、默认参数、可见性和可访问性
注意函数重载和默认参数的使用的清晰性和易读性。

@1.4.10.1
合理地使用函数默认参数。需要注意参数顺序。

@1.4.10.1.1
在虚函数中应该避免使用默认参数。
如果需要使用默认参数，应在基类中使用具有默认参数的非虚成员函数调用没有默认参数的非 public 虚函数。

@1.4.10.2
在结构体/类中合理使用 using 声明使被隐藏成员可见。

@1.4.10.3
在结构体/类中合理使用 using 声明使被隐藏成员可见。

@1.4.11
在相同作用域内，前置和后置自增/减被同时定义时，尽量保证它们的语义一致性，并通过前置自增/减来实现后置版本。如果有必要改变，必须给出注释说明。
能使用前置自增/减实现相同效果时，不用后置自增/减。

@1.4.12
可以同时使用流和 printf/scanf 函数族进行格式化输入/输出处理。
正确使用 printf/scanf 函数族格式化输入输出的控制字符。

@1.5 对象特性抽象：

@1.5.1 容器：
容器是在逻辑上包含零个或更多个其它对象的对象。

@1.5.2 循环迭代器：
经过有限次前置 operator++ 或前置 operator-- 操作，可以得到初始值的迭代器。
理想情况下，通过迭代操作（至少包括前置 operator++ 和前置 operator--）获得的所有临时迭代器状态中，有且仅有一个无效状态。

@1.6 约束概念：
实现了容器模板接口 GIContainer 的类，称为容器 (Container) 类。

@1.7 进程内通信：

@1.7.1 事件：
事件是用户发出的信号在进程中的抽象。
事件本身是即时的，包含发生时间和事件内容两个方面的意义（有时后者又包含前者）。

@1.7.1.1 事件空间：
对于有限的不同种类事件，它们内容可以用整数或枚举类型标识，对应的取值集合称为事件空间。

@1.7.1.2 事件回调：
事件可以在生成同时调用预先设置对应关系（注册）的事件处理器（事件响应函数），即同步回调；也可以事件发生后延迟调用，即异步回调。
事件处理器可以是对应参数列表的非成员函数或静态成员函数、非静态成员函数和函数对象。
复杂的回调要求事件能够被带有状态地进行传递，此时需要使用函数对象。

@1.7.2 简单事件调用：
可以通过把事件本身抽象为具体的类，借用委托（例如函数指针）实现同步回调。

@1.7.3 消息：
为了传递事件，需把其中的事件内容包装至某一可传递的数据结构中。使用消息机制解决这个问题。
消息类型是为了在应用程序进程内部、应用程序进程之间以及应用程序进程和操作系统之间传递数据的数据结构。它的实例称为消息（Message）。
使用消息传递事件内容，需要包含一个主标识和与其语义相关（具体语义可以取决于主标识）的其它参数。除此之外，消息类型中的成员是可定制的。
各个域完全相等的消息是完全相同的。

@1.7.3.1 消息空间：
所有能够在一个处理单元（例如线程）在该单元生存期被处理的消息集合称为消息空间。
任意完全相同的消息在一个消息空间中不应该含有超过一个实例。
消息空间的具体实现可以采用队列等抽象数据结构。

@1.7 组件和界面设计概述：

@1.7.1 UI（User Interface ，用户界面）设计：
为了适应不确定数量的输出设备，中间层 Shell 可以用于实现程序中处理 UI（User Interface ，用户界面）行为。
用于实现 UI 的 Shell 一般也包括实现相关消息处理。
和 Shell 相对的是 Core ，不直接参与实现 UI 。
 Shell 和 Core 相对独立，以方便移植。
 Shell 本身为单线程。

@1.7.2 GUI（Graphic UI ，图形用户界面）设计概述：
界面实现使用精简的主动模型-视图-控制器模式，参照窗体-控件模式。
基于性能考虑，底层不实现观察者模式。

@1.7.2.1 构件实体：
相较于典型的窗体-控件模式， GUI控件(controls) 退化为组件(components) ，组件退化为部件(widgets) ，进而分离控件和部件属性，抽象出独立于部件的控件特征，细分功能以实现高度可配置性。
 YSLib 本身不提供大量成熟的控件，而是着重提供可供组装为控件的基本 GUI 类（部件模块类）、部件类、在部件基础上衍生的构件以及部件简单组合的组件。这些设计元件都不具有消息处理或事件响应的功能，因此不是控件。
控件主要由用户通过组装以上的构件定制。在 YControl 单元中提供最常用的控件实现。

@1.7.2.1 模型(model) ：
模型表示数据模型(data model) 和业务逻辑(business logic) 。

@1.7.2.2 视图(view) ：
视图用于向用户呈现数据。可以和控制器(@1.7.2.3) 共享界面和输入逻辑。
视图在 GUI 响应(@1.7.2.5) 中不会修改模型，但可以向控制器提交状态。
部件模块类是基本的视图类。通过派生或修饰这些类可以得到扩展的视图。

@1.7.2.3 控制器(controller) ：
控制器包含了根据用户在视图中的行为更新模型的逻辑。
模型和视图不能直接修改控制器的状态，但可以提交状态等待控制器自行更新。

@1.7.2.4 组合构件：
可以自定义任意的模型类来组装控件。
但是，并非每一个成分都是必须的。某些成分可能在具体的类的外部实现。
若组合的结果能处理消息或响应事件，同时能够呈现界面数据，那么就是控件。

@1.7.2.5 GUI 输入控制器：
由于设备的特点， GUI 输入相对于输出而言是容易规格化的。因此在 YControl 单元中定义了一些默认 GUI 输入事件，且在 YGUI 单元中定义了若干函数/类用于处理默认 GUI 输入事件。
在默认的控件实现中，使用上述的默认 GUI 输入处理程序作为调度控件行为的控制器。在自定义控件实现中，可以另行定义控制器。

@1.7.2.6 默认 GUI 响应流程概述：
终端用户进行 GUI 输入；
控制器捕获 GUI 输入产生 GUI 输入事件；
视图或控制器处理 GUI 输入事件，必要时呈递至模型，并向视图同步模型数据；
视图向用户呈现 GUI 数据。
以上流程在组合构件中可以有相应细节上的变化，但步骤之间的顺序不变。

@1.7.2.7 默认 GUI 渲染逻辑：
使用视图的方法对缓冲区进行渲染。具体内容由视图的实现决定。
刷新逻辑见 @2.6.3 。

@1.7.2.8 辅助模块类：
默认提供基本事件回调模板类，以方便用户实现消息映射和其它间接传递消息的功能。
此外，还提供对默认 GUI 输入事件的参数类。

@1.7.2.9 默认 GUI 事件：
默认 GUI 事件和 YGUI 单元、 YControl 单元和默认部件模块类相关。

@1.7.2.9.1 焦点事件：
在 YControl 单元的可视控件事件空间 EControl 中定义。
包含 GotFocus 和 LostFocus 事件。
触发条件参考 @1.7.2.9.2 。
功能概述参考 @2.6.2 。

@1.7.2.9.2 基本输入事件（由 YGUI 单元产生）：
在 YControl 单元的可视控件模块类 MVisualControl 中定义。
当用户按键时，触发 KeyDown 事件；持续时触发 KeyHeld 事件；结束时依次触发 KeyPress 和 KeyUp 事件。
当用户使用指针设备（包括触摸屏）输入时，触发 TouchDown 事件；持续时触发 TouchHeld 事件；结束时依次触发 Click 和 TouchUp 事件。
 MVisualControl 默认处理 KeyHeld 和 TouchDown 事件时调用 RequestFocus(...) 向容器请求焦点。若请求成功，则默认当前控件以外的控件失去焦点（触发 LostFocus 事件），之后当前控件获得焦点（触发 GotFocus 事件）。
指针设备作用于 MVisualControl 派生的控件，触发 TouchDown 事件之前判断输入焦点时触发 Enter 事件；触发 TouchHeld 同时移动指针设备出入控件边界可触发 Leave 和 Enter 事件； TouchUp 事件触发后触发 Leave 事件。
指针设备相关事件中，参数包含了相对于控件的坐标。最近操作的全局（相对于屏幕的）坐标保存于全局变量 VisualControlLocationOffset 中。

@1.7.2.9.3 扩展输入事件：
 MVisualControl 定义了 TouchMove 。
虚成员方法 OnTouchHeld 默认处理 TouchHeld 事件时若用户移动指针设备，则触发 TouchMove 事件。
虚成员方法 OnTouchMove 默认用于实现拖动控件（但默认并没有被添加至 TouchMove 事件处理器）。

@1.7.2.10 公用和扩展事件处理程序：
 YControl 模块中定义了部分非成员函数公用事件处理器。
 OnKeyHeld 使用 RepeatHeld 产生有延迟的连续按键输入。
 OnTouchMove 可结合 OnTouchHeld 用于处理 TouchMove 事件，实现控件拖曳。

@1.7.2.11 默认实现细节：
事件处理器不适用虚函数，以免在基类添加事件后，在派生类重复添加事件响应。
在派生类定义的和基类同名的事件响应函数会被隐藏而不是覆盖基类的事件响应函数。一般应该避免使用基类指针或引用直接调用响应函数。
派生 AVisualControl 类实现的类在构造函数中添加了 GotFocus 、 LostFocus 、 TouchDown 、 TouchHeld 的事件响应器，且除了 TouchHeld 外，都是 AVisualControl 的成员函数。

@1.8 对象所有权：
具有所有权的对象（所有者）负责被托管对象的释放。
一旦向对象所有者添加了对象，就不应在从所有者移除该对象前通过所有者以外的途径访问该对象（作用于对象，从所有者移除该对象的操作除外）。
由于所有权最终会导致对象被所有者释放，因此具有栈语义的自动对象不宜被添加所有权，否则容易被误释放超过一次。若自动对象被添加所有权，则应确保所有者释放该对象之前，手动从所有者移除该对象。
以下所有权关系中，被托管对象类包括派生类：
 YApplication 具有 Shells::YShell 所有权。
 Drawing::YFontCache 具有 Drawing::Typeface 、 Drawing::FontFile 、 Drawing::FontFamily 的所有权。
 Text::TextMap 及其派生类 Text::TextFileBuffer 具有 Text::TextBlock 的所有权。

@2 实现概览：
外部库参考 @3 。
一个编译单元一般对应一个或多个头文件，包含类（组件）或 API（Application Programming Interface ，应用程序编程接口）的实现。
多个编译单元组成一个系统。

@2.1 命名空间、对象作用域和全局对象规则：
使用嵌套命名空间。
一个单元可能有多个命名空间。
一个命名空间可能在多个模块中。

@2.1.1 一般准则：
禁止在头文件中使用不具名命名空间 (unnamed namespace) 。
禁止在头文件中使用全局 using 指示符，除非是有意的（例如减少别名个数；需在文档中说明）。
局部对象在声明时同时初始化。
函数内变量尽可能置于最小作用域内——除非效率原因，尽可能使用语句块级对象代替函数级局部对象。
避免在嵌套类中定义被嵌套类的定义，除非能够确保此定义的实现无关性。
有依赖关系的全局对象应置于同一编译单元内。
禁止使用函数返回值初始化全局对象。
除非程序明确为单线程的，禁止使用非 POD(plain-old data) 类型的全局对象。如果非必要，用内建 (built-in) 类型代替 POD 结构体全局对象。
多线程程序中，禁止使用非 const 全局对象。

@2.1.2 YSLib 库的根命名空间为 YSLib ，一般应置于全局命名空间中，即为 ::YSLib 。

@2.1.3 依赖性：
默认显式依赖于库 CHRLib 。具体由适配器系统(@2.7) 决定。

@2.1.4 命名空间分配：
 YSLib::Components ：组件。
 YSLib::Components::Widgets ：部件。
 YSLib::Components::Controls ：控件。
 YSLib::Components::Forms ：窗体应用。
 YSLib::Design ：基础语言设施（类型操作等）。
 YSLib::Design::Pattern ：设计模式。
 YSLib::Design::Policies ：类构建策略。
 YSLib::Design::Policies::Storage ：类存储构建策略。
 YSLib::Design::Policies::Operation ：类操作构建策略。
 YSLib::Design::TL ：类型表 (Typelist) 操作。
 YSLib::Device ：设备抽象。
 YSLib::Drawing ：图形处理。
 YSLib::IO ：输入/输出管理。
 YSLib::Runtime ：运行时对象。
 YSLib::Shells ： Shell 抽象层。
 YSLib::Text ：文本服务。
 YSLib::Timers ：计时器服务。

@2.2 语言特性支持：

@2.2.1 接口

@2.2.2 断言

@2.2.3 成员函数简写

@2.3 类构建：

@2.3.1 命名必须和标识符命名规约(@4) 兼容。

@2.3.2 类型特性：
空结构体类型 EmptyType 。
除了 I 和 A 前缀的类，都不含有纯虚函数。
 Y 前缀类名的类不可被多继承。
命名中按以下列出的顺序确定分类。

@2.3.3 I 前缀类名的类：
接口。
纯虚类。

@2.3.4 A 前缀类名的类：
抽象类。
带有纯虚函数。

@2.3.5 S 前缀类名的类：
静态类。
除了类型定义外，应该仅包含静态成员。但编译时不作检查。
可参与多重继承，例如作为特征类(traits class) 。

@2.3.6 Y 前缀类名的类：
一般构件类，包括 YObject 和直接或间接派生自 YObject 的类。
 YObject 具有虚析构函数，因此这些类都是多态类。
基本对象类 YObject ：所有类名以 Y 作前缀（除模板类、非直接实例化类和模块类）的公共基类，为多态类。
提供引用相等判断等公共方法。

@2.3.6.1 基本可数对象类 YCountableObject ：
所有可数的基本对象类的公共基类，通过继承 GMCounter 模板实现静态实例计数器。

@2.3.7 M 前缀类名的类：
模块类。
用于提供实现而非规范接口，可定义人本接口成员。
作为 mixin 类的实现：强调可以参与多重继承组合为其它模块类和一般构件类，也包括被参数化（作为模板类型参数）以构建这些类。
当作为非多态类时析构函数应被保护（除非它的所有派生类都没有在它的基础上扩展域，或都满足析构函数被保护），且不可作为类的成员或被实例化。
其它情况下可实例化，但通常仅用于作为类实例的子对象（mixin 实例）。此时应尽可能减少虚表体积，并降低额外的运行时效率开销。

@2.3.8 E 前缀类名的类：
枚举包装类。
一般是非多态类。
包括事件空间类，即实现了 EventID 类型成员的类，仅作为模板参数使用。 EventID 可以是整数或枚举类型。
其它特性类型同屏幕对象类。

@2.3.9 H 前缀类名的类：
句柄类。
具有间接访问语义的类（例如指针、引用或迭代器）。

@2.3.10 无前缀类名的类：
一般类。
不属于以上有前缀类的类。无其它限制和特性。

@2.3.10.1 事件参数基类 EventArgs ：
即 EmptyType 。

@2.3.9 异常类总览：
专用于被 C++ 异常机制捕获的类称为异常类。
异常类不在特定的命名空间中定义。
标准库异常类以外， YSLib 仅使用派生自 YSLib::Exceptions::Exception 异常类。
以下是 YSLib 命名空间中一般的异常类列表：
模块 YException 中：
 Exception ： YSLib 异常基类。
 GeneralEvent ： 一般异常事件类。
 LoggedEvent ：记录异常事件类。

@2.4 核心构件系统：
位于 "/Core" 。
除了通用定义 YSDefinition 以外，主要包含以下几大部分：
对象计数器 YCounter；
函数对象封装模块 YFunc ；
核心实用模块 YCoreUtilities ；
平台无关的基础对象实现 YObject ；
异常处理模块 YException ；
基础字符串管理 YString ；
应用程序实例类抽象 YApplication ；
 Shell 定义 YShell ；
平台无关的设备抽象层 YDevice ；
资源管理模块 YResource ；
平台无关的文件处理系统 YFileSystem；
文件类集 YFile 等。

@2.4.1 设备抽象：
位于命名空间 Device 中。

@2.4.1.1 物理设备：
 YGraphicDevice 是输出设备基类。
 YScreen 由 YGraphicDevice 派生，是二维屏幕的抽象。

@2.4.1.2 虚拟设备：

@2.4.1.2.1 桌面：参考 @2.4.1 。

@2.4.2 通用字符串抽象。

@2.4.3 事件的实现：
位于单元 YEvent 中。
简单事件调用的标准实现位于命名空间 Runtime 中。
传递事件参数的参数基类是 EventArgs ，可从这个类派生自定义参数类。
除此之外，默认提供以下参数类：
 ScreenPositionEventArgs ，屏幕事件参数类；
 InputEventArgs ，输入事件参数模块类；
 TouchEventArgs ，指针设备输入事件参数类；
 KeyEventArgs ，键盘输入事件参数类；
为了实现和派生上的便利性，包括 EventArgs 以上类实际为结构体类型。
用模板定义用于事件处理机制的接口和实现类：
事件处理器接口模板 GIEventHandler ，标准版 IEventHandler ；
事件处理器模板 GEventHandler ，标准版 EventHandler ；
事件模板 GEvent ，默认第一参数为 true 时为多播版本，否则为单播版本，标准版 Event 为多播版本；
事件映射表模板 GEventMap 。

@2.4.3.1 标准事件处理实现概述：
基于 C++ 语言的局限性和效率考虑，事件处理器调用仅进行空指针检查（若为 NULL 则取消调用）。
单播版本：
添加事件订阅和移除事件订阅复杂度为 O(1) ，同普通的函数指针赋值。调用事件处理器复杂度为 O(1) ，同普通的函数指针调用。
多播版本：
本质上是 std::list 实现的函数指针队列。
调用链维持稳定的顺序（和订阅顺序相同）。
对于重复订阅，仅保留一个实例，添加时移至调用链末尾。
事件处理器调用顺序由调用链决定。
对于调用链长 n ，添加事件订阅、移除事件订阅、调用事件处理器复杂度相对每个事件处理器调用为 O(n) 。
每个事件处理器调用复杂度同单播版本。

@2.4.4 消息的实现：
消息类型是 Message 类；
消息主标识是唯一的，简称为消息标识，它的类型为 MSGID（本质上是无符号整数）；
消息队列类型是 YMessageQueue 类，是一个优先队列。
库中的 "/Core/ysmsgdef.h" 文件预定义了一些消息标识。覆盖这些标识的最小连续区间称为系统消息标识区间。
用户可自定义新的标识（用户自定义消息标识），但不应该和原有定义冲突。由于为宏定义实现，可以使多个标识名对应一个实际的标识，但反之无法实现。
应尽可能保持所有用户自定义消息标识在系统消息标识区间之外。
消息的处理的具体实现取决于用户。

@2.4.5 消息队列的实现：
消息队列为优先队列。第一优先级为 unsigned char 型变量。为了适应不支持 std::clock() 的平台，用消息实例构造时的计数标识代替产生时间作为第二优先级。

@2.5 图形系统：
位于 "/Shell" 。
包含 GDI/GUI 常用 API 以及其它较底层的绘图函数。更基本的图形抽象和资源管理则来自于 "/Core/YObject" 和 "/Core/YResource" 。

@2.5.1 桌面：
组件命名空间 Components 中的 YDesktop 类是桌面的抽象，自带显示缓冲区，和 YScreen 关联，负责把窗体和其它桌面对象输出至屏幕。

@2.5.2 文本服务：
通用的字符/字符串栅格化处理。字符串本身的逻辑处理在 "/Core" 中，而不在此处。

@2.6 组件 (Components) 系统：
位于 "/Shell" 。
组件/构件 (Component) 是具有一定相互联系的功能集合单元。 YSLib 中的组件是以引用方式传递的类。
组件类是非抽象类，默认基类为 YComponent 。
组件包含部件和控件：
具有基本屏幕输出效果，实现了部件接口 IWidget 的类，称为部件 (Widget) 类；
具有公共事件响应能力，实现了控件接口 IControl 的类，称为控件 (Control) 类；
同时具有基本屏幕输出效果和公共事件响应能力，实现了接口 IWidget 和 IControl 的类，称为可视控件类 (VisualControl) 类。
部件仅仅负责 Shell 直接和 UI 相关的部分，默认不包含任何消息处理。
消息应该被其从属的 YShell 消息处理过程截获并进行处理。
控件是可以处理消息的组件。
控件行为由事件映射表控制（在运行期加载函数）。其它组件行为原则上直接由 YShell 消息处理过程控制，以避免消息转发带来的开销。

@2.6.1 用于 GUI 的对象特性：
所有公共 GUI 对象继承自组件基类。
用于实现的类，除了能够直接和组建基类继承为完整的公共 GUI 对象的类（如 Widgets::Visual 、 Widgets::Widget 、 Controls::Control 等）使用公有继承，其它都以模块类使用保护继承。
部件是实现了 IWidget 接口的类，是基本的 GUI 对象类。
组件容器是能够以引用方式在逻辑上包含其它组件的组件，它实现了 GIContainer 接口模板的实例。
部件容器是实现了 IUIBox 接口或 IUIContainer 接口（都继承了 IWidget 接口）的类（标准基类为 YUIContainer ），是一般化的组件容器，它能以可视化方式处理其包含的部件（例如顺序显示）。其中 IUIContainer 限制了添加和移除部件的抽象方法。
控件是实现了 IControl 接口的类（标准基类为 YControl ），是具有一般化的事件（不一定是 GUI 事件）响应能力的组件。
可视控件是实现了 IVisualControl 接口（继承 IControl 接口）的类（标准基类为 YVisualControl ），是具有控件特性的组件。 YVisualControl 同时也是部件。
窗口是实现了 IWindow 接口（继承 IUIContainer 和 IVisualControl 接口）的类（标准模块基类为 AWindow 抽象类），是作为一种能在桌面显示的自带缓冲区的特殊组件，不涉及界面以外的任务，不通过事件映射方式响应事件（尽管同时是焦点响应类和焦点请求类）。
框架窗口（基类为 YFrameWindow ）是具有一般化的部件容器功能的窗口。
窗体（基类为 YForm ）是增加了事件映射响应能力和客户区布局管理的框架窗口。
默认组件中，除继承自窗口的组件（基类为 YWindow ，缓冲区继承自类 BitmapBuffer ）外，所有部件默认不带显示缓冲区。实际使用时可以用其它类型成员（如 TextRegion ）提供显示缓冲区。

@2.6.2 用于 GUI 的焦点特性：

@2.6.2.1 概述：
焦点在部件容器（称为焦点上下文）中标识当前（通常是用于响应输入的）操作作用的对象。

@2.6.2.2 默认实现相关的定义：
具有焦点响应能力（即储存了关于集中焦点于特定的子对象的状态）的类称为焦点响应类。
实现 AFocusRequester 抽象类的类具有焦点请求能力（即能够从焦点响应类中获取焦点），称为焦点请求类。

@2.6.2.2 默认实现综述：
 YSLib 中的通用焦点特性默认以 GMFocusResponser 类模板中的指针实现，同时在每个可识别自身焦点状态的对象中用 bool 变量指示状态。
 IUIBox 接口要求实现者需要响应焦点的请求和释放操作。
典型的实现方式是控件类以通过继承 GMFocusResponser 类模板的实例成为焦点响应类。这种方式会储存一个子焦点容器指针的集合，对于具有确定的子对象的控件而言效率较低，因此 GUI 默认实现中并不都采用此方法。
在 GUI 实现中独立保存额外的可视控件独立焦点指针。
为了支持拖放操作，指针索引可视控件时，按位置判断作用的可视控件并根据上述独立焦点指针和状态变量判断附加操作，而不通过上述的通用焦点。

@2.6.2.3 举例：
 YDesktop 是 IVisualControl 的焦点响应类。
 YFrameWindow 和 YForm 同时是 IVisualControl 的焦点响应类和对于 YDesktop 焦点请求类。

@2.6.2.1 焦点污染：
焦点默认和请求/响应双方相关，而和其它对象无关。即 RequestFocus(...) 函数应该只改变主调对象及其响应对象中描述焦点的状态域，而不产生副作用。
可以在 GotFocus 和 LostFocus 的响应函数中添加相关代码改变这一特性，但会使主调对象和其它对象产生额外的关联。这种关联不符合焦点本身的语义，且难以调试，如非必要，应该避免。

@2.6.2.2 焦点请求链：
在排除 @2.6.2.1 中叙述的副作用的情况下，可以认为不同对象的 RequestFocus(...) 的调用是顺序无关的，可以任意调度。
用 Runtime::RequestFocusCascade(Components::Controls::IVisualControl&) 函数可以实现由 IVisualControl 对象自下向上的嵌套容器焦点申请。注意，会以相同的顺序引发 GotFocus 事件。

@2.6.3 默认 GUI 刷新逻辑：
部件向容器请求得到绘制的过程称为刷新。缓冲区内的图形信息复制到其它缓冲区的过程称为更新。
部件实例存储背景重绘状态；带缓冲区的部件（包括窗口和桌面）实例存储刷新状态和更新状态。这些状态用 bool 类型变量表示。
背景重绘状态值为 true 时表示背景重绘已经结束，无需再次重绘；刷新状态和更新状态值为 true 时表示准备就绪并需要进行对应操作。
 DrawBackground() 和 DrawForeground() 是部件的状态无关的绘制接口，分别用于绘制背景和前景。
 Draw() 作为一般的缓冲区图形绘制接口（可能调用子对象的 Update() ），完成绘制后，设置刷新状态为 false ，更新状态为 true（对于桌面等无上层缓冲区的对象无必要）。
 Refresh() 在保证本层缓冲区（若存在）绘制完毕后向最近的上层缓冲区（若存在）传递刷新状态。
更新状态为 true 或上层容器（若存在）的刷新状态为 true 时， Update() 查询刷新状态，若需要刷新则使用 Draw() 绘图，之后若上层缓冲区存在，更新至上层缓冲区（对于桌面而言是屏幕），并设置对应容器的更新状态为 true 。
在 Shell 处理函数中可以在输入分支后添加桌面对象的 Refresh() 和 Update() ，按需要更新最近经过重绘但未经过更新的 GUI 对象。

@2.7 适配器 (Adaptor) 系统：
位于 "/Adaptor" 。
负责衔接和封装外部库，便于移植。
除了 C++ 标准库以外，其它外部库的函数需要在此声明，以便辨别。
直接使用除 C++ 标准库、 POSIX / GNU C 兼容函数库、 YCLib 库和 CHRLib 库之外的外部库的代码段所在文件都从属于 Adaptor 或 Helper 。

@2.8 服务系统：
位于 "/Service" 。
对以上组件提供内部和外部的常用类型和函数的封装。
提供了附属的类型和函数供用户程序使用。

@2.8.1 初始化逻辑的实现

@2.8.2 通用函数

@2.8.3 文本管理类

@2.9 帮助模块系统：
位于 "/Helper" 。
与以上系统不同，这个系统是平台相关的，一般由库用户自行配置。
 YGlobal 是不可缺少的，它封装了 main 函数和必要的全局变量。

@2.10 本体：
以上 YSLib 构成单元中，除了 Adaptor 和 Helper 以外的部分的总称。
其中 Adaptor 的改变很可能导致整个本体的重新编译。因此新增的平台相关的部分应尽量放在 Helper 中。

@3 库配置：

@3.1 支持库概述：

@3.1.1 基础库：
平台隔离用库 YCLib 。

@3.1.2 通用库：

@3.1.2.1
使用 Loki 库的智能指针实现句柄。

@3.1.3 专用库：

@3.1.3.1
字符串内码支持库 CHRLib 。

@3.1.3.2
字体输出使用 FreeType2 实现矢量字体光栅化支持。

@3.1.3.2.1
头文件版本： 2.3.12 ；
库文件版本：在 VNDS 源代码中提取的 2.3.6 。

@3.1.3.3
图形库：修正的 Anti-Grain Geometry 库 V2.4 。

@3.2 库文件基础结构：
平台设置在 <platform.h> 中。
任何 YSLib 文件，除了 "/Adaptor/yadaptor.h" 和 "/Core/ysdef.h" 以及仅包含宏定义的文件外，都必须包含 "/Core/ysdef.h" 文件。
所有外部链接库为静态库。除了 CHRLib （未找到替代品）和 YCLib 外，对外部库未经过封装的使用仅在 /Adaptor 组件中。这样有利于库的移植。

@4 标识符命名规约：
以下是 YSLib 风格标识符的命名规则和约定。

@4.1
通用指引：

@4.1.1
尽可能保持上下文一致性。

@4.1.2 基本例外：
类的 private 成员、函数作用域（注意不包括属于函数声明作用域的参数列表）和无名命名空间中的名称可以不受本规约限制。

@4.1.3 拼写：
以美式英语作为命名标识符的基本自然语言参考。

@4.1.3.1 构词原则：
如果不使用以下构词原则或例外，至少应该在原始声明或定义处注释。

@4.1.3.1.1 缩略词：
一般除了习惯（例如使用 GUI 表示 Graphic User Interface ），不构造新缩略词。

@4.1.3.1.1.1
被缩写词大小写不改变。
如“GUI”缩写后不作“Gui”。

@4.1.3.1.2 非缩略词和一般词组：
词与词之间需有 "_" 分隔符或大小写不同以示区分。除了 @4.1.3.1.3 中的情况外，通常使用后者。
单词的首字母大写，其它字母保持原形式（通常为小写）不变。
多个单词连用，保持首字母大写，省略其中空格。
这里的单词应该是自然语言中较广泛使用的单词，如果有多种拼写方法，使用较常见形式，尤其是语言标准中已经有定义的概念（如使用“adaptor”而不是“adapter”）。

@4.1.3.1.3 标准库兼容构词方法：
使用标准库或类似标准库命名风格的库（如 Boost ）时，对应成员使用库的命名风格，以便保持模板兼容性和适当的上下文一致性(@4.1.1) 。
注意对于如“valarray”这样的名称，为单词（非专有名词）而不是词组。因此“ValArray”不是“valarray”对应的 YSLib 风格名称。由 @4.1.3.1.2 ，只能保持原文，或者使用同义词组按 @4.1.3.1.2 所述方法得到的“ValueArray”代替。

@4.1.3.1.4
不使用小写字母起始的驼峰命名法，以免和可能使用的习惯匈牙利命名法的名称(@4.1.4) 混淆。

@4.1.3.1.5 专有名词例外：
对于某些专有名词不受以上限制（仍然受语言实现字符集限制）。
例如“GB”（“国标”的汉语拼音缩写）。

@4.1.3.1.6
在不致混淆的情况下，单字母等简单前缀可以直接作为哑变量、循环变量或形式参数名称。

@4.1.3.1.7
慎用前缀。在有限的类型或模板参数命名场合需要使用变形的系统匈牙利命名法，如 @4.3.5.2 。除了类的 public 成员外，对象命名可以使用习惯匈牙利命名法。
起始两个大写字母，之后紧接小写字母的类型（此上下文包含参数化类型，下同）标识符，第一个字符会被作为类型前缀。
少数特例(@4.3.5.2) 中，出现在类型标识符起始则被视为既定的类型前缀组合。 
一般应避免出现起始两个大写字母，之后紧接小写字母的非前缀标识符，以免混淆。

@4.1.4
在同一作用域中可以使用同一名称表示类型和对象。
（此时引用类型名须使用命名空间限定，否则无法正确编译。）

@4.1.5
语义：函数名以谓语动词（不一定是原型）起始。
成员函数名以动词起始，其它成员不使用谓语动词起始，以示区别。

@4.1.5.1
例外：参考 @4.1.3.1.3 ，如 C/C++ 标准库扩展函数。
为保持风格一致，不使用以上命名规约。

@4.1.6
保留标识符：
一般不应被用户程序使用。

@4.1.6.1
按 ISO/IEC 14882:2003 C++ 标准条款 17.4.3.1.2 [Global Names] 规定，包含双下划线 "__" 或以下划线 "_" 紧接大写字母起始的标识符保留给（语言和标准库）实现使用。

@4.1.6.2
以 "_y" 起始的标识符保留给 YSLib 库内部实现使用。

@4.1.7
以 "INCLUDED_" 起始的标识符专用于头文件包含标识。

@4.1.8
以 "_b" / "_p" / "_f" / "_i" / "_t" / "_g" 起始并紧接大写字母（_g 可接以上前缀并省略下划线）的标识符保留给 YSLib 模板参数使用，分别表示布尔类型参数、指针类型参数、函数类型参数、接口类型参数、其它类型参数、模板类型参数。

@4.2
宏定义:

@4.2.1
默认使用大写字母。用其它标识符构造的宏以及特殊宏除外。

@4.2.2
特殊宏。

@4.2.2.1
实现语言功能，如interface等。

@4.2.2.2
代码生成器：用宏展开为一段声明或定义的代码。

@4.2.3
 YSLib 保留宏以 "YSL" 起始。

@4.3
类型名：

@4.3.1
定长整型：全局命名空间中的类型，以前缀和字长组合的形式以明确整型所占的空间。前缀 s 表示有符号整数，前缀 u 表示无符号整数。

@4.3.2
通用类型：非全局命名空间中的类型，小写字母，以 "_t" 作为后缀。

@4.3.3
同质聚合类型：数组或容器类型，用不少于2个大写字母和后缀 "s" 组成。

@4.3.4
通用模板类：小写字母，词之间以 "_" 分隔。

@4.3.5
保留类型前缀（关于类型前缀，详细参考 @4.1.2.2 和 @2.3 ）：

@4.3.5.1
全局专有模板类前缀 G(Global Generics) 。可和其它前缀共用。

@4.3.5.2 类型特性划分：
部分使用系统匈牙利命名法。以下前缀适用于 struct 和 class 类型。
非类型参数化的类型前缀（即除了 G 以外的前缀）至多使用两个。
类型特性参考 @2.3 。

@4.3.5.2.1
接口（纯虚类）前缀 I(Interface) 。
对应的接口模板前缀 GI 。

@4.3.5.2.2
包含默认实现语义的虚函数的非严格接口（实际为抽象类）在此也作为接口处理。

@4.3.5.2.3
抽象类前缀 A(Abstract) 。
对应的接口模板前缀 GA 。

@4.3.5.2.4
静态类前缀 S(Static) 。

@4.3.5.2.5
一般构件类前缀 Y(YSLib Class) 。

@4.3.5.2.6
模块类前缀 M(Module) 。

@4.3.5.2.7
枚举包装类前缀 E(Enum) ，供包装枚举的 struct 和 class 类型使用。
含有事件的含义也属于此范畴，即事件空间类 E(Event Space) 。

@4.3.5.2.8
句柄类前缀 H(Handle) 。

@4.5
标号：同通用模板类。

@4.5
函数名：

@4.5.1
非成员函数：
以命名空间区分，长度不少于2 。

@4.5.2
成员函数：
除 @4.5.1 限制外， public 函数首字母须大写。

@4.5.2.1
 "Get" 和 "Set" 起始的成员一定是成员函数；不一定为类的访问器，但须符合访问器的一般语义。

@4.5.2.2
一般不使用缩写，除非有特殊含义。

@4.5.2.2.1
 "Ln" 表示文本行，区分于表示像素行的 "Line" 。

@4.5.2.2.2
 "N" 表示索引或总数。

@4.6.常量和变量：

@4.6.1
常量首字母大写，除非是局部（函数体或以下级别）的临时性常量。

@4.6.2
静态 public 成员首字母大写。

@4.6.3
同质聚合类型变量以一个小写字母起始，第二个字母起若干连续字符为大写字母，之后接小写字母或数字，后缀 "s" 。

@4.6.4
哑变量
不超过2个小写字母组成。

@4.6.5
其它变量
不限制。一般同标号。

@5 一般实现导引：
自定义应用程序 Shell 类，继承 YShell 类并产生实例。
完成自定义 Shell 类的消息处理过程。一般把多个处理过程的响应封装为单一函数。
对于支持实现对应 Shell 的窗口封装为窗体（Form）类（一般继承自 YWindow 类），在该自定义类中添加所需的 GUI 部件的定义，并实现界面效果。
在响应 SM_CREATE 或 SM_ACTIVATED 的处理过程中添加需要初始化的资源或子 Shell ，在 SM_DEACTIVATED 的处理过程中添加退出程序或转移线程控制权的指令。
在响应输入等事件消息的处理过程中添加对应的代码。

*/
////

