/*
	Copyright by FrankHB 2009 - 2013.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Designation.txt
\ingroup Documentation
\brief 设计规则指定和说明。
\version r8379
\author FrankHB <frankhb1989@gmail.com>
\since 早于 build 132
\par 创建时间:
	2009-12-02 05:14:30 +0800
\par 修改时间:
	2013-05-22 09:36 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Designation
*/


/*

@0 体例和适用范围：
引用标记参见 [Documentation::CommonRules @@0.1] 。
 YSLib 项目(the YSLib project) 包括 YFramework 和 YBase 。
本文档适用于 YFramework 的开发。除非有特别说明，编码细节和其它规范也适用于 YBase(@5.2.1) 。

@1 设计：

@1.1 设计的基本原理和表达形式：
设计的出发点：构建一个可复用的组件组成的库框架。
代码不保证语义角度（例如实现需求）内容的连贯性。
原始目的：在以标准 C++ 环境（宿主实现或独立实现）为基础的嵌入式设备等平台上，建立常规应用程序框架。
扩展目的：渐进地向独立的计算机软件系统演进，探究具有高度互操作性的系统的一般实现方法。

@1.1.1 设计原则：

@1.1.1.1 规约视角：
仅向内廪语义耦合：使用列举外延定义概念前必须提取清晰的内涵，同时避免和其它概念的耦合。
避免重复冗余：语义允许忽略差异的应保持同一性(identity) 的概念和实体不应存在别名以外的副本。

@1.1.1.2 组件视角：
层次封装：组件可分为若干层次，在任意层次上都需要保持对满足一定接口约束的同类组件的可替换性（如果可能，也适用于库的外部依赖项）。
任务关联：允许对完成一种任务提供多种接口，但应尽量能在足够明确的限制条件下找到单一最佳实践。

@1.1.1.3 用户视角：
给用户提供选择的自由。
信任用户，给用户提供服务而不是检查用户的行为。（类似 C 和 C++ 的设计哲学。注意这点同时也允许未定义行为。）

@1.2 理论背景、工具和依据：
基本内容参见 [Documentation::CommonRules @@2.1] 。
表现以下设计意义：
环境隔离：对特定领域相关的上层源代码提供一致的接口。
抽象和封装：提供控制流实体语义的抽象；提供用于封装上层平台相关的模块的支持。

@1.2.1 组织概念模型：

@1.2.1.1 平台无关的组织分类：
框架核心称为 Core ；
其它必须直接基于 Core 之上一些外围功能实现程序是 Shell ；
和框架核心之间没有整体依赖性（依赖在逻辑上可被其它组件替代）的部分称为 Service 。
 Shell 和 Core 应保持相对独立，以方便移植。

@1.2.1.1.1 相对性：
Shell 和 Core 的关系是相对的，例如：
操作系统上层（最终）用户界面和服务相对于操作系统内核(kernel) ；
基于操作系统 Shell 的应用程序相对于操作系统 Shell 。
这样， Shell 和 Core 之间的相对关系可以级联。对组织虚拟化程序架构等有一定意义。

@1.2.1.2 环境(environment) ：
程序中的某一部分的外界称为环境。
根据限定程序的范围，可以有更确切的概念定义，如实现环境（对于一类语言实现而言）、运行时环境（对于共享实现环境的一类程序而言）。
一般地，实现环境可以分为独立环境(freestanding environment) 和宿主环境(hosted environment) ，区分依据为是否依赖于宿主（对于部署在单一计算机上的实现，一般指操作系统）的支持。
因此，环境有时指操作系统及其提供的外部服务的集合。
一些语言，如 ISO C 和 ISO C++ ，可以同时支持宿主环境和独立环境的实现，对应地独立实现(freestanding impementation) 和宿主实现(hosted impementation) 。

@1.3 构建原则：
基本内容参见 [Documentation::CommonRules @@2.2] 。

@1.3.1 可移植性相关：
基本内容参见 [Documentation::CommonRules @@2.2.2] 。
语言使用规则参见 [Documentation::CommonRules @@5] 。

@1.3.2 环境依赖性：
关于环境，参见 @1.2.1.2 。
关于库配置，参见 @5 。
本节适用于 YSLib 库，用户程序不受此限制。
不使用和 ISO C++11 不相容的特性，包括 export 关键字([Documentation::CommonRules @@5.7.6]) 和已经在 ISO C++03 中标记为 deprected 而在 C++11 去除的特性（如 const char 数组类型左值到 char* 右值的转换）。
 YSLib 程序默认基于 ISO C++03 环境和基本的底层系统接口（由 YCLib 支持）。
依赖 ISO C++ 独立实现或宿主实现，附加以下例外：
需要 @1.3.2.1 列出的扩展支持；
库要求等同于 ISO C++11 定义的宿主实现；
需要定宽整数 std::intN_t 和 std::uintN_t （其中 N 为 8 、 16 、 32 或 64 ）支持（ ISO C++11 中为可选支持）。

@1.3.2.1 需要使用的非 ISO C++03 扩展：
定义于 ISO C99（ISO/IEC 9899:1999）和 ISO C++11（ISO/IEC 14882:2011）中，且有一个以上完整的语言实现。
 C99 preprocessor(N1653) ；
 Static assertions(N1720) ；
 Right angle brackets(N1757) ；
 long long(N1811) ；
 Built-in type traits(N1836) ；
 auto-typed variables(N1984) ；
 Delegating constructors(N1986) ；
 Extern templates(N1987) ；
 Generalized constant expressions(N2235) ；
 Variadic templates v0.9(N2242) ；
 New character types(N2249) ；
 Declared type of an expression v1.0(N2343) ；
 Defaulted and deleted functions(N2346) ；
 Strongly-typed enums(N2347) ；
 nullptr(N2431) ；
 Explicit conversion operators(N2437) ；
 Unicode string literals(N2442) ；
 New function declaration syntax for deduced return types(N2541) ；
 Initializer lists (N2672) ；
 Non-static data member initializers (N2756) ；
 Rvalue references v3.0(N3053) ；
 Lambda expressions and closures v1.1(N2927) ；
 Range-based for(N2930) ；
 Converting Lambdas to Function Pointers(N3052) ；
 Explicit virtual overrides v1.0(N3272) 。
接口和实现仅使用 ISO C++11 中头文件 <array> 、 <atomic> 、 <chrono> 、 <condition_variable> 、 <forward_list> 、 <mutex> 、 <thread> 、 <type_traits> 、 <tuple> 、 <unordered_map> 、<unordered_set> 和 <utility> 的特性。

@1.3.2.2
 YSLib 的源代码的本体(@2.1) 是平台中立([Documentation::CommonRules @@2.2.2.1]) 的。其中的一部分在冯·诺依曼体系结构的现代数字式电子计算机的范畴内是平台无关的。

@1.3.2.3
格式化输出及结构对齐时注意平台字长差异。

@1.3.3 可维护性和架构设计：
基本内容参见 [Documentation::CommonRules @@2.2.3] 。
语义相关的架构参见 [Documentation::CommonRules @@2.3.2] 。

@1.3.4 实现功能特征概述：
便于扩展。
尽可能地平台无关，且注重效率。
能够保持必要的运行时安全性。
实现一部分的通用较高级功能，例如消息机制(@1.4.1.3) 。

@1.4 通用语义：
基本内容参见 [Documentation::CommonRules @@2.3] 。

@1.4.1 运行时程序模型：
除以下部分外由具体项目定义。

@1.4.1.1 运行时程序结构和部署模型：
 YSLib 中讨论可部署的程序的基本单位是 Shell(@1.4.4.2) 。
 YSLib 基于单一进程和单一线程的运行时程序结构，类似于单内核操作系统；但内部实现是微内核至无内核的，除了主循环，任意一个 Shell 都可以独立部署。
在适当的平台上通过扩充能实现多个独立的二进制实体并行运行的多进程程序。

@1.4.1.2 并发模型：
基于可移植性和易用性的考虑， YSLib 并发语义的表达不包括作为机器模型的语言和库特性提供的线程模型的直接使用，而以角色模型进行并发抽象的问题模型。
对于 Shell 内部的操作，不存在共享状态的竞争条件，无需进行加锁操作，避免死锁、活锁和优先级反转等问题。即 Shell 本身使用单线程。
由于语言的限制，无法直接表达任意的并行语义，从而无法有效实现真并发行为。真并发行为可能由平台相关的扩展 API 实现。
 YSLib 仅提供有限的调度设施保证，通过加入线程模型相关的设计和实现，进程内的控制流实体保持是可扩充的和自洽的。

@1.4.1.3 消息机制：
基本内容参见 [Documentation::CommonRules @@2.5.3] 。
 YSLib 支持消息队列。
 YSLib 的消息被用于在 Shell 之间传递状态，称为 Shell 消息。
默认 Shell 消息列表参见 [Documentation::YSLib @@2] 。
消息、消息队列、消息分派和消息循环的实现参见 @2.5.10 。

@1.4.1.4 可重入性和线程安全性：
除本条外， YSLib 及其部分依赖项的可重入性和线程安全性参见 @2.6 、 @5.2 、 [Documentation::YSLib @@1.3] 和 [Documentation::CHRLib] 。

@1.4.1.4.1 一般准则：
中断服务例程应保证可重入性。
可重入和线程安全无必然联系。
对于单线程实现环境，不对线程安全性另行说明。

@1.4.1.4.2 例程和包含的可调用对象(callable object) 的调用：
仅包含可调用对象的调用时，此例程的可重入性和线程安全性等价于包含的所有调用：
包含可调用对象的调用时，此例程可重入，仅当包含的所有调用可重入。
包含可调用对象的调用时，此例程线程安全，仅当包含的所有调用线程安全。

@1.4.1.5 全局初始化：
除另有说明，仅保证可重入的调用可用于全局初始化。

@1.4.2 资源分类：
基本内容参见 [Documentation::CommonRules @@2.3.2.2] 。
 YSLib 对于资源的直接使用仅限软件资源（硬件资源通过语言抽象和 YCLib 等平台兼容层包装后间接使用）。

@1.4.3 资源管理：
基本内容参见 [Documentation::CommonRules @@2.3.2.3] 。
 RAII 在异常安全和可维护性等方面具有其它方法不可替代的优势，因此是 YSLib 中最主要使用的资源管理惯用法。

@1.4.4 Shell ：
在 YFramework/YSLib 中， Shell 有多种含义。
如无特殊说明一般指 @1.5.1.1 。

@1.4.4.1 组织分类：
参见 @1.2.1.1 。

@1.4.4.2 程序实体：
 Shell 实体（简称 Shell ）是一种包含状态的有限片段控制流抽象，是动态映像(@1.5.1.1) 或静态映像(@1.5.1.2) 之一。

@1.4.3 会话(session) ：
会话是连接对象([Documentation::CommonRules @@2.5.4]) 或其它会话具有直接所有权的实体集合，通常用于在一段时间间隔内跟踪连接的客户端的操作。

@1.4.3.1 网络通信会话：
网络通信会话是半持久化的数据交换的抽象。
会话的连接用于网络通信。
它可能被基于特定的协议上实现。

@1.4.3.2 用户登录会话：
保存特定用户使用计算机的状态的抽象。

@1.4.3.3 用户界面会话：
用户界面会话是对用户在特定界面操作状态集合的抽象。
会话的连接用于在界面逻辑状态和输入/输出缓冲区之间通信。

@1.4.3.4 会话的实例：
桌面会话是典型的用户界面会话。
浏览器会话包含客户端的网络通信会话和用户界面会话。

@1.4.3.5 会话管理：
会话管理是人机交互中对抽象为若干会话的用户活动的追踪。它能重置或还原特定用户行为和操作下的状态。

@1.5 YSLib 模型抽象：
本节讨论具体的基本特性相关的模型抽象。

@1.5.1 框架抽象：
本节描述框架组成成分的抽象。

@1.5.1.1 Shell 动态映像：
 Shell 作为被执行的程序称为 Shell 的动态映像。一个 Shell 动态映像的实例称为 Shell 对象，是运行时控制流映像，用于表示一段时间间隔（称为生存期）内计算机系统当前处理的任务。
 Shell 对象是程序的基本调度单位之一。不同于进程/线程等具体的任务实体，它仅是表示可执行的程序的高层抽象，并不限定环境(@1.2.1.2) 对共享资源的分配方式。
实现形式上 Shell 对象，可以是进程/线程等和体系结构关联更彻底的方式，但这并非其内涵。

@1.5.1.2 Shell 静态映像：
储存 Shell 动态映像中执行的代码的非运行时映像实体称为 Shell 静态映像。
实现形式上， Shell 静态映像可以是可执行文件中的代码片段或内存中的流，但这并非其内涵。
它可以作为构建程序时复用的单位。因此可以用于组织分类(@1.4.4.1) 。
注意 YSLib 中的实现 Shell 实体的基类 Shell 属于组织意义上的 Core 而非 Shell ，位于 "/Core" 。

@1.5.1.3 Shell 对象的执行状态：
一个 Shell 对象被调度的时间间隔不一定等于它的生存期，可能是其中的一部分。
因此， Shell 对象不仅表示活动的（当前正在运行的）运行时状态，还可以储存非活动的运行时状态。
在某个确定的时刻，一个 Shell 对象具有以下执行状态之一：不处于可被有效调度时的非活动态和处于可被有效调度时的活动态。
新建的 Shell 对象默认具有非活动态。
对于单线程的实现，同一时刻有且仅有一个 Shell 对象处于活动态。

@1.5.1.4 Shell 状态切换：
 Shell 对象由非活动态至活动态的转换过程称为激活(activation) ；活动态至非活动态的转换过程称为停用(deactivation) 。激活和停用合称为 Shell 状态的切换(switching) ，简称 Shell 切换。
 Shell 切换要求 Shell 具有完整的存储和正常的生存期。

@1.5.1.5 Shell 通信：
 Shell 的必要的基本通信机制是消息机制(@1.4.1.3) 。
使用消息机制， Shell 切换是用户程序可知的(@2.5.11) 。
用户可以自定义具体 Shell 的特定机制。
 Shell 可能是连接对象([Documentation::CommonRules @@2.5.4]) 。

@1.5.1.6 Shell 类和 Shell 对象生存期导致的限制：
 Shell 被设计为一个 C++ 多态类。
默认不在 Shell 内部保存激活或停用状态，而由外部控制。
在 C++ 中应注意以下几点：
一个类类型对象的生存期起始于构造调用结束后，构造函数中的操作是受限的（例如无法正确地调用虚函数）；
构造函数允许抛出异常。
因此：
 Shell 切换(@1.5.1.2) 时无法新建 Shell 对象且是无异常抛出保证([Documentation::CommonRules @@5.20.5.4]) 的；
激活和停用有必要明确地区分于构造和析构。
特定的 Shell 可作为 ISO C++11 30.2.5.1/1 定义的执行代理(execution agent) 。

@1.5.1.7 Shell 的应用场景：
 Shell 表示一类任务，可作为程序中的可重用组件存在。
 Shell 可在一段时间间隔内作为保存程序执行中公共状态的实体，类似于 Microsoft Windows 的会话(session) 或窗口站(window station) 。
 Shell 可以是会话(@1.5.1.8) 。

@1.5.2 显示模型：
本节描述显示特性相关的抽象。

@1.5.2.1 二维输出设备参照坐标系：
表示输出平面，使用二维欧几里得空间的视图坐标系。
逻辑上，坐标值是纯量，是实数或其子集的元素。对于实现而言也可能包括非数学量（如浮点数的无穷值）。
若无额外说明，同一个坐标系内的两个坐标值的取值范围相等。
若无额外说明，以输出设备相对于用户的最左上角为原点(0, 0) ，横坐标正方向向右，纵坐标正方向向下。
最基本的实例是屏幕坐标系。

@1.5.2.2 部件坐标系：
相对于输出所在屏幕的屏幕坐标系直接平移变换得到的坐标系。
注意原点相对于屏幕坐标系的坐标分量可以有负值。

@1.5.2.3 标准矩形(canonical rectangle) ：
边和二维输出设备坐标系共线的矩形。
一般地，可以使用四个纯量表示，如表示左上角的点坐标和长、宽，或表示对角线端点的两个点坐标。

@1.6 组件和界面设计概述：

@1.6.1 UI（User Interface ，用户界面）设计：
为了适应不确定数量的输出设备，特定的 Shell(@1.2.1.1) 可以用于实现程序中处理 UI（User Interface ，用户界面）行为，称为 UI Shell 。
输出特性依赖于部件坐标系(@1.5.2.2) 。
用于实现 UI 的 Shell 一般也包括实现相关消息处理。
和 Shell 相对的 Core 不直接参与实现 UI 。

@1.6.2 GUI（Graphical UI ，图形用户界面）设计概述：
界面实现使用称为 Shell-Widget 的模式，是精简的主动模型-视图-控制器模式的变体，参照窗体-控件模式。但架构模式无本质变化。
界面实现解决的三个问题：安排状态(state) 、逻辑(logic) 和同步(synchronization) ，都可以在运行期配置。
为了方便复用，这些属性有如下分类：
根据是否依赖于具体的 Widget 实例分为实例的和公共的；
根据是否能被所有 Widget 类共用分为公用的和专用的。
这些属性也适用于用于实现的构件。
强化了编译期可配置性。
基于性能考虑，仅在少数必要处实现观察者模式。
默认公共 UI 状态通过 YGUI 单元的 GUIState 类实现。

@1.6.2.1 模型(model) ：
模型表示数据模型(data model) ，保证和领域逻辑(domain logic)/业务逻辑(business logic) 具有合理的关联。
模型和其它部分是适当分离的，模型不被依赖，或仅被专用视图或控制器依赖。

@1.6.2.2 视图(view) ：
视图用于向用户呈现数据，保持用户界面状态。
视图在 GUI 响应（如具体实现 [Documentation::YSLib @@3.3.3] 和 [Documentation::YSLib @@3.3.5] ）中不会修改模型，但可以向控制器提交状态。
部件类实现了基本的视图。通过派生或修饰这些类可以得到扩展的视图。
通常约定视图在显示设备上呈现矩形区域。

@1.6.2.2.1 视图组织：
构件对象的视图之间的联系组成的抽象整体（是一个图）称为视图组织。
为了便于实现中以遍历为基础的算法能可靠结束，视图组织一般应是受限的、带层次的有向树（约定相邻层次的节点由父节点指向子节点），称为视图树。
一旦存在环路，对视图的某些操作可能导致未定义行为。
视图树的节点之间表示的显示范围存在约束。子节点可表示的区域是父节点的子集。

@1.6.2.3 控制器(controller) ：
控制器完成界面状态和模型状态的同步，保持根据用户在视图中的行为更新模型的逻辑。
若有必要，控制器可以保持状态。模型和视图不能直接修改控制器的状态，但可以提交状态等待控制器自行更新。

@1.6.2.3.1 公用控制器：
公用控制器用于实现公用输入逻辑，并储存了相关状态，是 UI Shell(@1.6.1) 的重要组成部分。
用户输入由公用控制器而不是视图进行直接处理。公用控制器转发处理的结果到专用控制器(@1.6.2.3.2) 中以便被进一步处理。
公用控制器是公共的，不依赖于实例。
专用控制器依赖于公用控制器的行为，但不依赖其实现。

@1.6.2.3.2 专用控制器：
专用控制器用于实现特定 Widget 的较高层 UI 行为。

@1.6.2.3.2.1 专用公共控制器：
专用公共控制器用于实现 Widget 类特定的较高层 UI 行为。

@1.6.2.3.2.2 专用实例控制器：
专用实例控制器用于实现 Widget 实例特定的较高层 UI 行为。一般位于部件(@1.6.2.5) 中。

@1.6.2.4 Shell-Widget 模式：

@1.6.2.4.1 Shell 状态和控制器：
 Shell 负责保存所有 GUI 之间的公用状态（如拖曳位置），并集成保存公用逻辑的公用控制器。它们都是公共的，不依赖于 Widget 实例。

@1.6.2.4.2 Widget 状态、控制器和视图：
 Widget 负责保存单一的 GUI 非公用状态、视图的直接实现，并集成保存专用逻辑的专用控制器用于在一定范围内动态配置 UI 的行为。
专用公共逻辑可能是多个 Widget 中相同的。
专用公共状态可能是多个 Widget 之间共享的([Documentation::CommonRules @@2.3.3.2]) 。
视图总是实例的，它自身有且仅有两种状态：已经被同步或未被同步。

@1.6.2.4.3 数据流和响应流程：
输入数据流首先被 Shell 的公用控制器响应；若有必要，更新公用状态。然后，转发至 Widget 。
 Widget 的专用控制器对输入进行响应；若有必要，更新非公用状态。（通常是公共的）专用控制器可能更新公用状态。根据此状态同步视图，并决定对输入数据的修饰以及是否转发至下一层次的 Widget 。
因为 Widget 之间的视图组织是有限的，所以当不存在环路时，以上流程应在有限时间内完成。
 Shell 的其它部分实现使视图更新至显示设备的输出调用。

@1.6.2.5 构件实体(part entities) ：
实现中 Shell-Widget 模式中作为 Widget 的角色。相较于典型的窗体-控件模式， GUI 控件(controls) 退化为部件(widgets) ，部件退化为组件(components) ，进而分离可视属性，抽象出独立于这些构件的部件特征，细分功能以实现高度可配置性。
一般的组件、部件和控件等实体在此统称为构件(parts) 。
 YSLib 本身不提供大量成熟的控件，而是着重提供可供组装为控件的基本 GUI 类（部件模块类）、部件类、在部件基础上衍生的构件以及部件简单组合的组件。这些用户界面元素(UI elements) 不一定具有消息处理或事件响应的功能，因此可以不是控件；参见 @1.6.2.6 。
控件主要由用户通过组装以上的构件定制。

@1.6.2.5.1 组合构件(compound parts) ：
可以自定义任意的模型类来组装部件、控件或其它用户界面元素。
但是，并非每一个成分都是必须的。某些成分可能在具体的类的外部实现。
若组合的结果能处理消息或响应事件，同时能够呈现界面数据，那么就是控件。

@1.6.2.5.2 构件容器(containers) ：
构件容器是能以引用等方式在逻辑上包含构件的构件实体。被包含的构件称为包含构件的子构件。
组件容器是组件。部件容器是部件。控件容器是控件。

@1.6.2.6 构件组织(parts construct) ：
和视图组织(@1.6.2.2.1) 类似，部件之间存在的联系组成的抽象整体（是一个图）称为构件组织。
类似地，构件组织一般应是受限的、带层次的有向树（约定相邻层次的节点由父节点指向子节点），称为构件树。
部件的构件组织用于视图组织的实现。其它非部件的构件组织同样可具有树形结构，但（默认）不具有类似的实现。

@1.6.2.7 场景(scenes) ：
场景是任意两个节点具有至少一个直接依赖的构件组织的非空子集。
由定义，场景是非空连通图。

@1.6.2.8 焦点(focuses) 概述：
焦点在部件容器（称为焦点上下文）中对 GUI 对象的标识。
控制器根据焦点选择当前操作（通常是输入）作用的对象。
由于在一个焦点上下文中可能包含多个子上下文（参见 @1.6.2.6 ），因此可能有多个焦点。
对于视图树而言，通过迭代访问焦点对象可以得到唯一的路径，称为焦点活动路径；其中的焦点称为活动路径焦点。末端的活动路径焦点称为活动焦点，在确定状态下若存在，则是唯一的。

@1.6.3 目标风格与最佳实践：
本节概述基于 @1.1 和 @1.3 的约束下，组件和 UI 库接口设计的总体风格和对用户代码的影响。

@1.6.3.1 引用参照：
 Ultimate++ ： http://www.ultimatepp.org/www$uppweb$overview$en-us.html 。

@1.6.3.2 库依赖性：
除非必要，尽量使用标准库。例外情况下应该提供充足理由，并对用户自行替换底层接口和实现提供一定的便利性。

@1.6.3.3 资源管理：
基于对象所有权，方法参见 @2.2.2 。
基于和 Ultimate++ 相同的理由，接口不使用智能指针，且用户代码而不是被依赖的组件决定部件对象的所有权从属。
但总体风格上没有限定作用域和所有权的严格对应关系，也因此能够自然地使用部件指针的标准库容器。这点同时简化基于迭代器模式的实现。
此外， YSLib 不排斥在部件实现([Documentation::YSLib @3.3]) 中提供（有限的）复制和转移支持以保证值语义。

@1.6.3.4 泛型值类型：
适当使用 YBase(@5.2.1) 提供的基于类型擦除的泛型值语义对象 ystdex::any 等类型实现。允许空值。

@2 框架库概览：
本章描述 YSLib 项目中的 YFramework 框架库。支持库参见 @5 。
模块化设计原则参见 [Documentation::CommonRules @@3.7.1] 。
一个模块目录([Documentation::ProjectRules @@3.2]) 中的模块组成一个系统。
关于一些文件的文件名的额外约定参见 @2.1 。

@2.1 框架组成和依赖项规则：
 YFramework 可分为几个目录表示具有特定功能集合的库的子集。在讨论具体目录下的库时，路径表示以此库的根目录。
其中最核心的部分是 YSLib 库，除了本文档描述外，参见 [Documentation::YSLib] 。
对于 YFramework 集成的第三方库(@5) ，位于 "/3rdparty/" 目录下。其它部分位于 "/YFramework/" 目录下。例如 YSLib 位于 "/YFramework/YSLib/" 目录下。
 YFramework 依赖于外部项目，包括平台支持和基础库 YBase ，参见 @5 。
 除了 YSLib 和第三方库， YFramework 也集成了一些辅助的库。其中一部分不依赖于 YSLib ，包括 CHRLib 和 YCLib ；另一部分依赖于 YSLib ，包括 NPL 和 Helper 。具体说明参见 @5 。
 YSLib 中，目录 "/YFramework/Adaptor/" 下的部分称为 Adaptor [Documentation::YSLib @@2] ，其它部分总称为本体，是平台中立的。
 Adaptor 的接口是平台中立的，但 Adaptor 的改变很可能导致整个本体中的很一大部分翻译单元的重新编译。
因此除非是用来实现基本功能的外部的库，新增的平台相关的部分应尽量放在外部的 Helper 库(@2.6) 而不是 Adaptor 中。
除非另有说明，仅保证非成员函数（排除声明紧随于某个类之后，首个参数为该类类型引用的人本接口）和静态成员函数的可重入性和线程安全性。
以下节指定 YFramework 中明确或明确禁止依赖的文件。关于 YBase 的文件依赖性参见 @5.2.1.2 。

@2.1.1 基本代码依赖性（适用于 YFramework 内部）：
 YSLib 文件中，文件名以 y 或 Y 起始且非限定模块名以 Y 起始的文件为必要文件，其它为非必要文件。必要文件必须被 YFramework 内的至少一个其它文件依赖。
关于 ISO C++ 2011 直接指定的依赖项，参考 [Documentation::CommonRules @@5.25.2] 。
以下为基本代码依赖性规则（以优先级顺序排列，即后者不满足前者的部分以前者为准）：
除非另有说明，禁止依赖于（包括包含）非头文件。
除非另有说明，禁止重复包含同一文件，避免造成循环依赖。
 YSLib/Adaptor 中的 config.h 不依赖 YCLib/Platform.h 以外的其它文件，仅可被 YSLib/Adaptor 中的头文件直接包含。
任意 YFramework 文件可依赖 @2.1 余下部分指定的标准库头文件以及 YBase 头文件。
必要文件不依赖非必要文件。
 YCLib 中除 YCLib/Platform.h 外的文件仅可被 YCLib 、 YSLib 和 Helper 依赖。
除 YSLib/Adaptor/yadaptor.h 外， YSLib/Adaptor 头文件不依赖 YCLib/ycommon.h 以外的 YCLib 文件。
 YSLib/Adaptor 头文件可依赖 YFramework 文件或标准库实现的非标准头文件。
本体头文件不依赖 YSLib 以外的文件。
 Helper 文件和本体的非必要源文件可依赖除 YSLib 和 Helper 外的 YFramework 其它文件（包括 YCLib 文件）。
 YCLib 和 Helper 文件可依赖具体平台相关的文件。
关于 YSLib 的文件依赖性，参见 [Documentation::YSLib @@1.2] 。

@2.1.2 YFramework 引入的命名空间：
 platform ：平台中立：接口平台无关但实现平台相关的实用程序。 YSLib 本体间接依赖于此命名空间。
 platform_ex ：接口和实现都平台相关的实用程序。 YSLib 本体不依赖于此命名空间。
 CHRLib ：子库 CHRLib 的命名空间。 YSLib 本体直接依赖于此命名空间。
 NPL ：子库 NPL(@2.7) 的命名空间。
 YSLib ： YSLib 库命名空间。

@2.2 实体实现规则：

@2.2.1 对象准则：
局部对象在声明时同时初始化。
函数内变量尽可能置于最小作用域内——除非效率原因，尽可能使用语句块级对象代替函数级局部对象。
避免在嵌套类中定义被嵌套类的定义，除非能够确保此定义的实现无关性。
有依赖关系的全局对象应置于同一编译单元内。
禁止使用函数返回值初始化全局对象。
除非程序明确为单线程的，禁止使用非 POD(plain-old data) 类型的全局对象。若非必要，用内建 (built-in) 类型代替 POD 结构体全局对象。
多线程程序中，禁止使用非 const 全局对象。

@2.2.2 对象引用和所有权管理：
基本概念参见 [Documentation::CommonRules @@2.3.3] 。
注意基于非透明引用计数实现的非侵入式智能指针（如 boost::shared_ptr/std::tr1::shared_ptr 以及 C++11 的 std::shared_ptr ）具有以下固有的缺点：
无法修改引用计数并直接转移所有权，资源实例的生存期依赖于至少一个具体智能指针对象的生存期；
资源实例对智能指针对象的上述依赖性导致智能指针类型入侵用户程序接口；
并非完全的非侵入式实现（例如可能依赖于 enable_shared_from_this 等），可能入侵客户资源实现，导致耦合扩散；
用户程序无法显式指定引用计数操作而造成不必要的性能负担（特别是异步流程中，无法进行基于调用栈的引用计数优化）。
为了克服前三个缺点，可以使用侵入式方案代替，但可能会引起额外的编码复杂度。最后一个缺点所在的场景一般不适合使用引用计数策略（尽管改用侵入式引用计数方案可能减小开销）。
因此 YSLib 仅在必要时使用基于此类智能指针实现的句柄，如跨 Shell 资源传递（包括 Shell 类实例本身）。
注意此时尽管和非句柄意义下的智能指针类型相同，但意义不同，除特殊情况外（如和内建指针直接比较；需在对应实现处注释）应避免通过 get 成员或 ystdex::raw 等直接使用对应的内建指针值。
对于需要保持所有权但又要避免重复引用计数的开销的情况，使用 std::unique_ptr 。
其它情况下，使用不含所有权的内建指针，以保持用户程序对资源管理的选择自由和灵活性。若没有在注释或文档注明所有权关系，均应视为由用户程序对象具有指针参数指向对象的所有权。

@2.2.2.1 所有权标签：
以下独占所有权关系中，被托管对象类不是直接的成员或明确具有所有权语义的指针指向的对象。使用 OwnershipTag 模板标识这些类型。
所有者（基类）中 private 继承了 OwnershipTag<_type> 。被托管对象的实际类型可能是 _type 的派生类。实例包括：
 Drawing::FontCache 具有 Drawing::Typeface 和 Drawing::FontFamily 的所有权；
 UI::MenuHost 具有 UI::Menu 的所有权；
 Text::TextMap 及其派生类 Text::TextFileBuffer 具有 Text::TextBlock 的所有权。
可以使用 HasOwnership<_tOwner, _type> 判断 _tOwner 是否具有 _type 成员的所有权。

@2.3 语言特性扩展支持：
位于 YBase(@5.2.1) 或 YFrameowrk::YSLib::Core(@2.5) 中。

@2.3.1 接口

@2.3.2 断言

@2.3.3 成员函数简写（代码生成器）

@2.4 类型构建：

@2.4.1 基本约束：
命名必须和标识符命名规约(@4) 兼容。

@2.4.2 类型特性：
除了 I 和 A 前缀的类，都不含有纯虚函数。
命名中按以下列出的顺序确定分类。

@2.4.3 I 前缀类名的类：
接口类型([Documentation::CommonRules @@2.4.1]) 或纯虚类。

@2.4.4 A 前缀类名的类：
抽象类。
成员函数中至少存在一个纯虚函数；不能被实例化。

@2.4.5 S 前缀类名的类：
静态类。
除了类型定义外，应仅包含静态成员。但编译时不作检查。
可参与多重继承，例如作为特征类(traits class) 。

@2.4.6 M 前缀类名的类：
模块类。
具有 public 或 protected 的无参数（或所有参数都有默认参数）的构造函数。不一定能够被复制构造（可能显式地被禁止）。
用于提供实现而非规范接口，可定义人本接口成员。
作为混入(mixin) 类的实现：强调可以参与多重继承组合为其它模块类和一般构件类，也包括被参数化（作为模板类型参数）以构建这些类。
当作为非多态类时析构函数应为 protected （除非它的所有派生类都没有在它的基础上扩展域，或都满足析构函数为 protected ），且不可作为类的成员或被实例化。
其它情况下可实例化，但通常仅用于作为类实例的子对象（混入实例）。此时应尽可能减少虚表体积，并降低额外的运行时效率开销（例如，不使用引用类型的成员）。

@2.4.7 H 前缀类名的类型：
从属于相近但不同的两类：
句柄(handles) ：具有间接访问语义的类型（例如指针、引用或迭代器）。
处理器(handlers) ：具有回调功能的类型（例如事件处理器或 std::function 的实例）。

@2.4.8 无前缀类名的类型：
一般类型。
其它类型。无其它限制和特性保证。

@2.4.9 异常类总览：
专用于被 C++ 异常机制捕获的类称为异常类。
异常类不一定在特定的命名空间中定义，但 YSLib 集中使用某些异常，参见 [Documentation::YSLib @@3.1.5] 。

@2.5 字符表示结构支持库 CHRLib ：
位于 "/CHRLib" 。非外部依赖项。
支持字符相关构造（编码和字符集等）的抽象。
支持特定编码字符串的转换。
参见 [Documentation::CHRLib] 。

@2.6 助手(Helper) 库：
位于 "/Helper" 。非外部依赖项。
可能平台相关的外部库，可以提供宿主实现、加入插件等，一般由库用户自行配置。
除非另有说明，仅保证必要文件(@2.1.1) 提供接口中的可重入性和线程安全性同本体(@2.1) 。其它文件应明确非成员函数和静态成员函数的可重入性和线程安全性。
 YGlobal 是不可缺少的，它封装了必要的全局对象。
 main 函数由 Helper 的其它源文件封装，或由用户提供。
 Helper 定义的类型若适用于不同平台，不保证二进制兼容性，除非另有说明。

@2.6.1 YGlobal 单元：
平台相关的全局对象和函数定义。
除了以下接口，其它都是不确定的：
const SDst MainScreenWidth, MainScreenHeight;

unspecified_class_type&
FetchGlobalInstance() ynothrow;

bool
InitConsole(Devices::Screen&, Drawing::PixelType, Drawing::PixelType);

这里 FetchGlobalInstance 返回类型为平台相关的应用程序类的引用。
 YSLib 不依赖这些接口以外的特性。

@2.6.2 Application 派生类：
适应于具体平台的应用程序实例抽象。
包含默认消息循环等。

@2.6.3 初始化 Initialization ：
参见 [Documentation::YSLib @@6] 。

@2.7 NPL 库：
实现基于 S 表达式的名称协议语言，当前仅用于用户配置设置。

@3 API 设计和风格概述：
基本规则参见 [Documentation::CommonRules @@3] 。

@3.1 类 C 标准库接口：

@3.1.1 内存管理行为：
接口不符合无隐式 malloc 规则 [Documentation::CommonRules @@5.25.3.1] 时必须向用户明确存储所有权。

@3.2 C++ 函数和函数模板：

@3.2.1 成员最小接口：
为了利用以类为单位的封装性（包括访问权限控制），一般类内的成员函数以最小接口为主，而人本接口在类外紧接类定义声明为第一个参数为类的引用类型的非成员函数。
可以适当使用友元简化接口和实现。

@3.2.2 函数参数：
尽量避免使用输出参数，特别是在最小接口中。
合理使用默认函数参数减少需要的函数重载版本。

@3.2.3 模板参数：
合理使用 ISO C++11 支持的函数模板的模板默认参数简化实现，减少需要的函数重载版本。

@3.2.4 SFINAE(substition failure is not an error) 技巧：
使用 SFINAE 进行类型检查，实现复杂的重载匹配。避免暴露过于复杂的接口。
在模板参数或函数参数中使用 ISO C++11 的 std::enable_if 实现 SFINAE 。需要考虑函数签名时，只能使用前者；需要考虑模板和非模板的匹配顺序时，一般使用后者。

@4 标识符命名规约(naming convention) ：
以下是 YSLib 风格标识符的命名规则和约定。

@4.1
参见 [Documentation::CommonRules @@4.1] 。

@4.1.6
基本内容参见 [Documentation::CommonRules @@4.1.6] 。

@4.1.6.1
以 "_y" 起始的标识符保留给 YSLib 库内部实现使用。

@4.1.6.2
以 "INCLUDED_" 起始的标识符专用于头文件包含标识。

@4.1.6.3 模板形式参数前缀：
以下前缀保留给的标识符保留作为模板形式参数的名称：
 "_b" ：布尔类型参数；
 "_f" ：函数/可调用对象(callable object) 类型参数；
 "_i" ：接口（纯虚类）类型参数；
 "_p" ：内建指针类型参数；
 "_r" ：引用类型参数；
 "_t" ：不保证以上类型的其它类型参数；
 "_g" ：泛型类型（模板）参数；
 "_gi" ：泛型接口（纯虚类模板）参数；
 "_gf" ：泛型函数/仿函数模板参数；
 "_v" ：其它非类型参数（值参数）。

@4.1.7 惯用函数命名：
基本内容参见 [Documentation::CommonRules @@4.1.7] 。

@4.1.7.3 YFramework 约定：

@4.1.7.3.1 模式 Fetch* ：
除了 YSLib 中非本体部分，命名空间作用域函数名 Fetch* ：语义近似于 Get*Of ，但遵循以下附加规则：
函数名符合模式 Fetch*Ref 的，返回类型为目标类型的引用或 const 引用类型；
函数名符合模式 Fetch*Ptr 的，返回类型为目标类型的指针、 const 指针或对应的智能指针类型；
目标类型为 POD 类型的，返回类型为目标类型；
其它情况返回类型为目标类型的引用或 const 引用类型。

@4.1.7.3.2 模式 Make* ：
类似 ISO C++ 标准库中的 make_* 。

@4.2 宏名：
基本内容参见 [Documentation::CommonRules @@4.2] 。

代码生成器：用宏展开为一段声明或定义的代码。

@4.2.3 全局保留宏名：
使用 YSLib 前需要保证未定义，且之后无法使用，除非使用 #undef 取消定义。
 YSLib 保留宏名以 "YSL" 起始，其基础库使用保留宏名以 "YCL" 起始。

@4.2.3.1 局部保留宏名：
使用 YSLib 前需要保证未定义，但库实现使用 #undef 限制作用域，因此之后可以使用。
 "This" 和 "CThis" 。

@4.3 类型名：
参见 [Documentation::CommonRules @@4.3] 。

@4.4 标号：
参见 [Documentation::CommonRules @@4.4] 。

@4.5 函数名：
参见 [Documentation::CommonRules @@4.5] 。

@4.6 具名对象：
参见 [Documentation::CommonRules @@4.6] 。

@5 程序部署和用户配置：
依赖项相关定义参见 [Documentation::ProjectRules @@1] 。
项目管理相关定义参见 [Documentation::ProjectRules @@2] 。
本章描述 YSLib 项目中除了 YFramework/YSLib 以外的库。
 YFramework 内包含少量外部依赖性如 FreeType2(@5.4.1) 。
以下如无特别说明，非外部依赖项的根路径取 YFramework 包含目录或源代码目录。

@5.1 平台配置：
平台配置 YCLib 平台定义文件(@5.2.2.3.1) 中定义的可支持平台对应。
当前正式支持的平台：
非宿主实现平台 DS （ Nintendo/iQue DS/DS Lite/DSi/DSi LL 以及 PC 端模拟器 DeSmuMe 等）；
宿主实现平台 MinGW32 （对应三元组 i686-pc-mingw32 及其向前兼容的 i686-w64-mingw32 等）。
目前除了 MinGW32 外，仅使用静态链接库链接至静态或动态目标。

@5.1.1 配置管理：
基本配置管理参见 [Documentation::ProjectRules @@2.1]。
 MinGW32 为 DLL 目标追加对应 debug 和 release 的配置 debug_DLL 和 release_DLL 。

@5.2 基础库：
除了 ISO C++ 标准库外的非外部依赖项：
基于标准库的基础库 YBase ，包含基于标准库的平台中立的扩展 YStandardEx ，独立于 YFramework 。
基于 YBase 的平台隔离用库 YCLib ，包含于 YFramework 中。

@5.2.1 YBase ：
 YBase 除了公用头文件 YDefinition(ydef.h) 外，由 YStandardEx 、 LibDefect 和 YTest 子库组成。
 LibDefect 不保证可重入性，线程安全性由 ISO C++11 规范。
 YBase 和其它模块之间传递的对象类型满足 trivially copyable ，以保证动态库存储安全（参见 [Documentation::CommonRules @@3.7.2] ）。

@5.2.1.1 LibDefect 以外的设计和实现原则：
除了去除后不影响语义正确性和可观察行为的扩展，遵守 ISO C++ ，不使用不兼容于 ISO C++11 的特性或依赖于特定平台实现的接口。
注意 YDefinition 实现及判断语言特性的接口可能依赖于具体语言实现的特性限制。
关于当前允许使用的非 ISO C++03 扩展参见 @1.3.2.1 。
尽量严格遵守 ISO C++11 ，涉及未确定行为和实现定义的行为时应附文档说明。
除非另有说明， YBase 中 LibDefect 以外的接口仅保证非成员或静态成员函数的可重入性和线程安全性。
除非有显著性能问题，否则非成员或静态成员接口应保证线程安全性。
不降低性能时尽量保证可重入性。

@5.2.1.2 文件依赖性：
以下为基本代码依赖性规则按（以优先级顺序排列，即后者不满足前者的部分以前者为准）：
 ydef.h(@5.2.1.3) 仅依赖标准库头文件。
 LibDefect 不包含头文件或仅包含标准库头文件。
 YBase 依赖且仅依赖 YBase 文件和标准库头文件。

@5.2.1.3 YDefinition ：
模块 YBase::YDefinition ，文件名 ydef.h ，是其它 YBase 头文件的公共依赖项。
若其它文件不依赖此文件，则也不依赖其它 YBase 文件。
文件內容为系统环境和公用类型和宏的基础定义，包括对实现环境的检测、实现特性的封装、部分未被实现关键字替代以及一些语言层次上的公共基础设施。

@5.2.1.3.1 宏 yoffsetof ：
同标准库宏 offsetof ，但额外提供了对于可能导致未定义行为的检查。
某些实现（如 GNU C++ ）可能已经自行提供了内建检查，所以此宏并非必要。但为了一致性在库的代码使用此宏。

@5.2.1.3.2 宏 yunseq ：
用于标记无序列依赖表达式组，以支持非序列优化。
参见 [Documentation::CommonRules @@6.4.3.3] 。

@5.2.1.4 YStandardEx ：
 YStandardEx 直接扩充标准库，包含仅依赖于标准库而非标准库的接口。
实现的内容限制为以下两个部分：
适用范围最广的基础设施（比标准库更严格），如序列/非序列调用、通用类型转换、元类型、函数对象、迭代器；
直接基于标准库接口的抽象和封装，如输入/输出抽象。
所有更具体应用问题领域相关的或特定于运行时表达形式相关的操作，如形式语言处理等，都不由 YStandardEx 直接提供接口。

@5.2.1.5 LibDefect ：
用于修正依赖的标准库实现因不完善或配置问题等与标准规定的接口的偏差。

@5.2.1.6 YTest ：
提供软件测试需要的一些功能的辅助库。

@5.2.2 YCLib ：
 YCLib 包含平台相关的 API 包装和若干接口平台中立的独立子库（按头文件路径划分，参见 @5.4.1 ）。
 YCLib 允许接口平台中立的接口具有实现定义的行为差异。
除非另有说明， YCLib 仅保证非成员或静态成员函数的线程安全性。
平台定义文件 Platform.h 不包含其它文件。

@5.2.2.1 环境资源占用：

@5.2.2.1.1 DS 计时器：
 build 291 前占用计时器 0 和计时器 1 。
 build 291 起占用计时器 2 。
占用计时器用于实现计时接口。若用户占用计时器或修改计数，则计时相关接口结果未定义。

@5.2.2.2 实现定义行为：

@5.2.2.2.1 对于未说明字符串参数编码的文件操作接口：
必要时的编码转换使用 CHRLib(@2.5) 。
 DS 直接使用 UTF-8 路径，或 UCS-2LE 转换得到的 UTF-8 路径，使用标准库函数或 POSIX 文件操作。
 MinGW32 直接使用 UCS2-LE 作为 UTF-16LE 路径，或 UTF-8 转换得到的 UCL2-LE 路径，使用 _w 起始的 MSVCRT 文件函数。

@5.2.2.3 平台 API 使用策略：

@5.2.2.3.1 Win32 API ：
需要 #undef 消除引起冲突的宏名，尽可能显式使用带后缀的函数（若存在）。
当存在后缀时，一般尽可能使用 W ，因为大部分情况下 W 后缀为原始版本， A 后缀需要转换间接调用 W 后缀版本。
但也存在例外， 如使用 ::OutputDebugStringA 。此时注意应该使相关字符串保持和 ANSI 及相关代码页的编码兼容，一般应仅使用 ASCII 。
不使用被标记为过时的 API 如 IsBadReadPtr 。

@5.2.2.3 平台文件：
引入平台相关特性。

@5.2.2.3.1 <Platform.h> ：
定义了必要的平台支持。
对正式支持的平台定义 YCL_ 起始的宏，保证替换得到的值非零。使用 #if （而不需要 #ifdef ）直接检测这些宏以确定是否支持。

@5.2.2.3.2 <NativeAPI.h> ：
定义了扩展的平台 API 。

@5.2.3 DS 平台库和标准库实现：
目标平台 DS ，实现环境参见 @5.1 。
使用 devkitPro（参见 http://devkitpro.org ） 中的 devkitARM 工具链及库文件的非 debug 版本。
依赖 devkitARM / libnds / default arm7 / libfat 版本：
 build 131 前：
未指定。可使用 devkitARM release 26 - 29 。
 2009-09-20 起：
 libnds 1.3.7 / default arm7 0.5.6 。
 2009-09-22 起：
 devkitARM release 26 / libnds 1.3.8 / libfat 1.0.4 。
 2009-12-12 起：
 devkitARM release 27 / libnds 1.4.0 / default arm7 0.5.8 / libfat 1.0.6 。
 2010-03-25 起：
 devkitARM release 29 / libnds 1.4.3 / default arm7 0.5.12 / libfat 1.0.7 。
 2010-04-06(build 131) 起：
 devkitARM release 30 。
 2010-08-08(build 139) 起：
 devkitARM release 31 / libnds 1.4.5 / default arm7 0.5.14 。
 2010-09-19(build 244) 起：
 default arm7 0.5.15 。
 2010-11-18(build 171) 起：
 devkitARM release 32 / libnds 1.4.8 / default arm7 0.5.17 。
 2011-01-06(build 180) 起：
 libnds 1.4.9 / default arm7 0.5.18 。
 2011-02-16(build 192) 起：
 libnds 1.5.0 / default arm7 0.5.20 / libfat 1.0.9 。
 2011-06-24(build 221) 起：
 devkitARM release 33 / libnds 1.5.0 / default arm7 0.5.20 。
注：文件系统目录访问接口变化，需要使用 devkitARM release 33 或自行配置所需的 POSIX API 。 
 2011-07-03(build 223) 起：
 libnds 1.5.1 / default arm7 0.5.21 。
 2011-07-05(build 223) 起：
 devkitARM release 34 。
 2011-08-27(build 236) 起：
 libnds 1.5.4 / default arm7 0.5.23 。
 2011-10-13(build 252) 起：
 devkitARM release 35 / libfat 1.0.10 。
 2012-03-06(build 291) 起：
 devkitARM release 37 。
 2012-04-12(build 300) 起：
 devkitARM release 38 / libnds 1.5.5 / default arm7 0.5.24 。
 2012-05-03(build 306) 起：
 devkitARM release 39 / libnds 1.5.7 。
 2012-05-14(build 308) 起：
 devkitARM release 40 / libfat 1.0.11 。
 2012-06-29(build 321) 起：
 devkitARM release 41 。

@5.2.4 MinGW32 平台库和标准库实现：
目标三元组(target triplet) i686-w64-mingw32 ，操作系统 Windows XP/Windows Server 2003 及以上。
 build 299 前：
无（不支持的平台）。
 2012-04-09(build 299) 起：
使用 http://code.google.com/p/mingw-builds 的 i686-mingw32-gcc-4.7.0-release-c,c++,fortran-sjlj 。
 2012-06-21(build 319) 起：
使用 http://sourceforge.net/projects/mingwbuilds/files/windows-host/4.7.1/release/i686-mingw-w64-gcc-4.7.1-release-c,c++,fortran-sjlj.7z 。
此版本于 2012-10-06 确认已被移除。
 2012-10-06(build 346) 起：
使用 http://sourceforge.net/projects/mingwbuilds/files/host-windows/releases/4.7.2/32-bit/threads-posix/sjlj/x32-4.7.2-release-posix-sjlj-rev0.7z 。
此版本于 2013-01-20 确认已被重命名为 x32-4.7.2-release-posix-sjlj-rev0.7z 。
 2013-03-23(build 392) 起：
使用 http://sourceforge.net/projects/mingwbuilds/files/host-windows/releases/4.8.0/32-bit/threads-posix/sjlj/x32-4.8.0-release-posix-sjlj-rev0.7z 。

@5.3 通用库：

@5.3.1
 build 207 前使用 Loki 库的智能指针实现句柄。

@5.4 专用库：
包含于 YFramework 中的子库。
关于 CHRLib ，参见 @2.5 。
关于 Helper ，参见 @2.6 。
关于 NPL ，参见 @2.7 。
本节余下内容描述第三方专用库。

@5.4.1
字体输出使用 FreeType2（参见 http://www.freetype.org ） 实现向量字体光栅化支持。

@5.4.1.1 使用版本：
 build 185 前：
头文件版本： 2.3.12 。
库文件版本：在 VNDS 源代码中提取的 2.3.6 。
 build 185 起：
头文件版本： 2.4.4 。
库文件版本：使用当时 devkitPro(@5.2.3) 编译的对应版本，使用 makefile 宏 CFLAGS ?= -c -g -O3 -Wall 。
库配置： modules.cfg 配置包含以下有效行：
FONT_MODULES += truetype
FONT_MODULES += sfnt
HINTING_MODULES += autofit
HINTING_MODULES += pshinter
RASTER_MODULES += smooth
AUX_MODULES += cache
AUX_MODULES += gzip
AUX_MODULES += psnames
BASE_EXTENSIONS += ftbitmap.c
BASE_EXTENSIONS += ftglyph.c
使用 makefile 宏 CFLAGS ?= -c -g -O3 -Wall 。
 build 223 rev 31 起：
头文件版本： 2.4.5 。
库配置：  modules.cfg 配置追加以下有效行：
BASE_EXTENSIONS += ftbbox.c
BASE_EXTENSIONS += ftstroke.c
BASE_EXTENSIONS += ftsynth.c
其它配置不变。
 build 224 rev 34 起：
使用 2.4.4 的 /src/cache 源文件代替 2.4.5 对应部分并重新编译库文件（以修正不明原因的 FontCache::GetAscender 的结果错误）。
其它配置不变。
 build 266 起：
头文件版本： 2.4.8 。
库文件版本：使用 2.4.4 的 /src/cache 源文件代替 2.4.8 对应部分，用当时 devkitPro(@5.2.3) 编译的对应版本。
其它配置不变。
 build 292 起：
头文件版本： 2.4.9 。
库文件版本： 2.4.9 用 devkitPro(@5.2.3) 编译的对应版本。
 build 299 起：
增加 MinGW32 库文件版本： 2.4.9 使用当时 MinGW32(@5.2.4) 编译的对应版本，使用 mingw32-make 直接构建默认提供的 makefile 。
 modules.cfg 配置不变。
 build 318 起：
头文件版本： 2.4.10 。
 DS 库文件版本： 2.4.10 使用 devkitPro 编译的对应版本。
 MinGW32 库文件版本： 2.4.10 使用当时 MinGW32(@5.2.4) 编译的对应版本。
其它配置不变。
 2012-12-21(build 366) 起：
头文件版本： 2.4.11 。
 DS 库文件版本： 2.4.11 使用 devkitPro(@5.2.3) 编译的对应版本。
 MinGW32 库文件版本： 2.4.11 使用当时 MinGW32(@5.2.4) 编译的对应版本。
其它配置不变。
 2013-05-19(build 406) 起：
测试发现 2.4.12 库在 DS 上的性能显著降低，因此暂不升级；仅重新编译减小二进制文件大小。
头文件版本不变。
 DS 库文件版本： 2.4.11 使用 devkitPro(@5.2.3) 去除 -g 选项（减小文件体积）重新编译的对应版本。
 MinGW32 库文件版本： 2.4.11 使用当时 MinGW32(@5.2.4) 重新编译的对应版本。
库配置和 DS 库构建文件已添加至版本库，参见 "3rdparty/freetype/builds/ds/modules.cfg" 。
 modules.cfg 配置移除以下有效行：
HINTING_MODULES += pshinter
AUX_MODULES += gzip
BASE_EXTENSIONS += ftbbox.c
其它配置不变。

@5.4.2
图形库：修正的 Anti-Grain Geometry 库 V2.4 。
已移除。

@5.5 库基础结构：
平台设置在 <Platform.h>(@5.2.2.3.1) 中。
除了 MinGW32 的平台运行时外，所有外部链接库为静态库。除了 YCLib 外，对外部库未经过封装的使用仅在 Adaptor 中。这样有利于以子库为单位的移植。

@5.6 全局命名空间：
除了使用标准库命名空间 std 外如下所列。

@5.6.1 标准库实现提供的附加命名空间：
 __gnu_cxx ： libstdc++ 扩展，可被 YBase::LibDefect 和 YFramework::YSLib::Adaptor 使用。

@5.6.2 YBase 引入的命名空间：
 YBase 使用的命名空间。
 ystdex ：从 std 扩充的平台无关的实用程序 YStandard 。 YSLib 本体直接依赖于此命名空间。
 ytest ：测试框架设施 YTest 。

@5.6.3 YFramework 引入的命名空间：
参见 @2.1.2 。

@6 编码风格导引：
仅叙述之前章节未涉及的内容。
基本内容参见 [Documentation::CommonRules @@6] 。

@6.1 源代码嵌入文档：
使用 Doxygen 。
编码适应大多数源文件，默认为 UTF-8 。
默认语言为简体中文。

@6.1.1 注释风格：
使用简化的（去除可以省略的星号后的） Qt 风格的注释。
分行例外（默认参见 [Documentation::CommonRules @@6.4.1] ）： URL 链接等超出默认行宽时可在同一行（无法生成正确的代码）。

@6.1.2 指令同义词：
当多种指令等价时使用 Doxygen 手册中直接说明（而非指示同义词即 "Equivalent to" ）的一项。
例外：
对外部参考使用 \see 而不是 \sa ；
 \throw 指显式抛出异常， \exception 指内部调用间接抛出的异常。

@6.1.3 指令行风格：
组(group) 相关指令（ \defgroup 、 \ingroup 、 \name 等）、实体标识指令（ \def 、 \fn 等）以及 \author 、\par 、 \sa 、 \since 、 \version 不使用句为单位（不使用全角标点）；其它指令后的内容以句为单位（对于中文注释以全角标点结束；不成句的不视为完整的注释）。
实体注释中详细注释放在最后。组相关指令在最前（且在注释首行使用水平制表符缩进），然后是实体标识指令（，除了 \def 外一般省略），之后是其它指令。

@6.1.4 指令顺序：
指定顺序的实体注释指令： \brief 、 \tparam 、 \param 、 \pre 、 \post 、 \return 、 \throw 、 \exception 、 \note 、 \warning 、 \bug 、 \deprecated 、 \relates 、 \sa 、 \see 、 \since  、 \todo 。
其它参见 http://drupal.org/node/1354#links 。

@6.2 YFramework 接口：

@6.2.1 YFramework 宏使用：
 YLSib 和 YFramework 中依赖 YSLib 的项目尽量使用 YSLib::Core::YBaseMacro([Documentation::YSLib @@3.1]) 定义的宏，而不是其展开形式：
使用宏 YSL_BEGIN 和 YSL_END 标识 YSLib 命名空间；
使用宏 YSL_BEGIN_NAMESPACE 和 YSL_END 标识 YSLib 命名空间下的子命名空间；
使用宏声明接口类型([Documentation::CommonRules @@2.4.1]) ；
使用宏 DefDe* 声明默认的特殊成员函数；
使用宏 DefDel* 声明删除的特殊成员函数；
使用宏 Impl* 表示公开实现（提供定义）的非模板成员函数的函数体；
使用宏 DefEmptyDtor 在类定义内定义空析构函数，除非需要显式的异常规范；
使用宏 PDefH 和 Impl* 实现成员函数，除非无法用宏 Impl* 简单表示其定义。

@7 一般实现导引：
自定义应用程序 Shell 类，继承默认 Shells::Shell 类或其派生类并产生实例。
完成自定义 Shell 类的消息处理过程。一般把多个处理过程的响应封装为单一函数。
对于支持实现对应 Shell 的窗口封装为窗体（Form）类（一般继承自 Window 类），在此自定义类中添加所需的 GUI 部件的定义，并实现界面效果。
在响应 SM_ACTIVATED 的处理过程中添加需要初始化的资源或子 Shell ，在 SM_DEACTIVATED 的处理过程中添加退出程序或转移线程控制权的指令。
在响应输入等事件消息的处理过程中添加对应的代码。

@7.1 初始化：
需要保证主 Shell 句柄在应用程序实例初始化之后初始化，基类 Shell 的构造函数调用了 Application 的非静态成员函数。

*/
////

