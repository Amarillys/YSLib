/*
	© 2014 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2013.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2013 年度。
\version r174
\author FrankHB <frankhb1989@gmail.com>
\since build 464
\par 创建时间:
	2014-01-01 00:46:52 +0800
\par 修改时间:
	2014-02-10 13:51 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2014
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2014-01:

report.impl:
The MinGW.org and MinGW-W64 runtime can be distinguished by predefined macros, though version macros are not predefined:
	See http://sourceforge.net/mailarchive/forum.php?thread_name=CAEwic4b-B8%3DQ%3DSV2ptwO36SsCQW%2B6b0N%3DX41t3NHPoDQV%2BKeTw%40mail.gmail.com&forum_name=mingw-w64-public .
	See also http://sourceforge.net/p/predef/wiki/Compilers/ .
There may be some wrong impression of border thickness due to the colors.
	It is easy to see the left vertical line of boundary of the checkbox is thicker in setting panel with violet background.
	When the panel background color is some lighter, here is no such illusion.
	Indeed they have the same thickness. It would be obvious after zoomed (esp. > 2x).
	Actually, no rendering code of checkbox has been changed.
Both the runtime from MinGW.org and MinGW-W64 support multiple versions of Microsoft Visual C++ library(MSVCRT). There are some issues:
	Different verstions of MSVCRT define different symbols with some subtle problems. So they should be same in different toolchain configurations for best compatibility.
		Both of them support at least version 6.0, which is probably the most wide-adopted by Microsoft Windows(they came by default install). The library file name is "msvcrt.lib" for Microsoft Visual C++, accordingly "msvcrt.dll" of the dynamic library and "libmsvcrt.a" as static library for both runtime.
			Though acceptable, but deployment depend on it is not good. The are not publicly guaranteed to be compatible within different versions of Windows.
		For newer versions, the dyanmic libraries name schema is "msvcrXX.dll", in which "XX" is the corresponding concatenated Microsoft Visual C++ main and minor version numbers. For example "msvcrt90.dll" is of VS2008.
			The architecture names (such as "x86" or "amd64") are not related of the file names.
			They are required to be deployed along with the applications, or the end users might able to install correspoinding version of Microsoft Visual C++ Redistributable Package.
		MinGW.org uses 6.0 as default. Things about MinGW-W64 are some complicated, see below.
		Currently MinGW.org's distribution has "libmsvcrt.a", "libmsvcp60.a"(the C++ runtime of VC++ 6.0), and "libmsvcr70.a" to "libmsvcr100.a"(the whole "XX" are 70, 71, 80, 90, 100). It also has corresponding debug versions for latter, i.e. "libmsvcr70d.a" to "libmsvcr100d.a". No newer MSVCRT are supported.
		On the other hand, MinGW.org's distribution also has "libmsvcrt.a", "libmsvcp60.a", and "libmsvcr80.a" to "libmsvcr100.a", but neither other versions("libmsvcr70.a", "libmsvcr71.a") nor debug libraries. However, it has "libmsvcr110.a", which MinGW.org's does not supported.
	There is one extra library, "oldname.lib", to contains the original version of symbol names deprecated by Microsoft (such as POSIX-specific functions, because they are not strictly comforming to ISO C), to map to new names(usually added prefix underscore).
		They are also different in MinGW.org's and MinGW-W64's runtime. There are "libmoldname.a" and "libmoldnameXX.a"("XX" here is also the version numbers, see above) for the former, and only one "libmoldname.a" for the latter.
		See http://sourceforge.net/mailarchive/message.php?msg_id=30556805 .
	Most notable problem is backward compatibility. For example if new "secure" functions(ISO TR 24731-1) like "scanf_s" are used, MSVCRT older than version 8.0 can not be used.
		Actually it is not version 6.0 of MinGW-W64's "libmsvcrt.a". It even exports "__gmtime32" comes from version 8.0.
	Both toolchains use the same built-in specs in compiler driver for use of these libraries, i.e. "-lmsvcrt".
		For better compatiblity, lirary not older than "libsvcrt80.a" should be put explicitly in the linker options to override the default linked "libmsvcrt.a".
		Allocation and deallocation should always be carefully matched within the boundary, i.e. make sure the allocation function and deallocation function for same storage are from the same library.
		Using 2 C runtime library and directly overriding symbols are dangerous.
			Note that libgcc, startfiles or some other library with "atexit" or thread-local storage can be involved with C runtime library's free storage allocation.
		Specs file can be used to specifying completely substition of the C runtime library. It is safer but less convenient.
	Both define the macro "__MSVCRT_VERSION__" in <_mingw.h> to control what version of MSVCRT used.
		If not explicitly specified (i.e. not defined "__MSVCRT_VERSION__" before inclusion of <_mingw.h> or through command line option), both would defined a hard-coded integer value.
		The default values in the libraries are different. It is "0x0600" in MinGW's but "0x0700" in MinGW-W64's.
		A subtle problem is, which not only effected by the version macro. One notable extra macro is "__STRICT_ANSI__", which introduced by several GCC compiler options like "-ansi" or "-pedantic".
		There is a horrible bug in the MinGW.org's <time.h>: if "__MSVCRT_VERSION__ >= 0x800" and "__STRICT_ANSI__" is also defined, then some ISO C functions like "time" are not declared.
			This directly caused <ctime> of libstdc++ (which has 'using ::time;', etc) unusable.
			Maybe more similar bugs, also in different headers.
	The "YFramework.dll" can compiled from b464 after some changes in "YCLib/FileSystem.cpp" but cannot be linked as DLL without changes of some project options.
		The error is of the unresolved symbol "_gmtime32", comes from "pngwrite.o" in "libFreeImage.a".
			It is introduced directly by a call of "gmtime" in function "png_convert_from_time_t" when the configure macro "PNG_CONVERT_tIME_SUPPORTED" is defined.
				The "PNG_CONVERT_tIME_SUPPORTED" configuration is not supported by every platforms, for example Windows CE.
				It is considerable to remove "PNG_CONVERT_tIME_SUPPORTED" in "pnglibconf.h". But it is not a fix for the problems here.
			Currently FreeImage is built with MinGW-W64 toolchain.
			Actually both toolchains can map "gmtime" to "_gmtime32".
			The reason of failure for MinGW.org is that "_gmtime32" is not contained by "libmsvcrt.a" of MinGW.org's, but do contained by MinGW-W64's.
	There are several optional version of MSVCRT containing "_gmtime32", but no one are proper for this scene.
		No MSVCRT 7.0 and 7.1 available for MinGW-W64 toolchain.
		The deployment of MSVCRT 8.0 and 9.0 makes a lot of trouble, if there is no manifest provided.
			For side-by-side assemblies, see http://msdn.microsoft.com/en-us/library/ms235624%28v=vs.80%29.aspx .
			For newer VC++ deployment, see http://stackoverflow.com/questions/6623780/visual-c-2010-changes-to-msvc-runtime-deployment-no-more-sxs-with-manifest .
		For MSVCRT 10.0, symbols "_wstat", "_imp__findfirst" and "_imp__findnext" are not defined.
		No MSVCRT 11.0 or newer available for MinGW.org toolchain.
	Though rebuilt libraries are needed sooner or later, now it is better to have a fix in the project configurations.
		For maintaince reason, the configuration should be the same, without need for users to select one out of two set of configurations.
		Note that a value of "__MSVCRT_VERSION__" not less than 0x0800 causes bugs in MinGW.org's headers when "__STRICT_ANSI__" is defined.
			If this macro is set, only 0x0600 to 0x0700 can be used.
			This macro can be set explicitly to 0x0600 for compatibilities (also for library rebuild).
		For convenience and sanity, no manifest should be introduced.
			There is even no dependency on MSVCRT other than "libmsvcrt.a" in MinGW-W64. It is only to be compatible with the buggy MinGW.org runtime.
			Though introduced a newer dependency, it is somewhat acceptable. YFramework might use some features in that newer version of MSVCRT.
			To introduce manifest only for MinGW.org's compatibility is too expensive.
		Note that mix use of different versions of MSVCRT is dangerous.
		It is relatively safe to use a newer library together with older headers.
		So the final resolution is to implement a custom "_gmtime32" function for MinGW.org toolchain.
Currently object files compiled with '-ffunction-sections -fdata-sections' for GNU ld with '--gc-sections' doesn't work for MinGW PE-COFF targets. It might be fixed in future.
	See https://sourceware.org/bugzilla/show_bug.cgi?id=11539 .
	See http://cygwin.com/ml/binutils/2012-08/msg00216.html .
	See http://sourceforge.net/mailarchive/forum.php?thread_name=CALc40c_v46OnoopJXWbPpQk651JAxWU3UYFmDJy998mPKzD9DA%40mail.gmail.com&forum_name=mingw-w64-public .
Skin is the top level of GUI an application's shell to reflect look and feel. For a reusable GUI toolkit, a visual style is a set of visualized features for UI elements, being a major part of the skin.
YFramework should implement the visual style support. It has been planned from very early reversions.
	Basically, the styles are not for each widgets. They are only effective to style-related widgets.
	The major interface is of namespace "YSLib::UI::Styles", providing abstraction to be stored within the GUI state.
	The previously implemented interface is the palette, which contains a vector of colors to be used in style-related widgets rendering.
	Now the visual style states should be implemented as sets of runtime swichable states.
		The style should be swichable by user code via the GUI state interface. It is the wrapper of the major interface.
		For convenience, the type "string" is used as the key to identify a style.
		It is intended that switching of styles should take effect on classes of widgets. For each paticular instance of widgets, it should be possibly doable to switch in future.
		Switching to a different style should be efficient. That means iteration of each widgets to modify the state is generally inacceptable.
		The basic idea is to bind each styled rendering process as an event handler with parameter type 'PaintEventArgs&&' and to be added to event 'Paint' of the target widget instance.
		The binding of event handler needs a type containing the common implmentation against to code bloat. If per widget style state can also supported here if necessary.
		There should be a way to identify the widget class types. Indexable RTTI type ('std::type_index') is preferred for convenience.
		Choice has been made for the lower layer of the implemention details:
			Static polymorphism is not feasible for some runtime-determinated properties.
			Both interface types(i.e. polymorphic classes having only pure virtual member functions) and manually indexing of handlers are feasible.
			Pros of interface types:
				It is flexible to describe complex details.
				Different sets of explicitly-typed shared state can be stored in the implementation directly.
				Type safety is easily gained through function signatures.
				Inheritance can reduce some common code.
			Cons of interface types:
				Probably more code to write. In the worst case, each interface type should provided to corresponding style-related widget class manually, being hard to reuse.
				Some extraordinary code bloats, linear complexity of total number of style-related widgets.
				Performance decreased for unnecessary virtual calls, though can be optimized away, but not guaranteed and likely not. Note that dispatch of event handler calls are already polymorphic in runtime through 'std::function'.
				It is difficult to use because the concrete interface type should be get statically. This causes it impossible to store all interface types for different widget classes together within the same GUI state without some tricks.
					Type erause or base interface type can be used. Both are expensive in performance and inconvenient to implement.
					Explicitly casts should be used for each binding, obviously inconvenient.
				The ABI is likely complex and not steady. Modifying interface of per class interface is very likely to leads to the user code to be built again.
			Pros of manually indexing of handlers:
				It is simple and direct for event handler binding.
				Code generation and performance is easier to control by the user.
				It is flexible and convenient to use.
				The ABI is likely simpler, and steady when no modification to the indices.
				Indices can have aliases through enumerator or 'const' object declarations.
			Cons of manually indexing of handlers:
				Some lower level details can not be exposed through the interface, which can be inconvenient to use.
				The handler type is limited to event 'Paint'. If needed, the major style interface should be modified.
				Shared states can be supported through the interface should be unique.
					If needed, some additional interface should be added to the GUI state.
					Type erasure or similar techniques can be used to get some intended effects.
				Almost no higher level of optimization at all. The implementation of the language is not aware to the indexing.
			For current requirements, the latter is better.
				It is easy to implement and use.
				It is not very hard to add functionality. Although if needed, the major interface might be modified, but not very probable.
				Indices are not needed to be assigned manually if using enumeration type.
ISO C++11 still uses copy elision for some cases as C++03. There are some special rules.
	See ISO C++11 12.8/31 for conditions.
	If these requirements are met, move constructor of a class can be selected by the overloading resolution without explicitly using 'std::move' or rvalue reference cast. See ISO C++ 12.8/32 for details.
	See also http://isocpp.org/blog/2012/12/quick-q-a-unique-ptr-is-not-copyable-so-why-can-i-return-one-by-value-stack .
Since now ISO C++11 is mandated '<::' to be distinguished as '<' and '::' but not '<:' and ':' if the consequence character is not '>' or ':' , no need to always add space to between '<' and '::'.
	G++ 4.7.1 has not supported.
	G++ 4.8.2 is conforming.

$2014-02:

report.impl:
Trailing path delimiters are allowed in YCLib::FileSystem.
	IEEE POSIX-1003.2 allowed trailing slashes.
		See http://mail-index.netbsd.org/tech-kern/2002/04/28/0016.html .
	Windows API 'FindFirstFile' does not expect trailing delimiters in pattern, so preprocessing of the path string is needed.
		Some implementations may only consider one delimiter. See 'diropen' implemented by MinGW.org.
Both slashes and backslashes can be supported as file system delimiter by Windows API.
	Adding prefix '\\?\' can ignore 'MAX_PATH' limitation and enable large path support.
		Not all API support it.
		Currently, YCLib do not explicitly use it.
	See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%28v=vs.85%29.aspx .

////

